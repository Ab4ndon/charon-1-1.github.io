<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里云CDN加速域名解析冲突问题</title>
    <url>/2020/10/11/ALi/</url>
    <content><![CDATA[<p>自己的个人博客搭建了也有一段时间了，以前部署在Gitee上访问速度还行，后来部署到GitHub后速度是一天不如一天了，于是想看看能不能加速一下，看了看网上的做法，我选择采用CDN加速域名。</p>
<p>首先，你需要将域名进行备案，备案完成后才能进行后续操作。</p>
<p>然后我选择的是阿里云的CDN（腾讯云貌似有6个月的免费试用，但是由于我是阿里云的域名，去腾讯云搞又得在那边域名备案，就放弃了）</p>
<p>前面按照网上的步骤走都没啥问题，但当进行到向域名解析中添加一条CNAME记录时显示与A解析冲突（<strong>A解析是当初绑定域名的时候添加的</strong>），我看了看阿里云提供的Tip，但是我还是不太明白怎么操作，尝试将原来的A解析删除，换成CNAME，换完发现我的博客直接502了。后来联系阿里云客服才将问题解决。</p>
<p>如果你也出现了同样的问题，首先，你检查一下你将顶级域名添加到CDN时设置的源站IP是不是A解析记录里的那个IP（我犯的错是将源站IP设置成了阿里云服务器的IP），如果不是，改过来，然后删除A解析，添加CNAME解析（CNAME解析的添加根据提示做就行了），然后就大功告成了。</p>
<hr>
<p>u1s1,阿里云的客服态度蛮好的，晚上10点多了还为我耐心解答问题，在此致谢！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>CDN 解析冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析之二分搜索_合并排序_快速排序</title>
    <url>/2021/03/22/Algorithm-code/</url>
    <content><![CDATA[<pre><code class="line-numbers language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt;
class SortableList
{
    public:
        SortableList(int mSize,int n,T*a);
        ~SortableList();
        int BSearch(const T&amp;x,int left,int right)const;  //把整个函数修饰为const，意思是“函数体内不能对成员数据做任何改动”。
        int BSearch_DieDai(const T&amp;x,int n) const;
       void Merge(int left,int mid,int right);
       void MergeSort();
       void MergeSort(int left,int right);
       void Output();

       void Swap(int &amp;a, int &amp;b);
       int Partition(int left,int right);
       void QuickSort();
       void QuickSort(int left,int right);

    private:
        T*l;
        int maxSize;
        int num;

};
//构造函数
template&lt;class T&gt;
SortableList&lt;T&gt;::SortableList(int mSize,int n,T*a)
{
    l=a;
    maxSize=mSize;
    num=n;
}
//析构函数
template&lt;class T&gt;
SortableList&lt;T&gt;::~SortableList()
{
    delete[]l;
}

/*********************************** 二分搜索 ****************************/
//采用递归的二分搜索
template&lt;class T&gt;
int SortableList&lt;T&gt; ::BSearch(const T&amp;x,int left,int right)const
{
    if(left&lt;=right)
    {
        int m=(left+right)/2;
        if(x&lt;l[m]) 
            return BSearch(x,left,m-1);
        else if(x&gt;l[m])
            return BSearch(x,m+1,right);
        else return m;
    }
    return -1;
}
//采用迭代的二分搜索（尾递归改迭代）
template&lt;class T&gt;
int SortableList&lt;T&gt;::BSearch_DieDai(const T&amp;x,int n)const
{
    int m,left=0,right=n-1;
    while(left&lt;=right)
    {
        m=(left+right)/2;
        if(x&lt;l[m])  
            right=m-1;
        else if(x&gt;l[m])  
            left=m+1;
        else 
            return m;
    }
    return -1;
}

/******************************* 合  并  排  序 ************************************/

template &lt;class T&gt;
void SortableList&lt;T&gt;::MergeSort()
{
    MergeSort(0,num-1);
}
template&lt;class T&gt;
void SortableList&lt;T&gt;::MergeSort(int left,int right)
{
    if(left&lt;right)
    {
        int mid = (left+right)/2;
        MergeSort(left,mid);
        MergeSort(mid+1,right);
        Merge(left,mid,right);
    }
}

template &lt;class T&gt;
void SortableList&lt;T&gt;::Merge(int left, int mid, int right)
{                                      //a数组为待排序的数组 
    T* temp =new T[right - left + 1]; //temp数组用来暂时保存排序好的数组 
    int i = left, j = mid + 1, k = 0; //left 至mid为左半数组 ，mid+1至right为右半数组 
    while((i &lt;= mid)&amp;&amp;(j &lt;= right))  //对应第一步 当左半数组和右半数组都不为空时 
        if(l[i] &lt;= l[j])             //输出两个数组中的较小者 
            temp[k ++] = l[i ++];
        else
            temp[k ++] = l[j ++];
    while(i &lt;= mid)                  //当一数组为空时，输出另一数组的剩余元素 
        temp[k ++] = l[i ++];
    while(j &lt;= right)                //当一数组为空时，输出另一数组的剩余元素 
        temp[k ++] = l[j ++];
    for(i = 0, k = left; k &lt;= right;) //将temp数组赋值给原数组 
        l[k ++] = temp[i ++];
}
 

template&lt;class T&gt;
void SortableList&lt;T&gt;::Output()
{
    for(int i = 0; i &lt; num; i++)
        cout &lt;&lt; l[i] &lt;&lt; " ";
    cout &lt;&lt; endl &lt;&lt; endl;
}

/********************************** 快  速  排  序 ***********************************/

template&lt;class T&gt;
void SortableList&lt;T&gt;::Swap(int &amp;a, int &amp;b)
{
    int t = a;
    a = b;
    b = t;
}

template &lt;class T&gt;
int SortableList&lt;T&gt;::Partition(int left,int right)
{
    if(left&gt;=right)
    {
        cout&lt;&lt;"下标范围有误，请确保left&lt;right!"&lt;&lt;endl;
        return 0;
    }
       
    int i = left,j = right +1;
    do 
    {
        do i++; while (l[i]&lt;l[left]);
        do j--; while (l[j] &gt; l[left]);
        if(i &lt; j) Swap(i,j);
    }while(i &lt; j);
    Swap(left,j);
    return j;
}

template &lt;class T&gt;
void SortableList&lt;T&gt;:: QuickSort()
{
    QuickSort(0,num-1);
}

template&lt;class T&gt;
void SortableList&lt;T&gt;:: QuickSort(int left,int right)
{
    if(left&lt;right)
    {
        int j = Partition(left,right);   
        if(j-left&lt;=right-j)                  //为了减少系统栈的深度，一般都会将长的子序列的上下界进栈         
        {                                    //先处理短的子序列
            if(j-left&gt;1)                     
            {
                QuickSort(left,j-1);
                QuickSort(j+1,right);
            }
        }else
        { 
            if(right-j&gt;1)
            {
                QuickSort(j+1,right);
                QuickSort(left,j-1);
            }
        }
    }
}

/************************************ main 函数 ***********************************/
int main()
{
    int a[5]={2,3,1,4,5};
    SortableList&lt;int&gt; list =SortableList&lt;int&gt;(5,5,a);
    int k = list.BSearch(4,0,4);
    int j = list.BSearch_DieDai(4,6);
    cout&lt;&lt;k;
    cout&lt;&lt;j;
     cout &lt;&lt; "排序前："&lt;&lt;endl;
    // for (int i = 0; i &lt; 5; i++)
    //     cout &lt;&lt; a[i] &lt;&lt; ' ';
    // cout &lt;&lt; endl;
    list.Output();
    list.MergeSort();
    cout &lt;&lt; "归并排序后："&lt;&lt;endl;
    // for (int i = 0; i &lt; 5; i++)
    //     cout &lt;&lt; a[i] &lt;&lt; ' ';
    // cout &lt;&lt; endl;
    list.QuickSort();
    list.Output();
    cout &lt;&lt; "快速排序后："&lt;&lt;endl;
    list.Output();
    return 0;
}
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法设计与分析  C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Android</title>
    <url>/2021/03/17/Android/</url>
    <content><![CDATA[<h4 id="1-边框圆角化"><a href="#1-边框圆角化" class="headerlink" title="1.边框圆角化"></a>1.边框圆角化</h4><pre><code class="line-numbers language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle"&gt;
    &lt;!-- 填充的颜色 --&gt;
    &lt;solid android:color="#EEB422" /&gt;
    &lt;!-- android:radius 弧形的半径 --&gt;
    &lt;!-- 设置按钮的四个角为弧形 --&gt;
    &lt;corners
        android:radius="20dip" /&gt;
    &lt;!--也可单独设置--&gt;
    &lt;!-- &lt;corners --&gt;
    &lt;!-- android:topLeftRadius="10dp"--&gt;
    &lt;!-- android:topRightRadius="10dp"--&gt;
    &lt;!-- android:bottomRightRadius="10dp"--&gt;
    &lt;!--  android:bottomLeftRadius="10dp"--&gt;
    &lt;!--   /&gt;  --&gt;
    **设置文字padding**
    &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt;
    &lt;padding
        android:left="5dp"
        android:top="3dp"
        android:right="5dp"
        android:bottom="3dp"
        /&gt;
&lt;/shape&gt;
</code></pre>
<h4 id="2-背景颜色渐变"><a href="#2-背景颜色渐变" class="headerlink" title="2.背景颜色渐变"></a>2.背景颜色渐变</h4><pre><code class="line-numbers language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;!--实现应用背景颜色渐变--&gt;
    &lt;gradient
        android:startColor="#FFF8DC"
        android:endColor="#FFE1FF"
        android:angle="270"/&gt;
    &lt;corners
        android:radius="20dip"
        android:topLeftRadius="0dp"
        android:topRightRadius="0dp"/&gt;
&lt;/shape&gt;
</code></pre>
<h4 id="3-Button背景色修改无效"><a href="#3-Button背景色修改无效" class="headerlink" title="3.Button背景色修改无效"></a>3.Button背景色修改无效</h4><p>找到main/res/values/themes.xml文件</p>
<p>将其中的<code>&lt;style name="Theme.MyRegistration" parent="Theme.MaterialComponents.DayNight.DarkActionBar"&gt;</code></p>
<p>修改为<code>&lt;style name="Theme.MyRegistration" parent="Theme.MaterialComponents.DayNight.DarkActionBar.Bridge"&gt;</code>即可</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android UI</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF 《Ezfileinclude》 wp</title>
    <url>/2020/07/25/DASCTF/</url>
    <content><![CDATA[<p><img src="/2020/07/25/DASCTF/image-20200725170156404.png" alt="image-20200725170156404"></p>
<p>没错，就是这么残忍。直接把我0封了。<img src="/2020/07/25/DASCTF/image-20200725180746269.png" alt="image-20200725180746269"></p>
<img src="/2020/07/25/DASCTF/image-20200725180804349.png" alt="image-20200725180804349" style="zoom:67%;">

<p>后来在大佬的反复提示帮助之下，勉强解出第一题《Ezfileinclude》,下面记录一下自己的挨打历程。</p>
<p>打开靶机，页面显示的是一张图片<img src="/2020/07/25/DASCTF/image-20200725180822011.png" alt="image-20200725180822011" style="zoom:67%;"></p>
<p>查看源码，没太多有用的信息，唯一比较特殊的话是这找图片的url:<code>**image.php?t=1595643210&amp;f=Z3F5LmpwZw==**</code></p>
<p>看到f=后面那一串东西，一下子想到了base64编码，尝试解一波码，解出来<code>gqy.jpg</code>，先留着，说不定有用。</p>
<p>试了一下image.php,回显：<strong>you miss some parameters</strong>（你漏掉了一些参数）奥，可能后面的t,f也得跟着，复制粘贴上去，再回车，页面回显：<strong>what’s your time ?</strong></p>
<p>作为一个萌新，我一度怀疑这是不是什么CTF黑话，特意百度了一波 <em><strong>CTF what’s your time?</strong></em>  好吧，并不是，想了想，可能是要给time这个参数赋值，盲猜可能是URL中的t参数，试着把t参数删掉，回车，回显提醒漏掉参数，给t赋值为time试试？还是问我时间！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8">😩</span>但是时间一直是变化的呀，，，怎么搞呢？关键在于那个t后面的一串数字是啥，我又去百度了一波CTF中的数字编码，没啥结果。卡住。</p>
<p>求助大佬（emmm，应该不算犯规吧）大佬说那一串数字是<strong>unix时间戳</strong>，百度了一波，相当于那一串数字其实表示的是一个时间</p>
<img src="/2020/07/25/DASCTF/image-20200725172909110.png" alt="image-20200725172909110" style="zoom:67%;">

<p>还是那个问题，该怎么传当前时间？？？当前时间一直在变化的呀。</p>
<p>此处贴出大佬的方法：</p>
<img src="/2020/07/25/DASCTF/image-20200725173059630.png" alt="image-20200725173059630" style="zoom:80%;">

<p>python脚本，，，好吧，我是靠<code>.py</code>这个后缀猜的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span></p>
<p>菜鸡的我再次流下了伤心的类水，咱也不会写python脚本呀（一打开我满是灰尘的pycharm还出错了，大家还是支持正版吧<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>）</p>
<p>不会脚本，只能靠手速了，按照大佬的指导，先转换一个10秒后的时间戳。等到时候再发（妙啊）</p>
<p>一顿操作猛如虎，以为flag呼之欲出了，结果出来的是一堆乱码，淦！</p>
<img src="/2020/07/25/DASCTF/image-20200725173839845.png" alt="image-20200725173839845" style="zoom:50%;">

<p>搞了半天居然没用。。。</p>
<p>后来大佬提示我去看看攻防世界 warmup 这道题的wp,<strong>目录穿越，flag在根目录</strong>，去找了一波wp学习了一下，感觉两个题的确蛮像的，不过那个题源码有提示，这个题看不了源码。我模仿那道题的wp试了试 <code>?file=index.php?/../../../../../../flag</code>不行，又试了试它的各种变形体，失败。我感觉应该没啥问题呀（<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b05.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b05.png?v8">⬅</span>菜鸡的蜜汁自信）</p>
<p>去问大佬这个姿势错在哪,大佬说不是file=而是f=,我照做了，吧上面那个payload里的file改成了f,还是不行呀。</p>
<p>再次寻求help,大佬让我看看时间对不对，一惊，<strong>还得用时间？</strong> （不是说没卵用的吗，，手动狗头，，）</p>
<p>原来每次都必须t=当前时间戳&amp;f=xxx(这边就解释了为啥是f而不是file了，我还是后来才醒悟)  好吧好吧，先去转换一个20秒后的时间戳，打开手机读秒，我感觉到了胜利的曙光<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span></p>
<p>一回车，妈耶，还是不行呀，奥，那个f=xxx，xxx应该像他原来url里那样用base64编一下码的，害，这脑子。去在线编码网站把<code>index.php?/../../../../../../flag</code> base64编码一下，编码完发现它居然后面没有两个==, 我不会又被在线编码网站给制裁了吧？<img src="/2020/07/25/DASCTF/image-20200725180857115.png" alt="image-20200725180857115">将信将疑地将它复制过去，又开始手动传时间（卑微.jpg），居然成功得到了flag!</p>
<p>一波三折，跌宕起伏，柳暗花明。</p>
<hr>
<p><strong>参赛体验：</strong></p>
<p>1.有机会一定学习一下python脚本，手速传时间实在是卑微</p>
<p>2.多刷题！多刷题！多刷题！多涨涨见识才能触类旁通</p>
<p>第一次参赛，纪念一下吧<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p>
<p><img src="/2020/07/25/DASCTF/image-20200725181614351.png" alt="image-20200725181614351"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】线性表基本运算的实现</title>
    <url>/2021/03/11/DSLinearList/</url>
    <content><![CDATA[<h4 id="【数据结构】线性表基本运算的实现"><a href="#【数据结构】线性表基本运算的实现" class="headerlink" title="【数据结构】线性表基本运算的实现"></a>【数据结构】线性表基本运算的实现</h4><pre><code class="line-numbers language-c">/*
  author:Ab4nd0n
  Time:2021-3-11
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 0
#define OK 1
#define Overflow 2
#define Underflow 3
#define NotPresent 4
#define Duplicate 5

typedef int ElemType;
typedef struct
{
    int n;              //元素个数
    int maxlength;      //最大允许长度
    ElemType *element;  //指针变量
} SeqList;

typedef int Status; //自定义类型

//初始化
/*
为顺序表L动态分配一维数组
若动态分配一维数组失败则返回ERROR（0）
*/
Status Init(SeqList *L,int mSize)
{
    L-&gt;n=0;
    L-&gt;maxlength=mSize;
    L-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);
    if(!L-&gt;element)  
    {
        return ERROR;
    }
    return OK;
}

//顺序表的查找(查找元素ai的值,直接定位下标)
/*
首先判断传入的下标i是否越界（0~n-1）
若未越界，则取出element[i]的值传给x返回

算法复杂度为O(1)
*/
Status Find(SeqList *L,int i)
{
    int x;
    if(i&lt;0||i&gt;L-&gt;n-1)
    {
        return ERROR;
    }
    return x=L-&gt;element[i]

}

//顺序表的插入(在ai之后插入，即ai+1的位置)
/*
判断下标i是否越界 （-1~n-1）
判断顺序表存储空间是否已满
将元素ai+1~an-1依次向后移动一个位置
将要插入元素赋值给element[i+1]
表长+1

算法复杂度为O(n)
*/
Status Insert (SeqList *L, int i,ElemType x)
{
    int j;
     if(i&lt;-1||i&gt;L-&gt;n-1)  //注意此处i的范围 是&lt;-1 不是0  ！！！
    {
        return ERROR;
    }
    if(L-&gt;n==L-&gt;maxlength)   //判满
    {
        return ERROR;
    }
    for(j=L-&gt;n-1;j&gt;i;j--)       //通过循环将下标i+1到n-1的元素后移（从后往前）
    {
        L-&gt;element[j+1]=L-&gt;element[j];   //注意是j的值给j+1（从后往前）
    }
    L-&gt;element[i+1]=x; //把插入的 元素放到下标为 i+1 的位置
    L-&gt;n=L-&gt;n+1;      //表长加1
    return OK;

}

//顺序表的删除
/*
判断下标是否越界（0~n-1）
判断顺序表是否为空
将元素ai+1~an-1依次前移一个位置
表长-1

算法复杂度为O(n)
*/
Status Delete(SeqList *L,int i)
{
    int j;
    if(i&lt;0||i&gt;L-&gt;n-1)  return ERROR;  //此处i&lt;0!!!注意和插入区分
    if(!L-&gt;n)  return ERROR;    //判空
    for(j=i+1;j&lt;L-&gt;n;j++)
    {
        L-&gt;element[j-1]=L-&gt;element[j];  //从前往后逐个前移元素，j的值给j-1
    }
    L-&gt;n--;    //表长-1
    return OK;
    
}

//顺序表的输出
Status Output(SeqList *L)
{
    int i;
    if(!L-&gt;n)   return ERROR;   //判空
    for(i=0;i&lt;L-&gt;n;i++)
    {
        printf("%d",L-&gt;element[i]);
    }
    printf("\n\n");
     return OK;
}

//顺序表的销毁
void Destroy(SeqList *L)
{
    L-&gt;n=0;
    L-&gt;maxlength=0;
    free(L-&gt;element);
    printf("Sucessfuly Destroy!\n");
}


int main()
{
    int i,k;
    SeqList List;
    k=Init(&amp;List,10); //因为Init函数的形参是指针变量（地址），所以这里要用取地址符！！！
    printf("%d\n\n",k);   //测试返回值为 1
    for(i=0;i&lt;10;i++)
    {
        Insert(&amp;List,i-1,i);  //执行插入操作
    }
    Output(&amp;List);    // 0123456789
    Delete(&amp;List,2);
    Output(&amp;List);    // 013456789
    Destroy(&amp;List);   // Sucessfuly Destroy!
}
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构 C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构疑问</title>
    <url>/2021/03/16/DSQuestion/</url>
    <content><![CDATA[<h4 id="1-时间复杂度O-1-与O-n-的区别？"><a href="#1-时间复杂度O-1-与O-n-的区别？" class="headerlink" title="1.时间复杂度O(1)与O(n)的区别？"></a>1.时间复杂度O(1)与O(n)的区别？</h4><p><img src="/2021/03/16/DSQuestion/image-20210316215804952.png" alt="image-20210316215804952"></p>
<p><img src="/2021/03/16/DSQuestion/image-20210316220103135.png" alt="image-20210316220103135"></p>
<h4 id="2-随机存取"><a href="#2-随机存取" class="headerlink" title="2.随机存取"></a>2.随机存取</h4><p>根据存储位置是否可计算（是否有一个计算地址的公式）来判断该数据结构是否具备随机存取的特性，如数组知道首地址就可计算后面所有元素的地址</p>
<h4 id="第四章-数组和特殊矩阵"><a href="#第四章-数组和特殊矩阵" class="headerlink" title="第四章  数组和特殊矩阵"></a>第四章  数组和特殊矩阵</h4><h5 id="对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？"><a href="#对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？" class="headerlink" title="对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？"></a>对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？</h5><p>文件压缩有很多种，包含了稀疏矩阵</p>
<h5 id="为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除"><a href="#为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除" class="headerlink" title="为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除"></a>为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除</h5><p>数组是静态数据结构，本质上没有插入和删除运算</p>
<h5 id="为什么稀疏矩阵压缩存储后，必会失去随机存取功能？"><a href="#为什么稀疏矩阵压缩存储后，必会失去随机存取功能？" class="headerlink" title="为什么稀疏矩阵压缩存储后，必会失去随机存取功能？"></a>为什么稀疏矩阵压缩存储后，必会失去随机存取功能？</h5><p>因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素（没有一个计算公式）。</p>
<h5 id="动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？"><a href="#动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？" class="headerlink" title="动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？"></a>动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？</h5><p>先申请一块指定大小的内存块区域</p>
<h5 id="动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？"><a href="#动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？" class="headerlink" title="动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？"></a>动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？</h5><img src="/2021/03/16/DSQuestion/image-20210318140952671.png" alt="image-20210318140952671" style="zoom:80%;">

<p>无论是动态数组还是静态数组，数组长度确定下来后存储空间就确定了，所以静态和动态数组都是静态数据结构</p>
<p>静态数据结构通常不会去定义插入、删除操作</p>
<p><img src="/2021/03/16/DSQuestion/image-20210318141309092.png" alt="image-20210318141309092"></p>
<h5 id="假如数组下标不是从0开始，而是从1开始，会影响到什么？"><a href="#假如数组下标不是从0开始，而是从1开始，会影响到什么？" class="headerlink" title="假如数组下标不是从0开始，而是从1开始，会影响到什么？"></a>假如数组下标不是从0开始，而是从1开始，会影响到什么？</h5><p>lacation计算里会出现一个-1计算</p>
<h5 id="n和t都是未知常数，那O-n-t-复杂度和O-1-有什么区别？稀疏矩阵的快速转置算法中时间复杂度O-n-t-能不能直接写成O-n-？"><a href="#n和t都是未知常数，那O-n-t-复杂度和O-1-有什么区别？稀疏矩阵的快速转置算法中时间复杂度O-n-t-能不能直接写成O-n-？" class="headerlink" title="n和t都是未知常数，那O(n+t)复杂度和O(1)有什么区别？稀疏矩阵的快速转置算法中时间复杂度O(n+t)能不能直接写成O(n)？"></a>n和t都是未知常数，那O(n+t)复杂度和O(1)有什么区别？稀疏矩阵的快速转置算法中时间复杂度O(n+t)能不能直接写成O(n)？</h5><p>n、t都是可变的，是<strong>变量</strong>，所以不能写成O(1)，又不知道n、t哪个大，所以不能写成O(n)或者O(t).在某些情况下，如果知道n,t的大小情况的话是可以写成O(较大的那个)</p>
<h5 id="我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？"><a href="#我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？" class="headerlink" title="我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？"></a>我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？</h5><p>更节省空间的暂无</p>
<p>更易进行矩阵运算的有很多（分块啥的）</p>
<h5 id="用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？"><a href="#用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？" class="headerlink" title="用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？"></a>用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？</h5><h5 id="如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？"><a href="#如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？" class="headerlink" title="如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？"></a>如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？</h5><p>可以查查matlab是怎么实现的</p>
<h5 id="C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？"><a href="#C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？" class="headerlink" title="C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？"></a>C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？</h5><img src="/2021/03/16/DSQuestion/image-20210318140758524.png" alt="image-20210318140758524" style="zoom:80%;">

<h5 id="稀疏矩阵的快速转置算法“快速”的代价是什么？"><a href="#稀疏矩阵的快速转置算法“快速”的代价是什么？" class="headerlink" title="稀疏矩阵的快速转置算法“快速”的代价是什么？"></a>稀疏矩阵的快速转置算法“快速”的代价是什么？</h5><p>存储空间增加了</p>
<h5 id="稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗"><a href="#稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗" class="headerlink" title="稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗"></a>稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗</h5><p>按书上那么做的话是必要的</p>
<p><img src="/2021/03/16/DSQuestion/image-20210318152228362.png" alt="image-20210318152228362"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博客发布时 hexo d 命令报错</title>
    <url>/2021/03/17/GitQues/</url>
    <content><![CDATA[<p>问题描述：</p>
<p>博客闲置了一段时间，最近想在上面记录一些自己遇到的问题和学习上的一些东西，<code>hexo s</code>正常，但是<code>hexo g</code>后进行<code>hexo d</code>时报错：</p>
<p><code>fatal: unable to access ‘https: [//github.com/***](https://github.com/***)’: Failed to connect to [github.com](http://github.com/) port 443:Timed out</code></p>
<p>起初我再执行几次<code>hexo d</code>就可以正常部署了，我也没有在意。但昨天晚上怎么试都不行，就想彻底解决一下。去网上找了很多方法试了都不太行，后来通过下面这两篇博客里的方法进行尝试成功将问题解决，在此记录一下。其实就是将我们的博客重新部署到Github上。（当然，方法不一定适用与每一个人，但应该是一种解决方法）</p>
<p><a href="https://blog.csdn.net/weixin_30940783/article/details/99581061?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-4.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-4.control">针对github权限导致hexo部署失败的解决方案</a></p>
<p><a href="https://blog.csdn.net/qq_43768946/article/details/90411154">Git使用出现git@github.com: Permission denied (publickey). 处理</a></p>
<hr>
<p>emmm,在准备把这篇博客部署的时候hexo d 又报错了，无语了。上面的方法仅供参考吧，今天我找到一种可行的方法。（至少暂时还没翻车）</p>
<p><a href="https://sevencho.github.io/archives/8e3becb8.html">记一次Hexo博客部署缓慢的解决办法</a></p>
<p>加油，打工人！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git Hexo部署</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】单链表的基本运算实现</title>
    <url>/2021/03/12/SingleList/</url>
    <content><![CDATA[<h4 id="【数据结构】单链表的基本运算实现"><a href="#【数据结构】单链表的基本运算实现" class="headerlink" title="【数据结构】单链表的基本运算实现"></a>【数据结构】单链表的基本运算实现</h4><p>关于数据结构中线性表的链接表示的基本运算的实现,把书上单链表的代码敲了一遍，加了些注释。</p>
<span id="more"></span>

<pre><code class="line-numbers language-c">/*
  author:Ab4nd0n
  Time:2021-3-11
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define OK 1
#define ERROR 0

typedef int Status;
typedef int ElemType;

typedef struct node     //节点的结构体
{
    ElemType element;
    struct node *link;
}Node;

typedef struct singleList //单链表的结构体
{
    Node *first;  //first 头指针，用来存放头结点a0的地址
    int n;        //表示单链表中元素的个数
}SingleList;


//单链表的初始化
Status Init(SingleList *L)
{
    L-&gt;first=NULL;
    L-&gt;n=0;
    return OK;
}

//单链表的查找
/*
判断下标i是否越界 0~n-1
若未越界，则从头结点开始顺着单链表逐个结点查找
通过循环让p指向结点ai
将ai的值通过x返回（传值与传址，这边传进来的是地址，操作完会改变实参x的值）
*/
Status Find(SingleList *L,int i,ElemType *x)
{
    int j;
    Node *p;
    if(i&lt;0||i&gt;L-&gt;n-1)   return ERROR;
      
    p=L-&gt;first;          //p指向a0
    for(j=0;j&lt;i;j++)
    {
        p=p-&gt;link;       //执行1次后p指向a1,反复指向下一个结点
    }
    *x=p-&gt;element;
    return OK;
}

//单链表的插入
/*
判断i是否越界 （-1~n-1）
查找ai,指针p指向此节点
生成一个新的结点q，将新结点的数据域置为x，指针q指向此结点
考虑i的取值：若i=-1,表明新结点q插在头结点a0之前，成为新的头结点
            若i&gt;-1,将q所指向的结点插入p所指的结点之后（注意不要断链）
单链表元素个数+1
*/
Status Insert(SingleList  *L,int i,ElemType x)
{
    Node *p,*q;
    int j;
    if(i&lt;-1||i&gt;L-&gt;n-1)
    {
        return  ERROR;
    }
    p=L-&gt;first;          //p指向头指针
    for(j=0;j&lt;i;j++)     //从头开始查找ai
    {
        p=p-&gt;link;
    }
    q=(Node*)malloc(sizeof(Node));      //生成新节点q
    q-&gt;element=x;

    if(i&gt;-1)            //讨论i=-1和i&gt;-1的情况
    {
        q-&gt;link=p-&gt;link;
        p-&gt;link=q;
    }
    else
    {
        q-&gt;link=L-&gt;first; //新节点插在头节点a0之前，成为新的头节点
        L-&gt;first=q;
    }
    L-&gt;n++;
    return OK;
}

//单链表的删除
/*
判断i是否越界（0~n-1）、单链表是否为空
查找元素ai的直接前驱ai-1,并令指针q指向它
考虑i的取值：若i=0,则从单链表中删除头结点
            若i&gt;0，则使p指向ai所在的结点，并删除ai
释放p所指结点的存储空间
单链表元素个数-1
*/
Status Delete(SingleList *L,int i)
{
    int j;
    Node *p,*q;
    if(!L-&gt;n)  
      return ERROR;
    if(i&lt;0||i&gt;L-&gt;n-1)
      return ERROR;
    q=L-&gt;first;
    p=L-&gt;first;
    for(j=0;j&lt;i-1;j++)
      q=q-&gt;link;
    if(i==0)
      L-&gt;first=L-&gt;first-&gt;link;    //删除的是头节点
    else
    {
        p=q-&gt;link;               //p指向ai
        q-&gt;link=p-&gt;link;          //ai+1的地址存到ai-1的指针域中
    }
    free(p);   //释放p所指结点的存储空间
    L-&gt;n--;
    return OK;

}

//单链表的输出
Status Output(SingleList *L)
{
    Node *p;
    if(!L-&gt;n)
        return ERROR;
    p=L-&gt;first;
    while(p)
    {
        printf("%d ",p-&gt;element);
        p=p-&gt;link;
    }
    printf("\n\n");
    return OK;
}

//单链表的销毁
void Destroy(SingleList *L)
{
    Node *p;
    while (L-&gt;first)
    {
        p=L-&gt;first-&gt;link;  //保存后继结点地址，防止断链
        free(L-&gt;first);   //释放first所指结点的存储空间
        L-&gt;first=p;
    }
}


int main()
{
    int i;
    int x;
    SingleList List;
    i=Init(&amp;List);
    printf("%d\n\n",i);     // 1
    for(i=0;i&lt;10;i++)
    {
        Insert(&amp;List,i-1,i);
    }
    Output(&amp;List);    //0 1 2 3 4 5 6 7 8 9
    Find(&amp;List,1,&amp;x);
    printf("The value is : %d\n\n",x);  //1
    Delete(&amp;List,3);
    Output(&amp;List);  //0 1 2 4 5 6 7 8 9
    Destroy(&amp;List);

}

</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构 C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>YCBCTF wp</title>
    <url>/2020/09/10/YCBCTF/</url>
    <content><![CDATA[<p>“羊城杯”，开学后打的一场比赛，由于我实在是太菜了，只会写第一题<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span></p>
<span id="more"></span>

<p>尝试访问一波index.php，页面出现<code>eval post cmd</code>,貌似是一句话木马。</p>
<img src="/2020/09/10/YCBCTF/image-20200910224747632.png" alt="image-20200910224747632" style="zoom:50%;">



<p>尝试用蚁剑连接一下，密码试一下cmd,连接成功！</p>
<img src="/2020/09/10/YCBCTF/image-20200910224833992.png" alt="image-20200910224833992" style="zoom:50%;">



<p>并没有找到flag.php或者含flag字样的东西，倒是发现一个bbbbbbbbb.txt，十分可疑，下载后打开发现是一堆奇奇怪怪的字符。想到可能是图片编码，尝试反向解码。找一个解码网站，将txt中的内容复制进去，显示格式错误。后来了解到要解码还得在前面加上一小串东西：<strong>data:image/jpg;base64,</strong>    解码成功！flag就在图片中，奇怪的知识又增加了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>。</p>
<p><img src="/2020/09/10/YCBCTF/image-20200910224632204.png" alt="image-20200910224632204"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo matery主题代码高亮问题</title>
    <url>/2020/09/26/hexo/</url>
    <content><![CDATA[<p>转载自大佬们的博客:</p>
<p><a href="https://www.jianshu.com/p/f395d92a1110">Hexo博客：六、prism代码高亮</a></p>
<p><a href="https://blog.csdn.net/zemprogram/article/details/104421008">个人博客搭建笔记—-hexo主题代码高亮</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>hexo 代码高亮 matery</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/07/07/test/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>MoeCTF wp</title>
    <url>/2020/08/14/moectf/</url>
    <content><![CDATA[<img src="/2020/08/14/moectf/image-20200816135721888.png" alt="image-20200816135721888" style="zoom:50%;">

<p>MoeCTF，西安电子科技大学的新生赛，作为一个南邮的小菜鸡，成功通过wh1sper师傅提供的后门混入其中:wink:，借此锻炼锻炼自己的能力，同时也为0xGame做准备。冲冲冲！</p>
<span id="more"></span>

<h4 id="1-GET"><a href="#1-GET" class="headerlink" title="1.GET"></a>1.GET</h4><p>这是一道简单的get传参的题，直接在url里传a这个参数<code>?a=flag</code>，即可得到flag</p>
<hr>
<h4 id="2-POST"><a href="#2-POST" class="headerlink" title="2.POST"></a>2.POST</h4><p>这是一道简单的post传参的题，利用hackbar（火狐浏览器的插件，不了解的话可自行百度一下，安装啥的不难的）即可传参，或者利用bp应该也是一样的。</p>
<img src="/2020/08/14/moectf/image-20200814140353992.png" alt="image-20200814140353992" style="zoom:50%;">

<hr>
<h4 id="3-小饼干"><a href="#3-小饼干" class="headerlink" title="3.小饼干"></a>3.小饼干</h4><p>进入页面发现是一个空页面，这时候想到利用bp抓包，观察</p>
<img src="/2020/08/14/moectf/image-20200814140801922.png" alt="image-20200814140801922" style="zoom: 67%;">

<p>发现类似flag的东西。复制提交，发现就是正确的flag</p>
<hr>
<h4 id="4-Introduction"><a href="#4-Introduction" class="headerlink" title="4.Introduction"></a>4.Introduction</h4><p>这个题点进去的话就是很正常的对<strong>moectf</strong>的介绍，点进去源码也没看到flag     (好吧，是我眼瞎，后来才发现flag就在源码里)  尝试抓包，也没找到</p>
<img src="/2020/08/14/moectf/image-20200814142428514.png" alt="image-20200814142428514" style="zoom: 67%;">

<p>考的是眼力:imp:</p>
<hr>
<h4 id="5-一句话木马"><a href="#5-一句话木马" class="headerlink" title="5.一句话木马"></a>5.一句话木马</h4><p>进入题目，发现源码就是一句话木马</p>
<img src="/2020/08/14/moectf/image-20200814142846791.png" alt="image-20200814142846791">

<p>话不多说，直接掏出俺的<strong>蚁剑</strong></p>
<img src="/2020/08/14/moectf/image-20200814143147631.png" alt="image-20200814143147631" style="zoom: 50%;">

<p>这边的话要注意的就是连接密码一定别忘记，<strong>密码就是post后面单引号里的内容</strong>。</p>
<img src="/2020/08/14/moectf/image-20200814143913525.png" alt="image-20200814143913525" style="zoom: 50%;">

<p>连接成功！一般情况下flag就在根目录/下，去到这道题的根目录下的确发现了flag。</p>
<hr>
<h4 id="6-ezmath"><a href="#6-ezmath" class="headerlink" title="6.ezmath"></a>6.ezmath</h4><p>等待填坑</p>
<hr>
<h4 id="7-三心二意"><a href="#7-三心二意" class="headerlink" title="7.三心二意"></a>7.三心二意</h4><p>根据hint及观察代码，这应该是一道考察php弱类型相等的题。</p>
<pre><code class="line-numbers language-php">&lt;?php
$a = $_GET['a'];
$b = $_POST['b'];
$c = $_REQUEST['c'];
$d = $_COOKIE['d'];

if (!isset($a, $b, $c, $d)) {
    highlight_file(__FILE__);
} else {
    if (is_numeric($a) and $a == false) {
        echo 'A is OK!';
        echo '&lt;br/&gt;';
        if (!is_numeric($b) and $b == 0x125e591) {
            echo 'B is OK!';
            echo '&lt;br/&gt;';
            if ($c != 240610708 and md5($c) == md5(240610708)) {
                echo 'C is OK!';
                echo '&lt;br/&gt;';
                if (strlen($d) &lt; 7 and $d != 0 and $d ** 2 == 0) {
                    include('/flag');
                } else {
                    echo "D is not wanted.&lt;br/&gt;";
                    highlight_file(__FILE__);
                }
            } else {
                echo "C is not wanted.&lt;br/&gt;";
                highlight_file(__FILE__);
            }
        } else {
            echo "Too young too simple.&lt;br/&gt;";
            highlight_file(__FILE__);
        }
    } else {
        echo "A is not wanted.&lt;br/&gt;";
        highlight_file(__FILE__);
    }
} 
</code></pre>
<p>u1s1,我刷题的确太少了，对于题目中的几个判断都不是很熟悉，不知道怎么去绕过，一个一个做解释吧:cry:</p>
<ul>
<li><code>is_numeric($a) and $a == false</code></li>
</ul>
<p>此处涉及到**is_numeric()**这个php函数,<strong>is_numeric()</strong> 函数用于检测变量是否为数字或数字字符串,如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE。</p>
<p>也就是说上面这个语句要求a参数是一个数字或字符串，且==false，那挺简单的，0或者null都可以，尝试?a=0,回车一下发现没反应，仔细看源码才发现他要a,b,c,d四个变量都存在才行。</p>
<ul>
<li><p><code>!is_numeric($b) and $b == 0x125e591</code></p>
<p>这个语句的要求是b变量不是数字或字符串并且b==0x125e591，关于0x125e591，我也不太清楚他是个啥，看起来像16进制，百度一波</p>
<img src="/2020/08/14/moectf/image-20200921134750652.png" alt="image-20200921134750652" style="zoom:50%;">

<p>好家伙！直接给我转换出来了。没错了，0x125e591是16进制，转成10进制就是19260817。</p>
<blockquote>
<p>php有两种比较方式,一种是“= =”一种是“= = =”</p>
<p>“= =”：会把两端变量类型转换成相同的，再进行比较。</p>
<p>“= = =”：会先判断两端变量类型是否相同，再进行比较。</p>
<p>这里明确说明，<strong>在两个相等的符号中，一个字符串与一个数字相比较时，字符串会转换成数值</strong>。</p>
<p>当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内，该字符串被当作int来取值。其他所有情况下都被作为float来取值，<strong>该字符串的 开始部分 决定了它的值，如果该字符串以合法的数值开始，则使用该数值， 否则其值为0 。</strong></p>
<p>在进行比较运算时，如果遇到了 0e 这类字符串，PHP会将它解析为 科学计数法</p>
<p>在进行比较运算时，如果遇到了 0x 这类字符串，PHP会将它解析为 十六进制 。</p>
</blockquote>
<p>然后经过大佬指点和我的测试，我发现只需要在19260817后面加上字母就行了:smile_cat:</p>
</li>
<li><p><code>$c != 240610708 and md5($c) == md5(240610708)</code></p>
<p>这个的话主要是md5值的知识，上网一查，md5(‘240610708’)等于md5(‘QNKCDZO’)，于是直接吧c赋值成后面那个字符串。</p>
</li>
<li><p><code>strlen($d) &lt; 7 and $d != 0 and $d ** 2 == 0</code></p>
<p>这个一开始是真的不会，后来还是一个学弟教我的，害。</p>
<p>考点应该是<strong>md5()函数无法处理数组，如果传入的为数组，会返回NULL</strong>（之前应该遇到过，忘记了。。。）</p>
<p>所以此处将d赋值成<code>d[]=0</code>,妙啊。</p>
<p>所以最终传参如下：</p>
<img src="/2020/08/14/moectf/image-20200921143630484.png" alt="image-20200921143630484" style="zoom:67%;"></li>
</ul>
<p>再贴一道与这道题很像的题：（来自CNSS）</p>
<pre><code class="line-numbers language-php">&lt;?php
highlight_file(__FILE__);
$a = $_GET['a'];
$b = $_POST['b'];
$c = $_REQUEST['c'];
$d = $_COOKIE['d'];

if (isset($a) &amp;&amp; !is_numeric($a) &amp;&amp; $a == 114514) {
    echo "A is ok!";
    if (isset($b) &amp;&amp; $b != 0 &amp;&amp; $b ** 2 == 0) {
        echo "B is ok!";
        if (isset($c) &amp;&amp; isset($d) &amp;&amp; $c !== $d &amp;&amp; md5($c) === md5($d)) {
            echo "C is ok!";
            echo "Here is your flag:";
            include('/flag');
        } else {
            die((isset($c) &amp;&amp; isset($d)) ? "Try to search something?" : "C and D is wanted.");
        }
    } else {
        die(isset($b) ? "You need to try again." : "B is wanted.");
    }
} else {
    die(isset($a) ? "Please try another a." : "A is wanted.");
} 
</code></pre>
<hr>
<h4 id="8-俄罗斯头套"><a href="#8-俄罗斯头套" class="headerlink" title="8.俄罗斯头套"></a>8.俄罗斯头套</h4><img src="/2020/08/14/moectf/image-20200814145058030.png" alt="image-20200814145058030" style="zoom:67%;">

<p>点进去后发现这样一句话，觉得应该得<strong>burpsuits</strong>伪造一波ip地址</p>
<p><img src="/2020/08/14/moectf/image-20200814145154603.png" alt="image-20200814145154603"></p>
<p>抓包后添加 <strong>X-Forwarded-For</strong>头，伪造一波ip地址，send一下，得到如下页面</p>
<img src="/2020/08/14/moectf/image-20200814145736400.png" alt="image-20200814145736400" style="zoom:50%;">

<p>然后注意到response里说我得是从<a href="https://www.baidu.com来的，根据之前的做题经验的话，再添加一个**Referer**头即可，如下：">https://www.baidu.com来的，根据之前的做题经验的话，再添加一个**Referer**头即可，如下：</a></p>
<img src="/2020/08/14/moectf/image-20200814150025874.png" alt="image-20200814150025874" style="zoom:50%;">

<p>发现<strong>response</strong>里又要求使用Post请求，这个之前的确没遇到过，观察了一波现有的头，发现第一个头是Get，尝试将其修改为Post后send一波，得到如下信息：</p>
<img src="/2020/08/14/moectf/image-20200814150414403.png" alt="image-20200814150414403" style="zoom:50%;">

<p>好吧，没完了，不愧是俄罗斯头套<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>  不过supreme浏览器是什么鬼，我去百度了一波，靠，好像还真有这个浏览器，不会吧，不会吧，不会要去用这个浏览器去解题吧，那样还得重新配置<strong>burpsuits</strong>.</p>
<p>我去百度了一波burpsuits里浏览器是由哪个头去表示的，发现是由user-Agent去决定的，</p>
<img src="/2020/08/14/moectf/image-20200814150944737.png" alt="image-20200814150944737" style="zoom:50%;">

<p>仔细看了看burpsuits里那个头的内容，发现了一个Firefox，盲猜指的是所用的firefox浏览器，尝试将它改为题目中要求的supreme浏览器， 成功！</p>
<hr>
<h4 id="9-Moe-include"><a href="#9-Moe-include" class="headerlink" title="9.Moe include"></a>9.Moe include</h4><p>看这题目标题，应该和文件包含漏洞有关，点进去看一下：</p>
<p><img src="/2020/08/14/moectf/image-20200816140535894.png" alt="image-20200816140535894"></p>
<p>让我别点，那一定得点一下了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span></p>
<img src="/2020/08/14/moectf/image-20200816140646912.png" alt="image-20200816140646912" style="zoom: 67%;">

<p>发现回显的页面为空，但是注意到url里多了一个<code>?file=hint.php</code></p>
<p>hint是提示的意思，访问hint.php试试，回显的依旧是空页面，抓包看看：</p>
<img src="/2020/08/14/moectf/image-20200816141033076.png" alt="image-20200816141033076" style="zoom:67%;">

<p>看到注释：<strong>你知道php伪协议吗？</strong></p>
<p>不知道的话可以参考参考这篇博客：<a href="https://www.cnblogs.com/zzjdbk/p/13030717.html"></a><a href="https://www.cnblogs.com/zzjdbk/p/13030717.html">php伪协议总结</a></p>
<p>文件包含直接读取的是文件，而不是文件源码，所以要想办法读取源码.结合之前的做题经验，尝试了一下用<code>php://filter</code>去读取文件</p>
<p>尝试构造如下paylaod:<code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></p>
<img src="/2020/08/14/moectf/image-20200816142441015.png" alt="image-20200816142441015" style="zoom:67%;">

<p>然后对得到的字符串进行base64解密即可得到flag.<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span></p>
<hr>
<h4 id="10-Moe-unserialize"><a href="#10-Moe-unserialize" class="headerlink" title="10.Moe unserialize"></a>10.Moe unserialize</h4><p>等待填坑</p>
<hr>
<h4 id="11-EzXXE"><a href="#11-EzXXE" class="headerlink" title="11.EzXXE"></a>11.EzXXE</h4><p>等待填坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2021/07/07/test2/</url>
    <content><![CDATA[<p>111</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>尝试用typora写博客</title>
    <url>/2020/07/03/typora/</url>
    <content><![CDATA[<p>​    昨天花了一番时间搭建好博客后，匆匆用记事本写了一句话作为纪念，将其作为第一条博客测试了一下。成功了，但是总觉得那样写博客有些低效，而且怎么把它搞得花里胡哨呢:question:</p>
<span id="more"></span>

<p>​    在大佬的安利之下，我发现了 <strong>Trpora</strong> 这个强大的软件，今天就用它来写这篇博客。（第一次使用，用意不在内容，而是想测试一下各种花里胡哨的东西​ :smile:）</p>
<p>​    话不多说，测试开始</p>
<p>:boxing_glove:</p>
<ul>
<li><h4 id="首先，测试一下图片的插入-arrow-down-small"><a href="#首先，测试一下图片的插入-arrow-down-small" class="headerlink" title="首先，测试一下图片的插入:arrow_down_small:"></a>首先，测试一下图片的插入:arrow_down_small:</h4><p><img src="/2020/07/03/typora/wallhaven-ox7695.jpg"></p>
</li>
<li><p><img src="/2020/07/03/typora/wallhaven-49e9zx.jpg"></p>
</li>
</ul>
<p><strong>美汁儿汁儿</strong>:call_me_hand:</p>
<ul>
<li><h4 id="接着测试一下超链接"><a href="#接着测试一下超链接" class="headerlink" title="接着测试一下超链接"></a>接着测试一下超链接</h4><p><a href="http://www.baidu.com/">百度</a></p>
<p>ojbk:sunglasses:</p>
</li>
<li><h4 id="搞点代码恰恰-grey-question"><a href="#搞点代码恰恰-grey-question" class="headerlink" title="搞点代码恰恰:grey_question:"></a>搞点代码恰恰:grey_question:</h4><p><code>printf("hello world!");</code></p>
</li>
</ul>
<pre><code class="line-numbers language-c">#include &lt;stdio.h&gt;
int main()
{
    printf("welcome!");
}
</code></pre>
<ul>
<li><h4 id="再整个表？听说Typora这个功能很强啊-black-flag"><a href="#再整个表？听说Typora这个功能很强啊-black-flag" class="headerlink" title="再整个表？听说Typora这个功能很强啊 :black_flag:"></a>再整个表？听说Typora这个功能很强啊 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f3f4.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3f4.png?v8">🏴</span></h4><p><code>ctrl+T</code> 插入表格</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>不知道该制个啥表，先空着吧，网上复制一个去(这功能tql)</p>
<p>好家伙，找半天，没找到合适的，，，，以后再说吧</p>
</li>
</ul>
<ul>
<li><h4 id="引用点东西水一水字数-cold-sweat"><a href="#引用点东西水一水字数-cold-sweat" class="headerlink" title="引用点东西水一水字数:cold_sweat:"></a>引用点东西水一水字数<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span></h4><blockquote>
<p>​        寂坐时，常想到晚明张岱。他写湖心亭：“崇祯五年十二月，余住西湖。大雪三日，湖中人鸟声俱绝。是日更定矣，余拿一小舟，拥毳衣炉火，独往湖心亭看雪。雾淞沆砀，天与云、与山、与水，上下一白。湖上影子，惟长堤一痕，湖心亭一点，与余舟一芥，舟中人两三粒而已。”</p>
<p>​        深夜独自到湖上看大雪，他显然不觉寂寞——寂寞可能是美学的必要。但是，国破家亡、人事全非、当他在为自己写墓志铭的时候呢？</p>
<p>​        蜀人张岱，陶庵其号也。少为纨绔子弟，极爱繁华，好精舍，好美婢，好娈童，好鲜衣，好美食，好骏马，好华灯，好烟火，好梨园，好鼓吹，好古董，好花鸟，兼以茶淫橘虐，书蠹诗魔，劳碌半生，皆成梦幻。年至五十，国破家亡，避迹山居。所存者，破床碎几，折鼎病琴与残书数帙，缺砚一方而已。布衣疏莨，常至断炊。回首二十年前，真如隔世。</p>
<p>​        有一种寂寞，身边添一个可谈的人，一条知心的狗，或许就可以消减。有一种寂寞，茫茫天地之间“余舟一芥”的无边无际无着落，或许只能各自孤独面对，素颜修行吧。</p>
<p>​                                                                                                                                                            ——龙应台《寂寞》</p>
</blockquote>
<hr>
<p>OK，测试暂且到这吧，以后常用的大概就这些了。U1S1，Typora的确是个宝藏软件<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f595.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f595.png?v8">🖕</span></p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构实验一</title>
    <url>/2021/07/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>诗和远方</title>
    <url>/2020/07/20/%E8%AF%97%E8%AF%8D/</url>
    <content><![CDATA[<p>迁客骚人，多会于此。我可能是后者​,​h​h​h<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span></p>
<span id="more"></span>



<h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-西湖"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-西湖" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 西湖"></a>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 西湖</h4><p><strong>&nbsp;六月西湖好，风光小处藏。</strong><br>&nbsp;（仄仄平平仄，平平仄仄平。）<br><strong>&nbsp;苏堤夹岸绿，曲院满池芳。</strong><br>&nbsp;（平平平仄仄，仄仄仄平平。）<br><strong>&nbsp;花港观鱼醉，扁舟水上忙。</strong><br>&nbsp;（平仄平平仄，平平仄仄平。）<br><strong>&nbsp;雷峰夕照晚，自适意悠长。</strong><br>&nbsp;（平平平仄仄，仄仄仄平平。）</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>0xCTF web题 writeup</title>
    <url>/2020/07/05/0xctf/</url>
    <content><![CDATA[<h4 id="1-soeasy"><a href="#1-soeasy" class="headerlink" title="1.soeasy"></a>1.soeasy</h4><p><img src="/2020/07/05/0xctf/image-20200705164040950.jpg" alt="1"></p>
<p>这个题还是蛮简单的，查看源码,稍微找找就能得到flag</p>
<p>稍微总结一下查看源码的方法吧：</p>
<p>a.鼠标右键，点查看源代码</p>
<p>b.<code>F12</code></p>
<p>c.<code>Ctrl+shift+I</code></p>
<p>d.<code>ctrl+U</code></p>
<p>e.在网址前面加上<code>view-source:</code>(火狐反正支持这种方式)</p>
<hr>
<h4 id="2-GET"><a href="#2-GET" class="headerlink" title="2.GET"></a>2.GET</h4><p><img src="/2020/07/05/0xctf/image-20200705165429119.jpg" alt="image-20200705165429119"></p>
<p>稍微判断一下这是一个通过Get方式传参的问题（如果不了解的话提前去了解一下PHP语言，熟悉一下基本语法）</p>
<p>Get方式传参直接在URL后面写上参数并为其赋值即可，本题要传的的参数为0x,值为0xfxxker,故在网址栏应该这么写：</p>
<p><img src="/2020/07/05/0xctf/image-20200705165907235.png" alt="image-20200705165907235"></p>
<p>回车一下就得到了flag.</p>
<hr>
<h4 id="3-POST"><a href="#3-POST" class="headerlink" title="3.POST"></a>3.POST</h4><p><img src="/2020/07/05/0xctf/image-20200705170036059.png" alt="image-20200705170036059"></p>
<p>本题考察的是POST方式传参，我是用火狐插件hackbar来解的（关于hackbar的下载安装并不难，不必装最新版，最新版需要付费，下个旧版就行了，然后关闭自动更新。具体去百度一下）</p>
<p>F12查看源码，然后点Hackbar, <code>laod URL</code>,勾选<code>post date</code>，在下面的框里输入参数并为其赋值，点击<code>Execute</code>就能成功传参，然后flag就有了</p>
<p>当然，用Burpsuit也一样能做，在这不赘述了</p>
<img src="/2020/07/05/0xctf/image-20200705170922230.png" alt="image-20200705170922230" style="zoom: 33%;">



<hr>
<h4 id="4-XFF-amp-Referer"><a href="#4-XFF-amp-Referer" class="headerlink" title="4.XFF&amp;Referer"></a>4.XFF&amp;Referer</h4><p>打开页面只有一句话“只有本地IP才能访问”，刷过攻防世界的新手区的题的话应该会有印象，其实就是伪造一个Ip，然后就可以了</p>
<p>首先利用Burpsuit抓个包，右击发送到repeater,然后在header里面Add一个新的头：<code>X-Forwarded-For</code> , 值为127.0.0.1</p>
<img src="/2020/07/05/0xctf/image-20200705171807465.png" alt="image-20200705171807465" style="zoom:50%;">

<p>点击send（貌似大部分版本是go,小事小事），这时候看右边的响应，多出来一句话“<code>必须来自于：http://0xctf.ctf</code>”</p>
<p>这时同样的方法，在headers中再添加一个名为<code>Refere</code>r的头，值为<code>http://0xctf.ctf</code>,send一下，响应中就出现了flag</p>
<img src="/2020/07/05/0xctf/image-20200705172430570.png" alt="image-20200705172430570" style="zoom: 50%;">

<hr>
<h4 id="5-ezmd5"><a href="#5-ezmd5" class="headerlink" title="5.ezmd5"></a>5.ezmd5</h4><img src="/2020/07/05/0xctf/image-20200705173020907.png" alt="image-20200705173020907" style="zoom: 80%;">

<p>核心是那个if 语句，它要求参数a,b 的值相同但是MD5相同，这里可以利用绕过。（绕过蛮有意思的，当时做这题的时候查了查，觉得有篇博文讲的还蛮好的，在这安利一下：<a href="https://blog.csdn.net/qq_19980431/article/details/83018232">CTF中常见php-MD5()函数漏洞</a>）</p>
<blockquote>
<p>PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。</p>
<p><strong>以下值在md5加密后以0E开头：</strong></p>
<ul>
<li>QNKCDZO</li>
<li>240610708</li>
<li>s878926199a</li>
<li>s155964671a</li>
<li>s214587387a</li>
<li>s214587387a</li>
</ul>
<p><strong>以下值在sha1加密后以0E开头：</strong></p>
<ul>
<li>sha1(‘aaroZmOk’)</li>
<li>sha1(‘aaK1STfY’)</li>
<li>sha1(‘aaO8zKZF’)</li>
<li>sha1(‘aa3OFF9m’)</li>
</ul>
</blockquote>
<p>所以可以将a,b赋值成上面所列的由md5加密后以OE开头的两个不同的值，再采用get方式传参即可。</p>
<p><img src="/2020/07/05/0xctf/image-20200705173943800.png" alt="image-20200705173943800"></p>
<hr>
<h4 id="6-ezmd5-2"><a href="#6-ezmd5-2" class="headerlink" title="6.ezmd5-2"></a>6.ezmd5-2</h4><img src="/2020/07/05/0xctf/image-20200705182529614.png" alt="image-20200705182529614" style="zoom:80%;">

<p>与上一题其实蛮类似的，只不过它的限制又变大了，这次是“===”严格相等，不仅值要相等，类型也要相同</p>
<p><strong>PHP中md5的函数特性</strong></p>
<pre><code class="line-numbers language-php">md5([1,2,3]) == md5([4,5,6]) == NULL
</code></pre>
<p>[1] !== [2] &amp;&amp; md5([1]) === md5([2])<br>所以GET传入<code>a[]=1&amp;b[]=2</code>就能够绕过了。</p>
<hr>
<h4 id="7-跳转"><a href="#7-跳转" class="headerlink" title="7.跳转"></a>7.跳转</h4><p>点开页面只有一句话“flag is not here”,抓一下包看一下响应，发现有个比较特别的响应头,<code>location: youcanfindme.php</code>,</p>
<p>虽然有所发现，但是一开始不知道怎么用，尝试在原来的URL后加了个<code>youcanfindme.php</code>,发现页面没变化，一筹莫展。</p>
<p>后来向大佬求助，我应该再抓一次包的，加了<code>youcanfindme.php</code>后的页面抓包后状态码变成了302（暂时性转移），响应里多了个<code>0xctf: MHhDVEZ7MWY5NGIwMzZiY2NkOTA5Nzg2Yzc3MTVkZTg1NGJmMTh9</code>的头，很可疑，很像flag，但是一般flag不是这种形式啊。原来他用了Base64编码，需要先解码（百度上有很多在线解码的）。解码后就出来一个flag。</p>
<p>稍微总结一下：</p>
<p>​    首先，抓包，send to repeater后观察响应头，在原来的URL后面添加发现的<code>youcanfindme.php</code>,再抓一次包，同样观察响应，发现可疑字符串，利用base64编码进行解码即可</p>
<p><img src="/2020/07/05/0xctf/image-20200705184218489.png" alt="image-20200705184218489" style="zoom:50%;"><img src="/2020/07/05/0xctf/image-20200705184247594.png" alt="image-20200705184247594"></p>
<img src="/2020/07/05/0xctf/image-20200705184247594.png" alt="image-20200705184247594" style="zoom:50%;">

<hr>
<h4 id="8-我爱吃饼干"><a href="#8-我爱吃饼干" class="headerlink" title="8.我爱吃饼干"></a>8.我爱吃饼干</h4><p>点进页面，也是只有一句话<code>You are guest now, only admin can see flag</code></p>
<p>抓个包看看吧</p>
<p>抓包后发现响应头里有这样一个头<code>Set-Cookie: Cookie=eyJ1c2VybmFtZSI6Imd1ZXN0In0%3D</code></p>
<p>首先我尝试的是在请求头里添加一个名为<code>cookie</code>的请求头，并把值赋为<code>eyJ1c2VybmFtZSI6Imd1ZXN0In0%3D</code>,失败！</p>
<p>经过上一道题的毒打，我去试了一下这串字符串是不是又是base64编码，结果如下：</p>
<p><img src="/2020/07/05/0xctf/image-20200705185303601.png" alt="image-20200705185303601"></p>
<p>能看出个大概，但是后面出现了乱码，这时候我尝试了一下在请求头里加了一个名为<code>username</code>的请求头，值为<code>guest</code>,失败！又试了一下把值改成<code>admin</code>依旧不行</p>
<p>这时候就得求助了，大佬告诉我%3D这类字符其实是经过特殊编码的，就像%20代表空格一样</p>
<p>比如在网址栏里输入%3D：</p>
<img src="/2020/07/05/0xctf/image-20200705185957749.png" alt="image-20200705185957749" style="zoom:80%;">

<p>这里的%3D其实就相当于=</p>
<p>我实在太菜了，大佬提示到这我还是没能领略，我尝试将原来的%3D替换成=再解码看看，得到<code>{"username":"guest"}</code></p>
<p>虽然解码正常了。但还是不知道怎么利用这个信息，想想题目那句话“only the admin can see the flag”,我试了一下将<code>{"username":"guest"}</code>中的<code>guest</code> 换成<code>admin</code>，获得一串字符，把这串字符作为请求头cookie 的值，send一波，失败!</p>
<p>此时大佬缓缓打出一个:question:方法对了，但是居然解不出来？</p>
<p>我又重新试了一遍，不行，发现我的base64编码出来的字符串和大佬的不一样，我换了一个在线解码的网站，再解了一次，把字符串作为cookie的值，成功解出flag。（什么？我居然被在线解码网站给克制了:angry:）</p>
<hr>
<h4 id="9-eztrick"><a href="#9-eztrick" class="headerlink" title="9.eztrick"></a>9.eztrick</h4><img src="/2020/07/05/0xctf/image-20200706183947270.png" alt="image-20200706183947270">

<p>起初我是把它当绕过来做的，试了试绕过空格的一些方法，都失败了。</p>
<p>后来大佬告诉我不是空格，而是URL编码显示空字符，让我试试<code>？%E%280%AC=xxx</code>的形式，我试了一下<code>？%E%280%AC=%E%280%AC</code>，成功得到flag</p>
<p><img src="/2020/07/05/0xctf/image-20200706184647653.png" alt="image-20200706184647653"></p>
<hr>
<h4 id="10"><a href="#10" class="headerlink" title="10.$$"></a>10.$$</h4><p><img src="/2020/07/05/0xctf/image-20200706184747544.png" alt="image-20200706184747544"></p>
<p>这题考察变量覆盖   此处安利一篇博客：<a href="https://www.jianshu.com/p/a4d782e91852">变量覆盖漏洞</a></p>
<p>准确说是考察由$$引起的变量覆盖，根据题意，在url后面加上<code>？ctf=0xctf</code>,使其满足if 条件语句即可</p>
<hr>
<h4 id="11-extract"><a href="#11-extract" class="headerlink" title="11.extract"></a>11.extract</h4><p><img src="/2020/07/05/0xctf/image-20200706185409318.png" alt="image-20200706185409318"></p>
<p>这题考察由extract（）函数引起的变量覆盖问题，（关于extract（）函数，可自行百度或者阅读上面的博文:arrow_up:）直接在url后面加上<code>？ctf=0xctf</code>,使其满足if 条件语句即可</p>
<hr>
<h4 id="12-parse-str"><a href="#12-parse-str" class="headerlink" title="12.parse_str"></a>12.parse_str</h4><p><img src="/2020/07/05/0xctf/image-20200706185724337.png" alt="image-20200706185724337"></p>
<p>这题考察的是由parse_str()函数引起的变量覆盖，主要是通过变量覆盖使得Leon1===Leon2</p>
<p>之前在学习变量覆盖的时候见过几道这方面的例题，这道题中的<code>$_SERVER["QUERY_STRING"]</code>是我没见到过的，去百度了一下：</p>
<blockquote>
<p>实例：</p>
<p>1，<a href="http://localhost/aaa/">http://localhost/aaa/</a>** (打开aaa中的index.php)<br>结果：<br>$_SERVER[‘QUERY_STRING’] = “”;<br>$_SERVER[‘REQUEST_URI’] = “/aaa/“;<br>$_SERVER[‘SCRIPT_NAME’] = “/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]   = “/aaa/index.php”;</p>
<p><strong>2，</strong><a href="http://localhost/aaa/?p=222">http://localhost/aaa/?p=222</a> (附带查询)<br>结果：<br>$_SERVER[‘QUERY_STRING’] = “p=222”;<br>$_SERVER[‘REQUEST_URI’] = “/aaa/?p=222”;<br>$_SERVER[‘SCRIPT_NAME’] = “/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]   = “/aaa/index.php”;</p>
<p><strong>3，<a href="http://localhost/aaa/index.php?p=222&amp;q=333">http://localhost/aaa/index.php?p=222&amp;q=333</a></strong><br>结果：<br>$$_SERVER[‘REQUEST_URI’] = “/aaa/index.php?p=222&amp;q=333”;<br>$_SERVER[‘SCRIPT_NAME’] = “/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]   = “/aaa/index.php”;</p>
<p>由实例可知：<br>$_SERVER[“QUERY_STRING”] 获取查询 语句，实例中可知，获取的是?后面的值<br>$</p>
<p>_$SERVER[“REQUEST_URI”]  获取 <a href="http://localhost/">http://localhost</a> 后面的值，包括/<br>$_SERVER[“SCRIPT_NAME”]  获取当前脚本的路径，如：index.php<br>$_SERVER[“PHP_SELF”]   当前正在执行脚本的文件名</p>
</blockquote>
<p>其实对于解题来说并没有太大影响</p>
<p>所以直接在url后面添加<code>？Leon1=abc&amp;Leon2=abc</code>即可</p>
<hr>
<h4 id="13-ezupload"><a href="#13-ezupload" class="headerlink" title="13.ezupload"></a>13.ezupload</h4><p><img src="/2020/07/05/0xctf/image-20200708184237017.png" alt="image-20200708184237017"></p>
<p>页面很简单，易得这是一道考察文件上传的题</p>
<p>上传了一张图片，得到一句话</p>
<p><code>you file: ./sandbox/3a64ab0e3d4f435a3ba6e69810dbcd01/wallhaven-0q6qw7.jpg</code></p>
<p>尝试上传一个.php文件，发现没有提示文件格式不对或者一些其他报错，依旧得到一句话：</p>
<p><code>you file: ./sandbox/e5e655202a8c03687b43d65e6351159b/shell3.php</code></p>
<p>尝试了一下分别把这两段话加到url后面，发现图片能够正常显示，而.php回显的是一个空白页面</p>
<p><img src="/2020/07/05/0xctf/image-20200708191734385.png" alt="image-20200708191734385"></p>
<p>后来去找了找这方面的例题，发现一道和这个有点类似的，它说页面回显的是一个空白页面说明一句话木马成功了（对了，上面用的那个.php文件是一句话木马，如<!--?php @eval($_POST['aaa'])?-->，新建一个空白文档，然后输入这句话，另存为.php文件即可生成）</p>
<p>按照网上的解法，接下来把空白页面的url 复制到中国菜刀链接一下即可，我去网上找了找中国菜刀，试了好多次都不行。（当时我十分怀疑我遇到了假的菜刀:cold_sweat:）</p>
<p>继而去求助大佬，这才知道原来像上面用的那句一句话木马在用菜刀时要输入密码，密码为aaa（密码是一句话木马中post或者get的值，上面那个一句话木马的post的值为aaa,故密码为aaa）.大喜:grin:，以为问题解决了，一试发现还是不行，连接不上。大佬说我可能装了个假菜刀:cold_sweat:此处附上大佬提供的中国菜刀与中国蚁剑的官网网址：</p>
<p><em>中国菜刀</em>：<a href="http://www.maicaidao.co/">http://www.maicaidao.co/</a></p>
<p><em>中国蚁剑</em>：<a href="https://github.com/AntSwordProject/antSword">https://github.com/AntSwordProject/antSword</a></p>
<p>一番波折之后，装上了真·:hocho:,一点添加，依旧没得到想要的结果。大佬建议换成蚁剑试试，成功了！</p>
<p>下面把正确的解题过程重新梳理一下：</p>
<p>首先，准备一个一句话木马（.php文件），然后上传，得到一串类似URL的东西，将它添加到原URL 后面，若回显空页面则说明一句话木马已经成功上传（如果404啥的检查一下URL，多试几次）</p>
<p>准备好中国蚁剑，在空白处右击添加数据，将空页面的URL复制进去，输入密码aaa，点击左上角的添加即可（因为我已经添加过了，所以左上角显示的是保存）</p>
<img src="/2020/07/05/0xctf/image-20200708194242532.png" alt="image-20200708194242532" style="zoom: 67%;">

<p>连接成功后双击打开：</p>
<img src="/2020/07/05/0xctf/image-20200708194638547.png" alt="image-20200708194638547" style="zoom:67%;">

<p>找了找也没找到flag，，，，实在是菜啊:sob:</p>
<p>问了大佬，<strong>flag一般在根目录下</strong>，点开那个<code>/</code>文件夹，在最下面发现了flag文件，点开即可得到flag。</p>
<hr>
<h4 id="14-一键getflag"><a href="#14-一键getflag" class="headerlink" title="14.一键getflag"></a>14.一键getflag</h4><img src="/2020/07/05/0xctf/image-20200709215614854.png" alt="image-20200709215614854" style="zoom:67%;">

<p>点进去，它提示你输入0xCTF网站的IP即可得到flag，菜鸡的我还去百度了一下什么是网站的IP:cold_sweat:</p>
<p>其实就类似127.0.0.1这类的，我查了一下有没有能查询某个指定网站IP的工具，找了一个在线查询的，输入网站的URL后得到网站的IP：<code>39.106.164.8</code></p>
<p>然后一波复制粘贴，发现粘贴不进去，查看源码，发现这样一句话：<input type="text" name="ip" class="form-control" maxlength="4" required=""></p>
<p><strong>maxlength=“4”</strong>说明输入的字符串最大长度为4，而我们的IP地址显然超过了，所以输不进去。想了一下利用Burpsuite抓一波包再改包：</p>
<p>先输入一个4个字符以内的IP。如我输入的是1234，抓包后将IP改为<code>39.106.164.8</code>，再发包即可</p>
<hr>
<h4 id="15-未完成的留言板"><a href="#15-未完成的留言板" class="headerlink" title="15.未完成的留言板"></a>15.未完成的留言板</h4><img src="/2020/07/05/0xctf/image-20200711132555655.png" alt="image-20200711132555655" style="zoom:80%;">

<p>点进去，看一下，是一个留言板</p>
<img src="/2020/07/05/0xctf/image-20200711132711291.png" alt="image-20200711132711291" style="zoom: 33%;">

<p>随便输入一句留言，点击回复</p>
<img src="/2020/07/05/0xctf/image-20200711132823635.png" alt="image-20200711132823635" style="zoom:33%;">

<p>因为题目说flag在fl4g.php，所以我把这个放到URL后面试了一下，跳转出来的还是留言板界面。</p>
<p>查看了一下源码，再抓包看了看，并没有看出什么端倪。于是我查看了提示，提示为：LFI，即本地文件包含，所以本题考查PHP伪协议与本地文件包含漏洞。通过对知识与例题的学习，我尝试了一下用php://filter去读取一下fl4g.php文件，构造如下payload:</p>
<pre><code class="line-numbers language-php">http://ctf.caoyi.site:30002/web8/index.php?file=php://filter/read=convert.base64-encode/resource=fl4g.php
</code></pre>
<p>失败，后来又尝试了一下用php://input的方式写入一句话木马，也失败了（可能是我姿势不对吧:joy:）</p>
<p>继而求助大佬，大佬一针见血地指出了我的问题，上面那个payload里的file参数在本题中并不存在</p>
<p>（的确，由于我是模仿的其他题目的解法，并没完全理解，此处就照搬了file参数</p>
<pre><code class="line-numbers language-php">include($_GET['file']);
</code></pre>
<p>这样的php语句说明file是参数，而本题是action为参数</p>
<pre><code class="line-numbers language-php">include($_GET['action']);
</code></pre>
<p>从点击回复后的url中便可看出<img src="/2020/07/05/0xctf/image-20200711135546090.png" alt="image-20200711135546090" style="zoom:80%;"></p>
<p>所以将上述payload中的file参数修改为action 即可，不不不，事情没有这么简单，我尝试了一下，直接404，好吧，貌似是index.php中并没有action 这个参数，所以应该在action.php 的基础上再去使用php://filter语句，故修改payload为：</p>
<pre><code class="line-numbers language-php">http://ctf.caoyi.site:30002/web8/action.php?action=php://filter/read=convert.base64-encode/resource=fl4g.php
</code></pre>
<p>访问一下，一串base64编码后的字符串一闪而过，然后页面又变成了留言板界面，此时想到的是抓包，使用Burpsuite抓包后发现可疑字符串</p>
<img src="/2020/07/05/0xctf/image-20200711140844022.png" alt="image-20200711140844022" style="zoom: 33%;">

<p>base64解码后即可得到flag</p>
<hr>
<h4 id="16-RCE-bypass"><a href="#16-RCE-bypass" class="headerlink" title="16.RCE bypass"></a>16.RCE bypass</h4><img src="/2020/07/05/0xctf/image-20200716214515665.png" alt="image-20200716214515665" style="zoom:67%;">

<p>这道题前前后后花了些时间，一开始无从下手，题目标题是RCE绕过，关于RCE绕过的姿势也了解了一些（此处安利一篇博客：<a href="https://cloud.tencent.com/developer/article/1599149">《RCE的Bypass与骚姿势总结》</a>），但完全无从下手。前期试了试get方式传一个cmd参数，我试了一下<code>？cmd=1</code>,并没有什么用。后来大佬建议我去了解一下php system 函数，了解了一波后，再结合刚学的Linux命令，想起来攻防世界里的一句话木马那道题当时有个wp就是采用system+cat来解决的。我踌躇满志地打开hackbar, load Url,post date:<code>shell=system('ls');</code>，然而又是啥都没。一番挣扎尝试后再次求助大佬，经过大佬的点播与提示，上述php语句中有两句话应该好好理解：</p>
<pre><code class="line-numbers language-php">$cmd = $_GET['cmd']?$_GET['cmd']:'';
</code></pre>
<p>这句话y中用到了三目运算符？：，如果问号前面的条件成立的话，那么它就执行问号与冒号之间的语句，否则执行冒号后面的语句.</p>
<p>那么这句话的意思就是如果以get方式传入了参数的话，那么他就把这个传入的cmd参数赋值给 $cmd,如果没有传入cmd这个参数的话，那么 cmd就为空。</p>
<pre><code class="line-numbers language-php">if($cmd)
{   system("$cmd"); }
</code></pre>
<p>这个语句表明php用system 函数把cmd这个参数当做系统命令执行，所以其实之前尝试的<code>shell=system('ls');</code>可以以在url 里将cmd 赋值为ls 来代替实现，</p>
<img src="/2020/07/05/0xctf/image-20200716221117992.png" alt="image-20200716221117992" style="zoom:67%;">

<p>此时页面中出现了flag.php和index.php的提示，此时想到利用cmd=cat flag.php的方式来读取文件，但是cat,flag被禁用了，第一时间想到的是用姿势绕过，但大佬说duck不必，<strong>cat被ban了可以用tac，tac被ban 了可以用head，head被ban了还可以用其他的</strong>。一语惊醒梦中人呐，之前在学习Linux命令的时候，的确很多命令都可以完成文件的读取工作。</p>
<blockquote>
<p><strong>小小整理一下，若cat被ban,可以采用以下命令代替：</strong></p>
<p>(1)more:一页一页的显示档案内容 </p>
<p>(2)less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页 （补充一下，如果想退出less，按q键就可以了）</p>
<p>(3)head:查看头几行 (默认是前10行)</p>
<p>(4)tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 </p>
<p>(5)tail:查看尾几行 （默认是后10行）</p>
<p>(6)nl：显示的时候，顺便输出行号 </p>
<p>(7)od:以二进制的方式读取档案内容 </p>
<p>(8)vi:一种编辑器，这个也可以查看</p>
<p>(9)vim:一种编辑器，这个也可以查看</p>
<p>(10)sort:可以查看 </p>
<p>(11)uniq:可以查看</p>
<p>(12)file -f:报错出具体内容   For example:<img src="/2020/07/05/0xctf/image-20200717092841793.png" alt="image-20200717092841793"></p>
<p>关于如何退出vim（命令模式下）</p>
<p>:q，退出(:quit的缩写)</p>
<p>:qL,退出且不保存(:quit的缩写)</p>
<p>:wq,保存并退出</p>
<p>:wq!，保存并退出即使文件没有写入权限(强制保存退出)</p>
<p>:x,保存并退出(类似:wq，但是只有在有更改的情况下才保存):exit,保存并退出(和:x相同)</p>
<p>:qa，退出所有(:quitall的缩写)</p>
<p>:cq，退出且不保存(即便有错误)</p>
</blockquote>
<p>尝试采用tail代替cat，下面应该把flag绕过就ok了，构造如下payload：<code>?cmd=tail fl''ag.php</code>,发现页面没有出现<strong>爪巴</strong>，估计是成功绕过了。</p>
<p>大佬友情提醒，文件内容含有&lt;??&gt;的不会在前端输出，需要查看源码。（由于&lt;??&gt;在前端并不显示，所以此处采用的是编码来让其显示，&lt;在html中可用<code>&amp;lt</code>加上<code>；</code>来显示，同理，&gt;用<code>&amp;gt</code>加<code>；</code>来显示，一定别忘了<code>；</code><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>，更多的这样的转义符可以去百度一下）</p>
<p>查看一波源码，成功得到flag</p>
<p>（这里再插几句，关于那个flag的绕过方式，其实fl*这种也很常见,即通配符绕过</p>
<p>此处再安利一篇博文：<a href="https://www.cnblogs.com/SpouseLJ/p/13223967.html#xcjwjDZd">《CTF下的命令执行漏洞利用及绕过方法总结》</a>。</p>
<p>但是让我很苦恼的是那种拼接方式去构造payload的方式我可能还不太理解，在本题中尝试了好多次也没成功，这个坑先留着，以后来填，或者大佬们评论区指点一波</p>
<p>）</p>
<hr>
<h4 id="17-RCE-bypass-pro"><a href="#17-RCE-bypass-pro" class="headerlink" title="17.RCE_bypass_pro"></a><strong>17.RCE_bypass_pro</strong></h4><img src="/2020/07/05/0xctf/image-20200720210307946.png" alt="image-20200720210307946" style="zoom:50%;">

<p>这道题是RCE的pro版本，料到了绕过有难度。点进去一看，我敲！这么多过滤条件！（手动滑稽_）</p>
<p>稍微理解一下源码：首先要以<code>GET</code>方式传一个<code>ip</code>参数，然后那一长串用于过滤的令人头皮发麻的正则表达式，emmm，怎么说呢，没能完全看懂，但大致能晓得它过滤掉了哪些东西。</p>
<p>先稍微试一试水，我构造了这样一个<code>payload:?ip=d;sort${IFS}fl\ag.php</code></p>
<p>失败，回显  <strong>fxck your symbol!</strong></p>
<p>又仔细看了看，好吧，疏忽了，<code>{}</code>、<code>/</code>貌似都被过滤了，额，<code>{}</code>好解决，空格用<code>$IFS</code>也可以替代，但是flag咋搞呢？</p>
<p>百度了一波，大概要么编码解决，要么用拼接（哎，终究逃不过拼接<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span>）</p>
<p>尝试一波拼接 <img src="/2020/07/05/0xctf/image-20200720214759811.png" alt="image-20200720214759811" style="zoom:67%;"></p>
<p>再次失败，不过这次回显的是  <strong>no flag</strong>,对照源码，应该是咱们的flag没成功绕过，还是被过滤了。</p>
<p>继续百度，我恰巧看到一篇博客里提到了<code>if(preg_match("/.*f.*l.*a.*g.*/", $ip)</code>这个正则表达式，他说这个过滤的话采用一般的拼接不起作用，得换换顺序，因为一旦 f l a g顺序显示，就歇菜了。</p>
<p>OK,那将a,b换换吧，重新构造payload:<img src="/2020/07/05/0xctf/image-20200720215305374.png" alt="image-20200720215305374" style="zoom: 67%;"></p>
<p>成功！！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span></p>
<p>然后我又尝试了一下其他的payload，应该不止这一种解法。继续逛百度，居然发现一道和这道题很像的题<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8">😲</span></p>
<p>去找了找它的wp，由于题目还是有点差异，有些wp中的解法并没成功（也可能是我太菜了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f635.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f635.png?v8">😵</span>），但是经过我的尝试，还是发现了几种骚姿势：</p>
<ul>
<li><img src="/2020/07/05/0xctf/image-20200720220319905.png" alt="image-20200720220319905"></li>
</ul>
<ul>
<li><img src="/2020/07/05/0xctf/image-20200720220434968.png" alt="image-20200720220434968"></li>
</ul>
<p>第二个实在是太骚了，运行后：</p>
<img src="/2020/07/05/0xctf/image-20200720220938545.png" alt="image-20200720220938545" style="zoom:80%;">

<p>菜鸡的我流下了伤心的泪水<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span></p>
<hr>
<h4 id="18-EZupload-2"><a href="#18-EZupload-2" class="headerlink" title="18.EZupload-2"></a>18.EZupload-2</h4><img src="/2020/07/05/0xctf/image-20200731115817516.png" alt="image-20200731115817516" style="zoom:67%;">

<p>依旧是一道文件上传，首先尝试一波上传shell.php,(让自己死心），回显不允许的文件类型。</p>
<p>又尝试了一波双写绕过，加.绕过，都不行，想了一下可能是得上传图片马，首先制作一个图片马：</p>
<p>首先桌面新建一个shell.php文件，写入一句话木马。</p>
<p>然后打开cmd,用<code>cd desktop</code>定位到桌面,<code>copy 1.jpg/b+shell.php/a 3.jpg</code>（前提是你桌面上有1.jpg这张图和shell.php）</p>
<p>用记事本打开3.jpg，将乱码拉倒最后，如果最后有一句话木马就说明制作成功了。（必要的情况下可以把乱码删掉，乱码太多后续可能解析不了）</p>
<p>图片马制作成功，然后也上传成功，但是菜刀和蚁剑都连不上，几番百度，也没发现问题。后来去问大佬，大佬说图片马没办法像php那样被解析，有两种方法：</p>
<ul>
<li><p>文件包含            </p>
</li>
<li><p>.htaccess</p>
<p>似乎豁然开朗，但是我之前上传.htaccess文件的时候它显示不允许的文件类型，大佬说抓包改一下文件类型就可以了（奥，我想起来，之前做那个靶场训练的时候好像遇到过这种题）</p>
<p>此处我当时踩了一个大坑，我的.htaccess文件命名成了1.htaccess，但是其实是不能有文件名的，那个文件直接命名成.htaccess就可</p>
<p>然后关于.htaccess的内容，第一种写法：<code>SetHandler application/x-httpd-php</code></p>
<p>然后还有一种更精准的写法：</p>
<pre><code> &lt;FilesMatch "shell.jpg"&gt;
  SetHandler application/x-httpd-php
 &lt;/FilesMatch&gt;
</code></pre>
<p>（当然这种写法你的图片马的文件名得是shell.jpg）</p>
<img src="/2020/07/05/0xctf/image-20200731122831238.png" alt="image-20200731122831238" style="zoom:67%;"></li>
</ul>
<p>把上面那个文件类型改成<code>image/jpeg</code> 再发包就可了</p>
<img src="/2020/07/05/0xctf/image-20200731123111676.png" alt="image-20200731123111676" style="zoom:67%;">

<p>上传成功！</p>
<p>接着再上传之前的图片木马，上传成功后回显一个地址，访问一波。</p>
<img src="/2020/07/05/0xctf/image-20200731124839807.png" alt="image-20200731124839807" style="zoom:50%;">

<p>应该是成功解析了，这时候将url用蚁剑链接一波，成功链接，然后成功在根目录下找到flag.<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f619.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f619.png?v8">😙</span></p>
<hr>
<h4 id="19-SQL-injection"><a href="#19-SQL-injection" class="headerlink" title="19.SQL_injection"></a>19.SQL_injection</h4><p>这是一道SQL注入的问题，应该不是很难。之前刷过几道sqllib的题，有空一定好好刷.</p>
<p>之前我采用的一直是手工注入，这次一开始也是采用的手工注入，但是出了些问题，后来转向sqlmap,由于我之前的sqlmap文件夹貌似又双叒叕被我误删了，这次使用的是kali自带的sqlmap。</p>
<ul>
<li>第一步，看是否存在注入点：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1' "</code></li>
</ul>
<img src="/2020/07/05/0xctf/image-20200928161245282.png" alt="image-20200928161245282" style="zoom: 67%;">

<p>提示“id”可能是注入点。</p>
<ul>
<li>第二步查看数据库名称：<code>kcm@kali:~$ sqlmap -u"http://59.110.157.4:30010/?id=1' " --dbs</code></li>
</ul>
<img src="/2020/07/05/0xctf/image-20200928161505584.png" alt="image-20200928161505584" style="zoom:67%;">

<p>显示有两个可用的数据库，一个名为 <strong>information_schema</strong>(信息模式？)，另一个名为<strong>user</strong>.</p>
<ul>
<li><p>知道了数据库的名称，接下来就是去查看数据库中的表：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1' " -D information_schema --tables</code></p>
<img src="/2020/07/05/0xctf/image-20200928161847157.png" alt="image-20200928161847157" style="zoom:67%;"></li>
</ul>
<p>自上而下看了半天，没发现flag字眼，暂且搁置，去另一个库康康：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1' " -D information_schema --tables</code></p>
<img src="/2020/07/05/0xctf/image-20200928162050230.png" alt="image-20200928162050230" style="zoom:67%;">

<p>只有简简单单的一个表，很可疑啊，觉得有必要深究一下。</p>
<ul>
<li><p>查看user数据库中user表的列信息：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1'" -D user -T user  --columns</code></p>
<img src="/2020/07/05/0xctf/image-20200928162328554.png" alt="image-20200928162328554" style="zoom:67%;">

<ul>
<li>最后查看你想看的东西就行了，falg应该是字符串，所以我首先查看的是password里的东西：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1'" -D user -T user -C password  --dump</code></li>
</ul>
<img src="/2020/07/05/0xctf/Users/28294/Desktop/无标题.png" alt="无标题" style="zoom:67%;">

<p>flag手动打码<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span></p>
</li>
</ul>
<hr>
<p>未完待续<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CTF  web</tag>
      </tags>
  </entry>
  <entry>
    <title>NJUPT 算法实验（合集）</title>
    <url>/2021/07/06/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h2><p>1用分治法实现一组无序序列的两路合并排序和快速排序。 要求清楚合并排序及快速排 序的基本原理， 编程实现分别用这两种方法将输入的一组无序序列排序为有序序列后输出。 </p>
<p>2采用基于“五元中值组取中值分割法”（median-of-median-of-five partitioning） 的线性<br> 时间选择算法，找出 N 个元素集合 S 中的第 k 个最小的元素，使其在线性时间内解决。（参<br> 考教材 5.5.3 节）</p>
<p>​        <strong>分治法</strong>采用将一个难以直接求解的复杂问题分解成若干个规模较小、相互独立，但类型相同的子问题，直到子问题足够小，能够直接求解为止，然后求解这些子问题，并且将子问题的解合成原始问题的一个完整解的策略。基于这样一种策略，我们可以用它来解决一系列复杂的问题。对于排序问题，将原来的序列分成一个个子序列后分别进行排序，再将已排序的子序列合成一个有序序列是可行的，所以符合分治法策略。不过，合并排序和快速排序虽然都运用分治策略，但两者的角度不同，得到的排序算法也不相同。合并排序的问题分解过程十分简单，只需将序列一分为二即可：而快速排序的问题分解方法相对较困难，需调用Partition函数将一个序列划分为子序列。然而，从子问题解得到原问题解的过程对于快速排序来说异常简单，几乎无须额外的工作；但对于合并排序，则需要调用Merge函数来实现。所以，其实Partition函数和Merge函数是这两种排序算法的核心。而线性时间选择第k小元素这个算法我觉得也是受到了快速排序中的分划方法的启迪，采用分治法策略去求。</p>
<h3 id="1-合并排序与快速排序"><a href="#1-合并排序与快速排序" class="headerlink" title="1.合并排序与快速排序"></a>1.合并排序与快速排序</h3><pre><code class="line-numbers language-c++">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#define INFTY 2147483647;
using namespace std;

class SortableList
{
    public:
        SortableList(int mSize)
        {
            maxSize = mSize;
            l = new int[maxSize];
            n = 0;
        }
        ~SortableList()
    {
    delete[] l;
    }
        void Input();
        void Output();
        void MergeSort();
        void QuickSort();
    private:
        int *l;
        int maxSize;
        int n;
        void Merge(int left,int mid,int right);
        void MergeSort(int left,int right);
        void QuickSort(int left, int right);
        void Swap(int i,int j);
        int Partition(int left, int right);
        
        
};

void SortableList::Merge(int left,int mid,int right)
{
    int *temp = new int[right - left + 1];
    int i = left, j = mid + 1, k = 0;
    while((i&lt;=mid)&amp;&amp;(j&lt;=right))
        if(l[i]&lt;=l[j])
            temp[k++] = l[i++];
        else
            temp[k++] = l[j++];
    while(i&lt;=mid)                //将剩余元素输出
        temp[k++] = l[i++];
    while(j&lt;=right)
        temp[k++] = l[j++];
    for (i = 0, k = left; k &lt;= right;)  //将排好序的有序序列复制到原序列中去
        l[k++] = temp[i++];
}

void SortableList::MergeSort()
{
    MergeSort(0,n-1);
}
void SortableList::MergeSort(int left,int right)
{
    if(left&lt;right)
    {
        int mid = left + (right-left) / 2;
        MergeSort(left,mid);
        MergeSort(mid+1,right);
        Merge(left,mid,right);
    }
}

void SortableList::Swap(int i,int j)
{
    int temp = l[i];
    l[i] = l[j];
    l[j] = temp;
}

int SortableList::Partition(int left,int right)
{
    int i = left, j = right + 1;
    l[n]=INFTY;
    do{
        do
            i++;
        while (l[i]&lt;l[left]);
        do
            j--;
        while (l[j]&gt;l[left]);
        if(i&lt;j)
            Swap(i,j);
    } while (i &lt; j);
    Swap(left,j);
    return j;
}

void SortableList::QuickSort()
{
    QuickSort(0,n-1);
}
void SortableList::QuickSort(int left,int right)
{
    if(left&lt;right)
    {
        int j = Partition(left,right);
        QuickSort(left,j-1);
        QuickSort(j+1,right);
    }
}

// void SortableList::Input()
// {
//     for (int i = 0; i &lt; maxSize;i++)
//     {
//         cin &gt;&gt; l[i];
//         n++;
//     }
// }

void SortableList::Input()
{
    int i = 0;
    ifstream out ("Sort.txt");
    if(!out)
    {
        cout &lt;&lt; "Can not open output file.\n";
        return;
    }
    for (i = 0; i &lt; maxSize;i++)
    {
        out &gt;&gt; l[i];
        n++;
    }
    out.close();
   
}

void SortableList::Output()
{
    for (int i = 0; i &lt; maxSize;i++)
    {
        cout &lt;&lt; l[i] &lt;&lt; " ";
       // cout &lt;&lt; endl;
    }
}

int main()
{
    int key;
    int x, k;
    SortableList list(30);
    cout &lt;&lt; "原始序列：\n" &lt;&lt; endl;
    list.Input();
    list.Output();
    cout &lt;&lt; "\n\n请选择排序算法：【0】两路合并排序  【1】快速排序\n" &lt;&lt; endl;
    cin &gt;&gt; key;
    
    if(key==0)
    {
        list.MergeSort();
    }
    else
        list.QuickSort();
    cout &lt;&lt; "排序后的序列：\n\n";
    list.Output();
   
}
</code></pre>
<h3 id="2-选择第k小元素"><a href="#2-选择第k小元素" class="headerlink" title="2.选择第k小元素"></a>2.选择第k小元素</h3><p>​       求第k小元素其实可以直接通过排序算法将原序列排序好，然后取出第k小元素即可，但是这样的话在最坏情况下的时间复杂度就不是线性的了，比如采用快速排序，那么在最坏情况下时间复杂度为O(n^2)。人们并不满足与这样的时间复杂度，所以继续去优化这样的一个算法，采用二次取中法确定主元的方式使得分划所得的两个子集合的大小相对接近，从而避免了上述最坏情况的发生，使得最坏情况下的时间复杂度也是O(n),我想这就是算法设计与分析的魅力所在，通过应用或设计一种算法去不断优化时空复杂度。</p>
<pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#define INFTY 2147483647;
using namespace std;

class SortableList
{
    public:
        SortableList(int mSize)
        {
            maxSize = mSize;
            l = new int[maxSize];
            n = 0;
        }
        ~SortableList()
    {
    delete[] l;
    }
        void Input();
        void Output();
        void MergeSort();
        int Select(int&amp; x,int k);
        int Ceil(int a,int b);

    private:
        int *l;
        int maxSize;
        int n;
        void Merge(int left,int mid,int right);
        void MergeSort(int left,int right);
        void Swap(int i,int j);
        int Partition(int left, int right);
        int Select(int k,int left,int right,int r);
        
};

void SortableList::Merge(int left,int mid,int right)
{
    int *temp = new int[right - left + 1];
    int i = left, j = mid + 1, k = 0;
    while((i&lt;=mid)&amp;&amp;(j&lt;=right))
        if(l[i]&lt;=l[j])
            temp[k++] = l[i++];
        else
            temp[k++] = l[j++];
    while(i&lt;=mid)                //将剩余元素输出
        temp[k++] = l[i++];
    while(j&lt;=right)
        temp[k++] = l[j++];
    for (i = 0, k = left; k &lt;= right;)  //将排好序的有序序列复制到原序列中去
        l[k++] = temp[i++];
}

void SortableList::MergeSort()
{
    MergeSort(0,n-1);
}
void SortableList::MergeSort(int left,int right)
{
    if(left&lt;right)
    {
        int mid = left + (right-left) / 2;
        MergeSort(left,mid);
        MergeSort(mid+1,right);
        Merge(left,mid,right);
    }
}

void SortableList::Swap(int i,int j)
{
    int temp = l[i];
    l[i] = l[j];
    l[j] = temp;
}

int SortableList::Partition(int left,int right)
{
    int i = left, j = right + 1;
    l[n]=INFTY;
    do{
        do
            i++;
        while (l[i]&lt;l[left]);
        do
            j--;
        while (l[j]&gt;l[left]);
        if(i&lt;j)
            Swap(i,j);
    } while (i &lt; j);
    Swap(left,j);
    return j;
}


void SortableList::Input()
{
    int i = 0;
    ifstream out ("Sort.txt");
    if(!out)
    {
        cout &lt;&lt; "Can not open output file.\n";
        return;
    }
    for (i = 0; i &lt; maxSize;i++)
    {
        out &gt;&gt; l[i];
        n++;
    }
    out.close();
   
}

void SortableList::Output()
{
    for (int i = 0; i &lt; maxSize;i++)
    {
        cout &lt;&lt; l[i] &lt;&lt; " ";
       // cout &lt;&lt; endl;
    }
}

int SortableList::Ceil(int a,int b)
{
    return (int)(a / b) + 1;
}

int SortableList::Select(int&amp;x,int k)
{
    if(n&lt;=0||k&gt;n||k&lt;=0)
        return -1;
    int j = Select(k,0,n-1,5);
    x = l[j];
        return 1;
}

int SortableList::Select(int k,int left,int right,int r)
{
    int n = right - left + 1;
    if(n&lt;=r)
    {
        MergeSort(left,right);
        return left + k - 1;
    }
    for (int i = 1; i &lt; n / r;i++)
    {
        MergeSort(left+(i-1)*r,left+i*r-1);
        Swap(left+i-1,left+(i-1)*r+Ceil(r,2)-1);

    }
    int j = Select(Ceil(n/r,2),left,left+(n/2)-1,r);
    Swap(left,j);
    j = Partition(left,right);
    if(k==j-left+1)
        return j;
    else if(k&lt;j-left+1)
        return Select(k,left,j-1,r);
        else
            return Select(k-(j-left+1),j+1,right,r);

}

int main()
{
    int key;
    int x, k;
    SortableList list(30);
    list.Input();
    list.Output();
    cout &lt;&lt; "\n\n请输入要寻找的第几小元素：\n";
    cin &gt;&gt; k;
    list.Select(x,k);
    cout &lt;&lt; x &lt;&lt; endl;
    //list.Output();
}
</code></pre>
<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><ul>
<li>用动态规划法和备忘录方法实现求两序列的 最长公共子序列问题。 要求掌握动态规划法思想在实际中的应用，分析最长公共子序列的问题特征，选择算法策略并设计具体算法，编程实现两输入序列的比较，并输出它们的最长公共子序列。</li>
<li>用动态规划法和备忘录方法求解矩阵相乘问题， 求得最优的计算次序以使得矩阵连乘总的数乘次数最少，并输出加括号的最优乘法算式。</li>
</ul>
<h3 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1.最长公共子序列"></a>1.最长公共子序列</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
using namespace std;
int const MaxLen = 50;
class LCS
{
    public:
        LCS(int nx,int ny,char *a,char *b);
        ~LCS();
        int LCSLength();
        void CLCS();
        void Output(int **a);
        int** getc()  // 用来访问私有数据成员
        {
            return c;
        };
         int** gets()
        {
            return s;
        };

    private:
        void CLCS(int i,int j);
        int **c, **s;
        int m, n;
        char *x, *y;
};

LCS::LCS(int nx,int ny,char *a,char *b)
{
    m = nx;
    n = ny;
    x = a;
    y = b;
    c = new int *[m + 1];
    s = new int *[m + 1];
    for (int i = 0; i &lt;= m;i++)
    {
        c[i] = new int[n + 1];
        s[i] = new int[n + 1];
    }
}

LCS::~LCS()
{
    for (int i = 0; i &lt; m;i++)
    {
        delete c[i];
        delete s[i];
    }
    delete c;
    delete s;
}

int LCS::LCSLength()
{
    int i,j;
    for ( i = 0; i &lt;= m;i++)
        {
            c[i][0] = 0;
            s[i][0] = 0;
        }
    for (j = 1; j &lt;= n;j++)
        {
            c[0][j] = 0;
            s[0][j] = 0;
        }
    for (i = 1; i &lt;= m;i++)
        {
            for (j = 1; j &lt;= n;j++)
            {
                // if(x[i]==y[i])   !!!!! 应该是y[j]
                // {
                //     c[i][j] = c[i-1][j-1]+ 1;   // 左上格值 + 1
                //     s[i][j] = 1;
                // }
                if(x[i] == y[j])  //由c[i-1][j-1]得到c[i][j]
                {
                    c[i][j] = c[i - 1][j - 1] + 1;
                    s[i][j] = 1;
                }
                else if(c[i-1][j] &gt;= c[i][j-1])    // 左格值 &gt; 上格值
                {
                    c[i][j] = c[i - 1][j];
                    s[i][j] = 2;
                }
                else     //左格值 &lt; 上格值
                {
                    c[i][j] = c[i][j - 1];
                    s[i][j] = 3;
                }
            }
        }    
return c[m][n];      // 返回最优解值
}

void LCS::CLCS(int i,int j)
{
    if(i==0||j==0)
        return;
    if(s[i][j]==1)
    {
        CLCS(i-1,j-1);
        cout &lt;&lt; x[i];
    }else if(s[i][j]==2)
        CLCS(i-1,j);
    else
        CLCS(i, j - 1);
}
void LCS::CLCS()
{
    CLCS(m,n);
}

void LCS::Output(int **a)
{
    
    int i, j;
    printf("  ");
    for (i = 0; i &lt;= n;i++)
    {
        printf("%4d",i);
    }
    printf("\n");
    for (i = 0; i &lt;= m;i++)
    {
        printf("%2d",i);
        for (j = 0; j &lt;= n;j++)
           {
               printf("%4d",a[i][j]);
           }
           printf("\n");
    }
   
}

int main()
{
    // int nx = 7, ny = 6;
    // char *x = (char*)"0abcbdab";
    // char *y = (char*)"0bdcaba";
    
    int nx, ny;
    char *x = new char[MaxLen], *y = new char[MaxLen];
    cout &lt;&lt; "Please input X:(Start with 0, like 0ab)" &lt;&lt; endl;
    scanf("%s", x);
    nx = strlen(x)-1;
    cout &lt;&lt;endl&lt;&lt; "Please input Y:(Start with 0, like 0ab)" &lt;&lt; endl;
    scanf("%s", y);
    ny = strlen(y)-1;
    LCS lcs(nx, ny, x, y);
    cout &lt;&lt;endl&lt;&lt; "The LCSLength of X and Y is: " &lt;&lt; lcs.LCSLength() &lt;&lt; endl&lt;&lt;endl;
    cout &lt;&lt; "The CLCS is: " ;
    lcs.CLCS();
    cout &lt;&lt; endl;
    
    cout &lt;&lt;endl&lt;&lt; "  c  =  " &lt;&lt; endl&lt;&lt;endl;
    lcs.Output(lcs.getc());    // 输出c[i][j]
    cout &lt;&lt;endl&lt;&lt;endl&lt;&lt; "  s  =  " &lt;&lt; endl&lt;&lt;endl;
    lcs.Output(lcs.gets());   // 输出s[i][j]
    delete []x;
    delete []y;
    return 0;
}
</code></pre>
<h3 id="2-矩阵连乘"><a href="#2-矩阵连乘" class="headerlink" title="2.矩阵连乘"></a>2.矩阵连乘</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;  //输出格式头文件
using namespace std;
int const MaxLen = 50;
class MatrixChain
{
    public:
        MatrixChain(int mSize,int *q);
        int MChain();
        int LookupChain();
        void Traceback();
        void Output();

    private:
        void Traceback(int i,int j);
        int LookupChain(int i,int j);
        int *p, **m, **s, n;
};

MatrixChain::MatrixChain(int mSize, int *q)
{  n=mSize;
   m=new int*[n];   s=new int*[n];   p=new int[n+1];
   for(int i=0; i&lt;n; i++)
   {  m[i]=new int [n];   m[i][i]=0;
      s[i]=new int [n];   s[i][i]=0;
         p[i]=q[i];
   }
   p[n]=q[n];
}

int MatrixChain::MChain()
{  //求A[0:n-1]的最优解值
   //for (int i=0;i&lt;n; i++) m[i][i]=0;  //由于构造函数中有了m[i][i]=0的语句，这条可以删除，且备忘录方法输出的s数组对角线就是0，否则不正确。
   for (int r=2; r&lt;=n; r++)
     for (int i=0; i&lt;=n-r; i++) 
                    {   int j=i+r-1;
           m[i][j]=m[i+1][j]+p[i]*p[i+1]*p[j+1];  //m[i][j] 的初值
            s[i][j]=i;
            for (int k=i+1;    k&lt;j; k++) 
                                {  int t=m[i][k]+m[k+1][j]+p[i]*p[k+1]*p[j+1];
                 if (t&lt;m[i][j]) 
                                            {  m[i][j]=t;   s[i][j]=k;
                                            }
                                }
                    }
      return m[0][n-1];
}

void MatrixChain::Traceback(int i,int j)
{
    if(i==j)
    {
        cout &lt;&lt; 'A' &lt;&lt; i;
        return;
    }
    if(i&lt;s[i][j])
        cout &lt;&lt; '(';
    Traceback(i,s[i][j]);
    if(i&lt;s[i][j])
        cout &lt;&lt; ')';
    if(s[i][j]+1&lt;j)
        cout &lt;&lt; '(';
    Traceback(s[i][j]+1,j);
    if(s[i][j]+1&lt;j)
        cout &lt;&lt; ')';

}

void MatrixChain::Traceback()
{
    cout &lt;&lt; '(';
    Traceback(0,n-1);
    cout &lt;&lt; ')';
    cout &lt;&lt; endl;
}

int MatrixChain::LookupChain(int i, int j)
{   if (m[i][j]&gt;0) return m[i][j];                  //子问题已经求解，直接引用
      if(i==j) return 0;                                      //单一矩阵无须计算
      int u=LookupChain(i+1, j)+p[i]*p[i+1]*p[j+1]; //按式（7-9）求最小值
    s[i][j]=i;
    for (int k=i+1; k&lt;j; k++) 
            {  int t=LookupChain(i, k)+LookupChain(k+1, j)+p[i]*p[k+1]*p[j+1];
         if (t&lt;u) 
                        {  u=t;   s[i][j]=k;
                        }
            }
    m[i][j]=u; return u;                           //保存并返回子最优解值
}

int MatrixChain::LookupChain()
{  
    return LookupChain(0, n-1);     //返回A[0:n-1]的最优解值
}

void MatrixChain::Output()
{  int i,j;
  
   cout&lt;&lt;"  m="&lt;&lt;endl;
   cout&lt;&lt;"  ";
   for(j=0; j&lt;n; j++)
                  if(j&lt;2) cout&lt;&lt;setw(4)&lt;&lt;j;
                        else cout&lt;&lt;setw(6)&lt;&lt;j;
   cout&lt;&lt;endl;

   for(i=0; i&lt;n; i++)
   {  cout&lt;&lt;"  "&lt;&lt;i&lt;&lt;" ";
      for(j=0; j&lt;n; j++)
                        {  if(i&lt;j) cout&lt;&lt;setw(6)&lt;&lt;m[i][j];  //setw(6), 指定输出域宽为6
         else if(i==j) cout&lt;&lt;setw(2)&lt;&lt;m[i][j];
            else cout&lt;&lt;setw(6)&lt;&lt;" ";
                        }
         cout&lt;&lt;endl;
   }

   cout&lt;&lt;"  s="&lt;&lt;endl;
   cout&lt;&lt;"    ";
   for(j=0; j&lt;n; j++) cout&lt;&lt;j&lt;&lt;" ";
   cout&lt;&lt;endl;
   for(i=0; i&lt;n; i++)
   {  cout&lt;&lt;"  "&lt;&lt;i&lt;&lt;" ";
      for(j=0; j&lt;n; j++)
      {  if(i&lt;=j) cout&lt;&lt;s[i][j]&lt;&lt;" ";
         else cout&lt;&lt;"  ";
      }
      cout&lt;&lt;endl;
   }
}

int main()
{ 
//   int nn=6,k,k2;
//   int pp[7]={30,35,15,5,10,20,25};
int pp[MaxLen];
int nn,i,k, k2;
cout &lt;&lt; "  请输入连乘矩阵的个数" &lt;&lt; endl;
scanf("%d", &amp;nn);
cout &lt;&lt; "  请输入连乘矩阵的"&lt;&lt;nn+1&lt;&lt;"个维数(以空格隔开)"&lt;&lt; endl;
for (i = 1; i &lt;= nn+1;i++)
    {
        scanf("%d", &amp;pp[i-1]);
    }
MatrixChain mm(nn, pp);
k = mm.MChain();
cout &lt;&lt; "  最少数乘次数k=" &lt;&lt; k &lt;&lt; endl; //最少数乘次数k=15125
mm.Traceback();                          //矩阵连乘次序:(((A0(A1A2))((A3A4)A5))
cout &lt;&lt; endl;
mm.Output();
k2 = mm.LookupChain();
cout &lt;&lt;endl&lt;&lt; "采用备忘录方法：" &lt;&lt; endl;
cout &lt;&lt; "  最少数乘次数k2=" &lt;&lt; k2 &lt;&lt; endl; //最少数乘次数k=15125
mm.Traceback();                            //矩阵连乘次序:(((A0(A1A2))((A3A4)A5))
cout &lt;&lt; endl;
mm.Output();

  
}
</code></pre>
<h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><ul>
<li><p>用回溯法求解 8- 皇后问题，使放置在 8*8 棋盘上的 8 个皇后彼此不受攻击，即：任何两个皇后都不在同一行、同一列或同一斜线上。请输出 8-皇后问题的所有可行解。</p>
</li>
<li><p>用回溯法编写一个递归程序解决如下装载问题： 有 n 个集装箱要装上 2 艘载重分别为 c1和 c2的轮船，其中集装箱 i 的重量为 wi（1≤ i ≤ n） ，且                                ,问是否有一个合理的装载方案可以将这 n 个集装箱装上这 2 艘轮船？如果有，请给出装载方案</p>
<p>提示 ：参考 子集和数问题的求解方法。 </p>
<p>举例 ： 当 n=3， c1=c2=50， 且 w=[10,40,40]时， 可以将集装箱 1 和 2 装到第一艘轮船上，集装箱 3 装到第二艘轮船上；如果 w=[20,40,40]时，无法将这 3 个集装箱都装上轮船。</p>
</li>
</ul>
<h3 id="1-8皇后问题"><a href="#1-8皇后问题" class="headerlink" title="1.8皇后问题"></a>1.8皇后问题</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#define N 8        // 8 皇后
using namespace std;
int count = 0,count2=0;

//判定两个皇后是否在同一列或在同一斜线上
bool Place(int k, int i, int *x)
{
   for(int j = 0; j &lt; k; j++)
   if((x[j] == i) || (abs(x[j] - i) == abs(j - k))) 
       return false;
   return true;
}

//递归函数（求解n皇后问题）
void NQueens(int k, int n, int *x) 
{
    for(int i = 0; i &lt; n; i++)  //显式约束的第一种观点，x[k] = 0,1,···,n-1
    {
        if(Place(k, i, x))  //约束函数
        {
            x[k] = i;
            if(k == n - 1)    
            {
                for(i = 0; i &lt; n; i++) 
                  cout &lt;&lt; x[i] &lt;&lt; " ";  //输出一个可行解
                cout &lt;&lt; endl;
                count ++;
            }
            else
            {
               NQueens(k + 1, n, x);  //深度优先进入下一层
            }
       }
    }
}

void NQueens(int n, int *x)
{
    NQueens(0, n, x);
}

//求非对称解
void NQueens2(int k, int n, int *x) 
{
    static int temp=n;        //求非对称的解
    if(k==0)
        n = int(temp / 2);
    else
        n = temp;
    for(int i = 0; i &lt; n; i++)  //显式约束的第一种观点，x[k] = 0,1,···,n-1
    {
        if(Place(k, i, x))  //约束函数
        {
            x[k] = i;
            if(k == n - 1)    
            {
                for(i = 0; i &lt; n; i++) 
                  cout &lt;&lt; x[i] &lt;&lt; " ";  //输出一个可行解
                cout &lt;&lt; endl;
                count2 ++;
            }
            else
            {
               NQueens2(k + 1, n, x);  //深度优先进入下一层
            }
       }
    }
}

void NQueens2(int n, int *x)
{
    NQueens2(0, n, x);
}

int main()
{
    int queens[N];  //8皇后
    // int count = 0,count2=0;
    for(int i = 0; i &lt; N; i++) 
        queens[i] = -1;
    NQueens(N, queens);
    cout &lt;&lt;endl&lt;&lt; "可行解共有: " &lt;&lt; count &lt;&lt;" 组"&lt;&lt; endl;
    cout &lt;&lt; endl&lt;&lt; " 仅输出非对称解 : " &lt;&lt; endl;
    NQueens2(N, queens);
    cout &lt;&lt;endl&lt;&lt; "非对称可行解共有: " &lt;&lt; count2 &lt;&lt;" 组"&lt;&lt; endl;
    getchar();
    return 0;
}
</code></pre>
<h3 id="2-装载问题"><a href="#2-装载问题" class="headerlink" title="2.装载问题"></a>2.装载问题</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;

using namespace std;

template &lt;class T&gt; 
class Loading  
{ 
private: 
  int  n,  // 集装箱数 
   x[100],   // 当前解 
   bestx[100]; // 当前 第一艘 船的最优解 
T  c1, // 第一艘轮船的核定载重量 
   c2, // 第二艘轮船的核定载重量 
   w[100], // 集装箱重量数组 
   total,  // 所有集装箱重量之和 
   cw,   // 当前 第一艘船的 载重量 
   bestw, // 当前 第一艘 船的最优载重量 
   r;   // 剩余集装箱总重量 
public: 
  Loading()   // 构造函数 
  {
    cout&lt;&lt;"请输入集装箱的数量："&lt;&lt;endl;
    cin&gt;&gt;n;
    cout&lt;&lt;"请输入轮船1、2的载重量："&lt;&lt;endl;
    cin&gt;&gt;c1&gt;&gt;c2;
    cout&lt;&lt;"请输入每个集装箱的重量："&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;w[i];
    }

    r=0;
    cw=0;
    bestw=0;
    for(int i=1;i&lt;=n;i++)
    {
        r=r+w[i];
    }
  }

      ~Loading() // 析构函数
      {
      }
    void Backtrack(int i); // 找到最接近第一艘轮船载重c1 的最佳装载方案，
                                // 最优载重值bestw ，最优解数组bestx 。
    void Show();          // 输出整个装载方案 
}; 
 
template &lt;class T&gt; 
void Loading&lt;T&gt;::Backtrack(int i) 
{  
 if(i&gt;n) //判断是否达到叶子节点
    { //到达叶子节点
        if(cw&gt;bestw)
        {
            for(int j=1;j&lt;=n;j++)
            {
                bestx[j]=x[j];   //把当前解赋给最优解
            }
            bestw=cw;    //把当前载重量赋给当前最优载重量
        }
    }

    r=r-w[i];  //剩余集装箱的总重量
    if(cw+w[i]&lt;=c1) //判断该集装箱到底放不放
    {
        x[i]=1;
        cw=cw+w[i];
        Backtrack(i+1);
        //当节点i的子树延伸结束时要返回i节点
        x[i]=0;
        cw=cw-w[i];

    }
    if(cw+r&gt;bestw) //判断先不放该集装箱后是否还有可行解
    {
        x[i]=0;
        Backtrack(i+1);
    }
    r=r+w[i];

} 
 
template &lt;class T&gt; 
void Loading&lt;T&gt;::Show() 
{
    int c2w=0;
    for(int i=1;i&lt;=n;i++)
    {
        if(bestx[i]==0)
        {
            c2w=c2w+w[i];
        }
    }
    if(c2w&gt;c2)
        cout&lt;&lt;endl&lt;&lt;"装载失败！无法装下所有的集装箱！"&lt;&lt;endl;
    else
    {
        cout &lt;&lt; endl&lt;&lt;"成功装载！" &lt;&lt; endl;
        cout&lt;&lt;"第一艘船所装的集装箱为："&lt;&lt;endl;
        for(int i=1;i&lt;=n;i++)
        {
            if(bestx[i]==1)
                cout&lt;&lt;i&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
        cout&lt;&lt;"第二艘船所装的集装箱为："&lt;&lt;endl;
        for(int i=1;i&lt;=n;i++)
        {
            if(bestx[i]!=1)
                cout&lt;&lt;i&lt;&lt;" ";
        }

    }

} 
 
int  main() 
{ 
  Loading&lt;int&gt; load;
  load.~Loading();
  load.Backtrack(1); 
  load.Show(); 
//   system("pause");
  return 0;
}
</code></pre>
<h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><h3 id="编程一个简单的RSA加、解密系统。"><a href="#编程一个简单的RSA加、解密系统。" class="headerlink" title="编程一个简单的RSA加、解密系统。"></a>编程一个简单的RSA加、解密系统。</h3><ul>
<li><p>假设用户A选择两个素数p和q，计算得到n=pq和Φ(n)=(p-1)(q-1)。选择一个加密密钥e，它小于Φ(n)且与Φ(n)互素。计算解密密钥 d≡ e-1 mod Φ(n)。则用户A公布公开密钥{e,n}，自己拥有私有密钥{d,n}。</p>
</li>
<li><p>用户B使用用户 A 的公开密钥 e 和 n 对报文 M 进行加密，得到 C= Me mod n，并发送给用户 A。</p>
</li>
<li><p>用户A收到加密的报文后，使用自己的私有密钥 d 和 n 对加密报文 C 进行解密，恢复得到明文 M=Cd mod n。</p>
</li>
</ul>
<pre><code class="line-numbers language-c++">#include &lt;iostream&gt;
using namespace std;
int MOD;

//由公开密钥e和n，求私有密钥d
int ext_euclid(int a, int b, int &amp;x, int &amp;y) 
{ 
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int gcd = ext_euclid(b, a % b, x, y);
    int t = x % MOD;
    x = y % MOD;
    y = ((t - a / b * x) % MOD + MOD) % MOD;
    return gcd;
}

int main()
{
    int p, q, i, d;
    cout &lt;&lt; "请输入一个质数 p (如 101) :";
    cin &gt;&gt; p;
    cout &lt;&lt; "请输入一个质数 q (如 113) :";
    cin &gt;&gt; q;
    int n = p * q;
    cout&lt;&lt;"分组加密时，每个分组的大小 n 不能超过 p*q=";
    cout &lt;&lt; n &lt;&lt; endl;

    //求得φ(n)=(p-1)*(q-1)的值
    MOD = (p - 1) * (q - 1);
    cout &lt;&lt; "模φ(n)=(p-1)*(q-1)=";
    cout &lt;&lt; MOD &lt;&lt; endl &lt;&lt; endl;

    //选取与φ(n)互质的公钥e
    int e;
    cout &lt;&lt; "输入与φ(n)互质的公钥 e (如 3533):";
    cin &gt;&gt; e;

    //由e和φ(n)生成私钥d
    int x, y;
    ext_euclid(e, MOD, d, y);
    while(d &lt; 0) 
        d += MOD;
    cout &lt;&lt; "通过调用扩展欧几里德算法，求得密钥d为：" &lt;&lt; d &lt;&lt; endl;

    //利用生成的公钥{e,n}对明文M进行加密
    int M, C;
    cout &lt;&lt; "现在公钥{e,n}、私钥{d,n}均已生成完毕。\n\n请输入需要传输的明文内容进行加密(如9726):";
    cin &gt;&gt; M;
    C = 1;
    for(i = 1; i &lt;= e; i++)
        C = C * M % n;
    cout &lt;&lt;endl&lt;&lt; "-------------------- 加解密完成 ----------------------" &lt;&lt; endl&lt;&lt;endl;
    cout &lt;&lt; "明文M= " &lt;&lt; M &lt;&lt; "  经加密后得到密文C=M^e(mod n):  " &lt;&lt; C &lt;&lt; endl;

    //利用生成的私钥私钥{e,n}对密文C进行解密
    M = 1;
    for(i = 1; i &lt;= d; i++)
        M = M * C % n;
    cout &lt;&lt; "密文C= " &lt;&lt; C &lt;&lt; "  经解密后得到明文M=C^d(mod n):  " &lt;&lt; M &lt;&lt; endl;
    return 0;
}

</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法设计与分析</tag>
        <tag>分治法</tag>
        <tag>动态规划法</tag>
        <tag>回溯法</tag>
        <tag>密码算法</tag>
      </tags>
  </entry>
</search>
